<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-06-07 Fri 21:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Package Formers</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Musa Al-hassy" />
<meta name="description" content="Generalising ADTS, records, typeclasses to “package formers”."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
	     margin-bottom: .2em; }
  .subtitle { text-align: center;
	      font-size: medium;
	      font-weight: bold;
	      margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
	    padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Package Formers</h1>

<style>

/* inline code; see here for other colours: https://www.w3schools.com/colors/colors_names.asp */
code { background: LightGray;
       border-radius: 5px; /* How curvy the borders should be. */
}

table {
    background: pink;
    border-radius: 10px; /* How curvy the borders should be. */
    /* width:90% */

    border-bottom: hidden;
    border-top: hidden;

    /* Put table in the center of the page, horizontally. */
    margin-left:auto;margin-right:auto;
}

/* table ‘d’ata elements */
td {
    border: 1px solid red; padding: 1em;
    /* border: none;
    border-left: 1px solid transparent;
    border-right: 1px solid transparent; */


}

/* Alter visible labels of source blocks */
pre.src-agda:before { content: 'Agda'; }
pre.src-haskell:before { content: 'Agda'; }
pre.src-org:before { content: 'Text'; }

</style>


<div class="org-center">
<p>
<b>Abstract</b>
</p>
</div>

<p>
Editor extension for supporting <a href="https://alhassy.github.io/next-700-module-systems-proposal/">“the next 700 module systems” proposal</a>.
</p>

<div class="org-center">
<p>
<i>Everything here works with Agda version 2.6.0.</i>
</p>
</div>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc6afac4">1. Aim: <i>Scrap the Repetition</i></a></li>
<li><a href="#org2322e5a">2. Global Preconditions</a></li>
<li><a href="#orgc7e1c49">3. Finding Children in the Wild</a></li>
<li><a href="#orgdc81ea7">4. Substrings Delimited by Tokens</a></li>
<li><a href="#org6a1c8d6">5. The <code>package-former</code> Datatype</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc6afac4" class="outline-2">
<h2 id="orgc6afac4"><span class="section-number-2">1</span> Aim: <i>Scrap the Repetition</i></h2>
<div class="outline-text-2" id="text-1">
<p>
We're going to write a code generator in Lisp that is going to interpret
fictitious Agda code &#x2014;henceforth referred to as “700 code”&#x2014;
into currently legitimate Agda code.
</p>

<p>
For example, something like the following, henceforth referred to as <code>test</code>:
</p>
<div class="org-src-container">
<pre class="src src-agda" id="orga7e93a7"><span style="color: #ba2f59; font-weight: bold;">PackageFormer Semigroup</span> (<span style="color: #0000cd;">v</span> :<span style="color: #ba2f59; font-weight: bold;"> Variation</span>) : <span style="color: #cd6600;">Set</span> <span style="color: #cd6600;">where</span>
  <span style="color: #cd6600;">field</span>
    <span style="color: #ba2f59; font-weight: bold;">_&#10814;_</span> :<span style="color: #ba2f59; font-weight: bold;"> Semigroup</span> <span style="color: #0000cd;">v</span> &#8594;<span style="color: #ba2f59; font-weight: bold;"> Semigroup</span> <span style="color: #0000cd;">v</span> &#8594;<span style="color: #ba2f59; font-weight: bold;"> Semigroup</span> <span style="color: #0000cd;">v</span>
   <span style="color: #ba2f59; font-weight: bold;"> Id</span>  :<span style="color: #ba2f59; font-weight: bold;"> Semigroup</span> <span style="color: #0000cd;">v</span>
    <span style="color: #ba2f59; font-weight: bold;">assoc</span> : &#8704; {<span style="color: #0000cd;">x</span> <span style="color: #0000cd;">y</span> <span style="color: #0000cd;">z</span>} &#8594; (<span style="color: #0000cd;">x</span> &#10814; <span style="color: #0000cd;">y</span>) &#10814; <span style="color: #0000cd;">z</span> &#8801; <span style="color: #0000cd;">x</span> &#10814; (<span style="color: #0000cd;">y</span> &#10814; <span style="color: #0000cd;">z</span>)

<span style="color: #ba2f59; font-weight: bold;">Semigroup-semantics</span>  <span style="color: #cd6600;">=</span> <span style="color: #ba2f59; font-weight: bold;"> Semigroup</span> <span style="color: #cd6600;">record</span>
<span style="color: #ba2f59; font-weight: bold;">Semigroup-syntax</span>     <span style="color: #cd6600;">=</span> <span style="color: #ba2f59; font-weight: bold;"> Semigroup</span> <span style="color: #cd6600;">data</span>
<span style="color: #ba2f59; font-weight: bold;">SemigroupOn</span>          <span style="color: #cd6600;">=</span> <span style="color: #ba2f59; font-weight: bold;"> Semigroup</span> <span style="color: #cd6600;">typeclass</span>
</pre>
</div>

<p>
Will behave as if it were written:
</p>
<div class="org-src-container">
<pre class="src src-agda"><span style="color: #cd6600;">record</span> <span style="color: #ba2f59; font-weight: bold;">Semigroup-semantics</span>  : <span style="color: #cd6600;">Set</span> <span style="color: #cd6600;">where</span>
  <span style="color: #cd6600;">field</span>
   <span style="color: #ba2f59; font-weight: bold;"> Carrier</span> : <span style="color: #cd6600;">Set</span>
    <span style="color: #ba2f59; font-weight: bold;">_&#10814;_</span> :<span style="color: #ba2f59; font-weight: bold;"> Carrier</span> &#8594;<span style="color: #ba2f59; font-weight: bold;"> Carrier</span> &#8594;<span style="color: #ba2f59; font-weight: bold;"> Carrier</span>
   <span style="color: #ba2f59; font-weight: bold;"> Id</span>  :<span style="color: #ba2f59; font-weight: bold;"> Carrier</span>
    <span style="color: #ba2f59; font-weight: bold;">assoc</span> : &#8704; {<span style="color: #0000cd;">x</span> <span style="color: #0000cd;">y</span> <span style="color: #0000cd;">z</span>} &#8594; (<span style="color: #0000cd;">x</span> &#10814; <span style="color: #0000cd;">y</span>) &#10814; <span style="color: #0000cd;">z</span> &#8801; <span style="color: #0000cd;">x</span> &#10814; (<span style="color: #0000cd;">y</span> &#10814; <span style="color: #0000cd;">z</span>)

<span style="color: #cd6600;">data</span> <span style="color: #ba2f59; font-weight: bold;">Semigroup-syntax</span> : <span style="color: #cd6600;">Set</span> <span style="color: #cd6600;">where</span>
    <span style="color: #ba2f59; font-weight: bold;">_&#10814;_</span> :<span style="color: #ba2f59; font-weight: bold;"> SemigroupD</span> &#8594;<span style="color: #ba2f59; font-weight: bold;"> SemigroupD</span> &#8594;<span style="color: #ba2f59; font-weight: bold;"> SemigroupD</span>
   <span style="color: #ba2f59; font-weight: bold;"> Id</span>  :<span style="color: #ba2f59; font-weight: bold;"> SemigroupD</span>

<span style="color: #cd6600;">record</span> <span style="color: #ba2f59; font-weight: bold;">SemigroupOn (Carrier</span> : <span style="color: #cd6600;">Set</span>) : <span style="color: #cd6600;">Set</span> <span style="color: #cd6600;">where</span>
  <span style="color: #cd6600;">field</span>
    <span style="color: #ba2f59; font-weight: bold;">_&#10814;_</span> :<span style="color: #ba2f59; font-weight: bold;"> Carrier</span> &#8594;<span style="color: #ba2f59; font-weight: bold;"> Carrier</span> &#8594;<span style="color: #ba2f59; font-weight: bold;"> Carrier</span>
   <span style="color: #ba2f59; font-weight: bold;"> Id</span>  :<span style="color: #ba2f59; font-weight: bold;"> Carrier</span>
    <span style="color: #ba2f59; font-weight: bold;">assoc</span> : &#8704; {<span style="color: #0000cd;">x</span> <span style="color: #0000cd;">y</span> <span style="color: #0000cd;">z</span>} &#8594; (<span style="color: #0000cd;">x</span> &#10814; <span style="color: #0000cd;">y</span>) &#10814; <span style="color: #0000cd;">z</span> &#8801; <span style="color: #0000cd;">x</span> &#10814; (<span style="color: #0000cd;">y</span> &#10814; <span style="color: #0000cd;">z</span>)
</pre>
</div>
<p>
This is a nearly 200% increase in size; that is, our fictitious code will
save us a lot of repetition.
</p>
</div>
</div>

<div id="outline-container-org2322e5a" class="outline-2">
<h2 id="org2322e5a"><span class="section-number-2">2</span> Global Preconditions</h2>
<div class="outline-text-2" id="text-2">
<p>
For this prototype, we have the following <a id="org21406da">constraints</a>:
</p>

<ol class="org-ol">
<li>All package formers have exactly one explicit <code>Variation</code> parameter.
<ul class="org-ul">
<li>They have no other parameters.</li>
</ul></li>

<li>The type of a PackageFormer is <code>Set ℓ</code> where <code>ℓ</code> is the empty string
or an expression of type <code>Level</code>. In-particular, subscript types
are not yet supported.</li>

<li>The <code>where</code> keyword appears on the same line as the <code>PackageFormer</code> key-phrase.</li>

<li>The name of the PackageFormer should not contain <code>PackageFormer</code> as a sub-identifier.</li>

<li>The first child of the package former is the <code>field</code> declaration, on its own line.</li>
</ol>
</div>
</div>
<div id="outline-container-orgc7e1c49" class="outline-2">
<h2 id="orgc7e1c49"><span class="section-number-2">3</span> Finding Children in the Wild</h2>
<div class="outline-text-2" id="text-3">
<p>
Consider the following todo list,
</p>
<div class="org-src-container">
<pre class="src src-org" id="org553db67">+ item 1
  - subitem 1.1
    * subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 1.2
+ item 3
</pre>
</div>

<p>
We would think that <code>item 1</code> has two ‘children’, and, moreover, one grand-child.
Whereas <code>item 2</code> has a single child and <code>item 3</code> is barren.
</p>

<p>
Here's my intuitive algorithm: We obtain the indentation of the first child,
then all subsequent lines with at least that much indentation have the same ancestor.
</p>

<details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> get-indentation Implementation </font> </strong> </summary>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">defun</span> <span style="color: #6c3163; font-weight: bold;">get-indentation</span> <span style="color: #6c3163;">(</span>string<span style="color: #6c3163;">)</span>
  <span style="color: #da8b55;">"How many spaces are there at the front of &#8216;</span><span style="color: #4e3163;">string</span><span style="color: #da8b55;">&#8217;?</span>

<span style="color: #da8b55;">  Property: The resulting number is &#8216;&#8804; length string&#8217;.</span>
<span style="color: #da8b55;">  "</span>
  <span style="color: #6c3163;">(</span><span style="color: #cd6600;">if</span> string <span style="color: #2d9574;">(</span>length <span style="color: #67b11d;">(</span>s-shared-start string <span style="color: #b1951d;">(</span>s-repeat <span style="color: #3a81c3;">(</span>length string<span style="color: #3a81c3;">)</span> <span style="color: #2d9574;">" "</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span> 0<span style="color: #6c3163;">)</span>
<span style="color: #3a81c3;">)</span>
</pre>
</div>

<pre class="example">
get-indentation
</pre>


</details>
<details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> get-children Implementation </font> </strong> </summary>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">cl-defun</span> <span style="color: #6c3163; font-weight: bold;">get-children</span> <span style="color: #6c3163;">(</span>parent the-wild <span style="color: #ba2f59; font-weight: bold;">&amp;key</span> <span style="color: #2d9574;">(</span>then #'identity<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span>
  <span style="color: #da8b55;">"Go into &#8216;</span><span style="color: #4e3163;">the-wild</span><span style="color: #da8b55;">&#8217; seeking out the first occurence of &#8216;</span><span style="color: #4e3163;">parent</span><span style="color: #da8b55;">&#8217;,</span>
<span style="color: #da8b55;">   who once found, ought to have a minimal indentation for its children.</span>

<span style="color: #da8b55;">   &#8220;Minimal&#8221; in that if there are items with a greater indentation,</span>
<span style="color: #da8b55;">    then they are children of children and should be kept.</span>

<span style="color: #da8b55;">   The first input argument is of type &#8216;</span><span style="color: #4e3163;">string</span><span style="color: #da8b55;">&#8217;,</span>
<span style="color: #da8b55;">   the second argument may be of type &#8216;</span><span style="color: #4e3163;">string</span><span style="color: #da8b55;">&#8217; or &#8216;</span><span style="color: #4e3163;">list</span><span style="color: #da8b55;">&#8217; of strings</span>
<span style="color: #da8b55;">   ---if it's a string, we split along new lines---,</span>
<span style="color: #da8b55;">   the optional &#8216;</span><span style="color: #4e3163;">then</span><span style="color: #da8b55;">&#8217; is a function acting on children strings.</span>

<span style="color: #da8b55;">   Result is the parent followed by its children, as a list of lines,</span>
<span style="color: #da8b55;">   where each child has been altered using the optional &#8216;</span><span style="color: #4e3163;">then</span><span style="color: #da8b55;">&#8217; function.</span>
<span style="color: #da8b55;">   Moreover, we also return the rest of the unconsidered portion of &#8216;</span><span style="color: #4e3163;">the-wild</span><span style="color: #da8b55;">&#8217;:</span>
<span style="color: #da8b55;">   Result: ( (cons parent-line children-lines) . unconsidered-remaining-lines )</span>

<span style="color: #da8b55;">   Warning: We do /not/ return the unconsidered prefix of &#8216;</span><span style="color: #4e3163;">the-wild</span><span style="color: #da8b55;">&#8217;; i.e,</span>
<span style="color: #da8b55;">   the porition that does not contain an occurence of &#8216;</span><span style="color: #4e3163;">parent</span><span style="color: #da8b55;">&#8217;.</span>
<span style="color: #da8b55;">   Why? I currently have no need for it, so I throw it away.</span>

<span style="color: #da8b55;">   Implementation: Look at the indentation of the</span>
<span style="color: #da8b55;">   first child, then use that as a lower bound to find the indentation</span>
<span style="color: #da8b55;">   of the remaining children.</span>
<span style="color: #da8b55;">  "</span>

  <span style="color: #6c3163;">(</span><span style="color: #cd6600;">let</span> <span style="color: #2d9574;">(</span> <span style="color: #67b11d;">(</span>lines <span style="color: #b1951d;">(</span><span style="color: #cd6600;">if</span> <span style="color: #3a81c3;">(</span>stringp the-wild<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">(</span>s-lines the-wild<span style="color: #3a81c3;">)</span> the-wild<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
	 <span style="color: #67b11d;">(</span>indentation -1<span style="color: #67b11d;">)</span>
	 <span style="color: #67b11d;">(</span>parent-line nil<span style="color: #67b11d;">)</span> <span style="color: #2d9574;">)</span>
    <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Ensure: lines &#8776; (parent-here . more-lines)</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">while</span> <span style="color: #67b11d;">(</span><span style="color: #cd6600;">and</span> <span style="color: #b1951d;">(</span>car lines<span style="color: #b1951d;">)</span> <span style="color: #b1951d;">(</span>not <span style="color: #3a81c3;">(</span>s-contains? parent <span style="color: #6c3163;">(</span>car lines<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
      <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#8216;</span><span style="color: #4e3163; background-color: #ecf3ec;">and</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#8217; in-case parent is not even in the list, and so we reach nil.</span>
      <span style="color: #67b11d;">(</span><span style="color: #cd6600;">setq</span> lines <span style="color: #b1951d;">(</span>cdr lines<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
      <span style="color: #2d9574;">)</span>

    <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Throw away parent, but keep its contextual line.</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> parent-line <span style="color: #67b11d;">(</span>car lines<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> lines <span style="color: #67b11d;">(</span>cdr lines<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>

    <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">How far is the first child indented?</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> indentation <span style="color: #67b11d;">(</span>get-indentation <span style="color: #b1951d;">(</span>car lines<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>

    <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Keep only the children that have at least this level of indentation.</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> lines&amp;more <span style="color: #67b11d;">(</span><span style="color: #cd6600;">--split-with</span> <span style="color: #b1951d;">(</span>&lt;= indentation <span style="color: #3a81c3;">(</span>get-indentation it<span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span> lines<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> lines <span style="color: #67b11d;">(</span>car lines&amp;more<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> unconsidered <span style="color: #67b11d;">(</span>cadr lines&amp;more<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>

    <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Alter the children according to the given function.</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> lines <span style="color: #67b11d;">(</span>mapcar then lines<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>

    <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Yield the parent line along with the children lines.</span>
    `<span style="color: #2d9574;">(</span> ,<span style="color: #67b11d;">(</span>cons parent-line lines<span style="color: #67b11d;">)</span> . ,unconsidered <span style="color: #2d9574;">)</span>
  <span style="color: #6c3163;">)</span>
<span style="color: #3a81c3;">)</span>
</pre>
</div>

<pre class="example">
get-children
</pre>


</details>

<p>
Let's try this out on our example hierarchy, <code>eh</code>, from earlier.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span>car <span style="color: #6c3163;">(</span>get-children <span style="color: #2d9574;">"+ item 1"</span> eh<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">+ item 1</td>
<td class="org-left">- subitem 1.1</td>
<td class="org-left">* subsubitem 1.1.1</td>
<td class="org-left">- subitem 1.2</td>
</tr>
</tbody>
</table>

<p>
Excellent! Let's looks at the other parents.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span>get-children <span style="color: #2d9574;">"+ item 2"</span> eh<span style="color: #3a81c3;">)</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(+ item 2   - subitem 1.2)</td>
<td class="org-left">+ item 3</td>
</tr>
</tbody>
</table>

<p>
Notice that we found the parent <code>+ item 2</code> and its only child <code>- subitem 1.2</code>, and
we dropped the prefix of <code>eh</code> that did not contain the parent but have kept
the remaining unconsidered portion of <code>eh</code>.
</p>

<p>
Finally, the barren parent.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span>get-children <span style="color: #2d9574;">"+ item 3"</span> eh<span style="color: #3a81c3;">)</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">+ item 3</td>
</tr>
</tbody>
</table>

<p>
Yay :smile:
</p>

<p>
Before we move on, let's try altering a child clause; e.g., I'd like
<code>* subitem 1.1.1</code> to be renamed to <code>* subitem that is super deep</code>.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span>car <span style="color: #6c3163;">(</span>get-children <span style="color: #2d9574;">"+ item 1"</span> eh
 <span style="color: #3a81c3;">:then</span> <span style="color: #2d9574;">(</span><span style="color: #cd6600;">lambda</span> <span style="color: #67b11d;">(</span>x<span style="color: #67b11d;">)</span> <span style="color: #67b11d;">(</span>s-replace <span style="color: #2d9574;">"1.1.1"</span> <span style="color: #2d9574;">"that is super deep"</span> x<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">+ item 1</td>
<td class="org-left">- subitem 1.1</td>
<td class="org-left">* subsubitem that is super deep</td>
<td class="org-left">- subitem 1.2</td>
</tr>
</tbody>
</table>

<p>
Nice :grin:
</p>


<p>
Now the moment of truth, let's try this out on our example.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span>car <span style="color: #6c3163;">(</span>get-children <span style="color: #2d9574;">"PackageFormer"</span> test<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">PackageFormer Semigroup (v : Variation) : Set where</td>
<td class="org-left">field</td>
<td class="org-left"><span class="underline">⨾</span> : Semigroup v → Semigroup v → Semigroup v</td>
<td class="org-left">Id  : Semigroup v</td>
<td class="org-left">assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)</td>
</tr>
</tbody>
</table>

<p>
Also, does the list variant work:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span>car <span style="color: #6c3163;">(</span>get-children <span style="color: #2d9574;">"PackageFormer"</span> <span style="color: #2d9574;">(</span>s-lines test<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">PackageFormer Semigroup (v : Variation) : Set where</td>
<td class="org-left">field</td>
<td class="org-left"><span class="underline">⨾</span> : Semigroup v → Semigroup v → Semigroup v</td>
<td class="org-left">Id  : Semigroup v</td>
<td class="org-left">assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)</td>
</tr>
</tbody>
</table>

<p>
Test-driven development doesn't seem bad 😲
</p>
</div>
</div>

<div id="outline-container-orgdc81ea7" class="outline-2">
<h2 id="orgdc81ea7"><span class="section-number-2">4</span> Substrings Delimited by Tokens</h2>
<div class="outline-text-2" id="text-4">
<div class="org-center">
<p>
<i>How do we find a string delimited by two tokens?</i>
</p>
</div>

<p>
Before we can get to the real stuff, we need to produce a few low-level &#x2014;string manipulation&#x2014;
utilities, so that we can work with higher-level abstract datatypes.
</p>

<ul class="org-ul">
<li><code>substring-delimited</code>: Given <code>prefix</code> and <code>suffix</code>,
this operation takes a string of the form  <code>⋯‘prefix’⟪needle⟫‘suffix’⋯</code> and yields <code>needle</code>.</li>
<li><code>substring-delimited-$</code>: Given <code>"⟪prefix⟫ $here ⟪suffix⟫"</code>
this operation takes a string of the form  <code>⋯‘prefix’⟪needle⟫‘suffix’⋯</code> and yields <code>needle</code>.</li>
</ul>

<details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> substring-delimited Implementation </font> </strong> </summary>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">cl-defun</span> <span style="color: #6c3163; font-weight: bold;">substring-delimited</span>
    <span style="color: #6c3163;">(</span>prefix suffix string <span style="color: #ba2f59; font-weight: bold;">&amp;key</span> preserve-spaces longest-substring<span style="color: #6c3163;">)</span>
  <span style="color: #da8b55;">"Assuming &#8216;</span><span style="color: #4e3163;">string</span><span style="color: #da8b55;">&#8217; &#8776; &#8943;&#8216;</span><span style="color: #4e3163;">prefix</span><span style="color: #da8b55;">&#8217;&#10218;needle&#10219;&#8216;</span><span style="color: #4e3163;">suffix</span><span style="color: #da8b55;">&#8217;&#8943;, return the /first/ such needle</span>
<span style="color: #da8b55;">   by default, unless &#8216;</span><span style="color: #4e3163;">longest-substring</span><span style="color: #da8b55;">&#8217; is true, in which case yield /longest/</span>
<span style="color: #da8b55;">   such needle.</span>

<span style="color: #da8b55;">  Unless &#8216;</span><span style="color: #4e3163;">preserve-spaces</span><span style="color: #da8b55;">&#8217; is true, we convert all adjacent whitespace</span>
<span style="color: #da8b55;">  characters to a single space in the input &#8216;</span><span style="color: #4e3163;">string</span><span style="color: #da8b55;">&#8217; and trim any surrounding</span>
<span style="color: #da8b55;">  whitespace from the resulting output needle string.</span>
<span style="color: #da8b55;">  "</span>

  <span style="color: #6c3163;">(</span><span style="color: #cd6600;">let</span> <span style="color: #2d9574;">(</span>longest-needle context first-ending result<span style="color: #2d9574;">)</span>

    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">unless</span> preserve-spaces <span style="color: #67b11d;">(</span><span style="color: #cd6600;">setq</span> string <span style="color: #b1951d;">(</span>s-collapse-whitespace string<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> context <span style="color: #67b11d;">(</span>concat prefix <span style="color: #2d9574;">".*"</span> suffix<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> longest-needle <span style="color: #67b11d;">(</span>s-chop-prefix prefix
			   <span style="color: #b1951d;">(</span>s-chop-suffix suffix
			     <span style="color: #3a81c3;">(</span>car <span style="color: #6c3163;">(</span>s-match context string<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>

    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> first-ending <span style="color: #67b11d;">(</span>s-index-of suffix longest-needle<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> result <span style="color: #67b11d;">(</span><span style="color: #cd6600;">if</span> <span style="color: #b1951d;">(</span><span style="color: #cd6600;">and</span> <span style="color: #3a81c3;">(</span>not longest-substring<span style="color: #3a81c3;">)</span> first-ending<span style="color: #b1951d;">)</span>
		       <span style="color: #b1951d;">(</span>substring longest-needle 0 <span style="color: #3a81c3;">(</span>1- first-ending<span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span>
		       longest-needle<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">if</span> preserve-spaces result <span style="color: #67b11d;">(</span>s-trim result<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
  <span style="color: #6c3163;">)</span>
<span style="color: #3a81c3;">)</span>
</pre>
</div>
</details>
<details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> substring-delimited-$ Implementation </font> </strong> </summary>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">cl-defun</span> <span style="color: #6c3163; font-weight: bold;">substring-delimited-$</span>
    <span style="color: #6c3163;">(</span>context string <span style="color: #ba2f59; font-weight: bold;">&amp;key</span> preserve-spaces longest-substring<span style="color: #6c3163;">)</span>
  <span style="color: #da8b55;">"Assuming &#8216;</span><span style="color: #4e3163;">context</span><span style="color: #da8b55;">&#8217; = &#8220;&#10218;prefix&#10219; $here &#10218;suffix&#10219;&#8221;</span>
<span style="color: #da8b55;">   and &#8216;</span><span style="color: #4e3163;">string</span><span style="color: #da8b55;">&#8217; &#8776; &#8943;&#8216;</span><span style="color: #4e3163;">prefix</span><span style="color: #da8b55;">&#8217;&#10218;needle&#10219;&#8216;</span><span style="color: #4e3163;">suffix</span><span style="color: #da8b55;">&#8217;&#8943;, return the /first/ such needle</span>
<span style="color: #da8b55;">   by default, unless &#8216;</span><span style="color: #4e3163;">longest-substring</span><span style="color: #da8b55;">&#8217; is true, in which case yield /longest/</span>
<span style="color: #da8b55;">   such needle.</span>

<span style="color: #da8b55;">  Unless &#8216;</span><span style="color: #4e3163;">preserve-spaces</span><span style="color: #da8b55;">&#8217; is true, we convert all adjacent whitespace</span>
<span style="color: #da8b55;">  characters to a single space in the input &#8216;</span><span style="color: #4e3163;">string</span><span style="color: #da8b55;">&#8217; and trim any surrounding</span>
<span style="color: #da8b55;">  whitespace from the resulting output needle string.</span>
<span style="color: #da8b55;">  "</span>

  <span style="color: #6c3163;">(</span><span style="color: #cd6600;">-let</span> <span style="color: #2d9574;">[</span>pre-post <span style="color: #67b11d;">(</span>s-split <span style="color: #2d9574;">"$here"</span> context<span style="color: #67b11d;">)</span><span style="color: #2d9574;">]</span>
    <span style="color: #2d9574;">(</span>substring-delimited <span style="color: #67b11d;">(</span>car pre-post<span style="color: #67b11d;">)</span> <span style="color: #67b11d;">(</span>s-trim <span style="color: #b1951d;">(</span>cadr pre-post<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span> string
     <span style="color: #3a81c3;">:preserve-spaces</span> preserve-spaces <span style="color: #3a81c3;">:longest-substring</span> longest-substring<span style="color: #2d9574;">)</span>
  <span style="color: #6c3163;">)</span>
<span style="color: #3a81c3;">)</span>
</pre>
</div>
</details>

<p>
Suppose a user provides us with an awkwardly spaced PackageFormer header,
our string manipulation setup is robust enough to get at the constituents:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">-let</span> <span style="color: #6c3163;">[</span>header <span style="color: #2d9574;">"PackageFormer  Semigroup   (  v : Variation) : Set (  &#8467;expr)   where"</span><span style="color: #6c3163;">]</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Three kinds of invocations; the last is my preferred choice &#9829;&#8255;&#9829;</span>
  `<span style="color: #6c3163;">(</span> ,<span style="color: #2d9574;">(</span>substring-delimited <span style="color: #2d9574;">"PackageFormer "</span> <span style="color: #2d9574;">"("</span> header <span style="color: #3a81c3;">:preserve-spaces</span> t <span style="color: #3a81c3;">:longest-substring</span> t<span style="color: #2d9574;">)</span>
     ,<span style="color: #2d9574;">(</span>substring-delimited <span style="color: #2d9574;">"PackageFormer "</span> <span style="color: #2d9574;">"("</span> header<span style="color: #2d9574;">)</span>
     ,<span style="color: #2d9574;">(</span>substring-delimited-$ <span style="color: #2d9574;">"PackageFormer $here ("</span> header<span style="color: #2d9574;">)</span>
   <span style="color: #6c3163;">)</span>
<span style="color: #3a81c3;">)</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Semigroup   (  v : Variation) : Set</td>
<td class="org-left">Semigroup</td>
<td class="org-left">Semigroup</td>
</tr>
</tbody>
</table>

<p>
The aim is to eventually have an interface that interacts with an buffer containing Agda code.
To that end, we propose that our fictitious syntax be directly embedded into via special comments,
<code>{-700 ⋯ -}</code>, henceforth referred to as “<a id="org3351147">700-comments</a>”.
</p>

<ul class="org-ul">
<li><code>(buffer-substring-delimited starting-regexp ending-regexp)</code> yields the <i>next</i> portion of the buffer
as a string, relative to the current position of the cursor, that is contained in the ‘parenthesis’
<code>starting-regexp</code> and <code>ending-regexp</code>.</li>

<li><code>(buffer-substring-delimited-whole-buffer starting-regexp ending-regexp)</code> yields <i>all</i> portions of the buffer,
contained in the ‘parenthesis’ <code>starting-regexp</code> and <code>ending-regexp</code>, as a list of strings.

<ul class="org-ul">
<li>Cursor position is saved.</li>
<li>This function let's us obtain the contents of <i>all</i> <a href="#org3351147">700-comments</a>.</li>
</ul></li>
</ul>

<details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> buffer-substring-delimited Implementation </font> </strong> </summary>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">cl-defun</span> <span style="color: #6c3163; font-weight: bold;">buffer-substring-delimited</span> <span style="color: #6c3163;">(</span>start end <span style="color: #ba2f59; font-weight: bold;">&amp;optional</span> <span style="color: #2d9574;">(</span>highlight nil<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span>
  <span style="color: #da8b55;">"</span>
<span style="color: #da8b55;">  Get the current buffer's /next/ available substring that is delimited</span>
<span style="color: #da8b55;">  between the regexp tokens &#8216;</span><span style="color: #4e3163;">start</span><span style="color: #da8b55;">&#8217; up to &#8216;</span><span style="color: #4e3163;">end</span><span style="color: #da8b55;">&#8217;, exclusively.</span>

<span style="color: #da8b55;">  If no tokens are found, an error is thrown.</span>

<span style="color: #da8b55;">  The &#8216;</span><span style="color: #4e3163;">highlight</span><span style="color: #da8b55;">&#8217; option simply highlights the selected region ---visual feedback</span>
<span style="color: #da8b55;">  for the user.</span>
<span style="color: #da8b55;">  "</span>
  <span style="color: #6c3163;">(</span><span style="color: #cd6600;">let</span> <span style="color: #2d9574;">(</span>p1 p2<span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span>re-search-forward start<span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> p1 <span style="color: #67b11d;">(</span>point<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>

    <span style="color: #2d9574;">(</span>re-search-forward end<span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span>backward-word<span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">setq</span> p2 <span style="color: #67b11d;">(</span>point<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>

    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">when</span> highlight <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">do we want to highlight the region?</span>
      <span style="color: #67b11d;">(</span>goto-char p1<span style="color: #67b11d;">)</span>
      <span style="color: #67b11d;">(</span>push-mark p2<span style="color: #67b11d;">)</span>
      <span style="color: #67b11d;">(</span><span style="color: #cd6600;">setq</span> mark-active t<span style="color: #67b11d;">)</span>
    <span style="color: #2d9574;">)</span>

    <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(copy-region-as-kill p1 p2)</span>
    <span style="color: #2d9574;">(</span>buffer-substring-no-properties p1 p2<span style="color: #2d9574;">)</span>
<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>
</details>

<details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> buffer-substring-delimited-whole-buffer Implementation </font> </strong> </summary>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">cl-defun</span> <span style="color: #6c3163; font-weight: bold;">buffer-substring-delimited-whole-buffer</span> <span style="color: #6c3163;">(</span>start end<span style="color: #6c3163;">)</span>
  <span style="color: #da8b55;">"Return a list of all substrings in the current buffer that</span>
<span style="color: #da8b55;">   are delimited by regexp tokens &#8216;</span><span style="color: #4e3163;">start</span><span style="color: #da8b55;">&#8217; and &#8216;</span><span style="color: #4e3163;">end</span><span style="color: #da8b55;">&#8217;, exclusively.</span>
<span style="color: #da8b55;">  "</span>
  <span style="color: #6c3163;">(</span><span style="color: #cd6600;">save-excursion</span>
    <span style="color: #2d9574;">(</span><span style="color: #cd6600;">let</span> <span style="color: #67b11d;">(</span><span style="color: #b1951d;">(</span>l nil<span style="color: #b1951d;">)</span> <span style="color: #b1951d;">(</span>continue t<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
     <span style="color: #67b11d;">(</span>beginning-of-buffer<span style="color: #67b11d;">)</span>

     <span style="color: #67b11d;">(</span><span style="color: #cd6600;">while</span> continue
       <span style="color: #b1951d;">(</span><span style="color: #cd6600;">condition-case</span> nil
	 <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">attemptClause</span>
	 <span style="color: #3a81c3;">(</span><span style="color: #cd6600;">setq</span> l <span style="color: #6c3163;">(</span>cons <span style="color: #2d9574;">(</span>buffer-substring-delimited start end<span style="color: #2d9574;">)</span> l<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
	 <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">recoveryBody</span>
	 <span style="color: #3a81c3;">(</span><span style="color: #dc752f; background-color: #fbf8ef;">error</span> <span style="color: #6c3163;">(</span><span style="color: #cd6600;">setq</span> continue nil<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>

     <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">We've collected items as we saw them, so &#8216;l&#8217; is in reverse.</span>
    <span style="color: #67b11d;">(</span>reverse l<span style="color: #67b11d;">)</span>
    <span style="color: #2d9574;">)</span>
  <span style="color: #6c3163;">)</span>
<span style="color: #3a81c3;">)</span>
</pre>
</div>
</details>

<p>
Here are some possible invocations, the last one being our use case.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Get text delimited by quotes</span>
<span style="color: #3a81c3;">(</span>buffer-substring-delimited <span style="color: #2d9574;">"^\""</span> <span style="color: #2d9574;">"^\""</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Get text delimited by quotes</span>
<span style="color: #3a81c3;">(</span>buffer-substring-delimited <span style="color: #2d9574;">"^</span><span style="color: #dc752f; background-color: #fbf8ef;">\</span><span style="color: #2d9574;">{-"</span> <span style="color: #2d9574;">"^-</span><span style="color: #dc752f; background-color: #fbf8ef;">\</span><span style="color: #2d9574;">}"</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execute the following in an Agda buffer to see this function in action.</span>
<span style="color: #3a81c3;">(</span><span style="color: #cd6600;">setq</span> it <span style="color: #6c3163;">(</span>buffer-substring-delimited-whole-buffer <span style="color: #2d9574;">"^</span><span style="color: #dc752f; background-color: #fbf8ef;">\</span><span style="color: #2d9574;">{-700"</span> <span style="color: #2d9574;">"^-</span><span style="color: #dc752f; background-color: #fbf8ef;">\</span><span style="color: #2d9574;">}"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
So much string meddling, hopefully no more 🙈 :hear<sub>no</sub><sub>evil</sub>: :speak<sub>no</sub><sub>evil</sub>:
</p>
</div>
</div>

<div id="outline-container-org6a1c8d6" class="outline-2">
<h2 id="org6a1c8d6"><span class="section-number-2">5</span> The <code>package-former</code> Datatype</h2>
<div class="outline-text-2" id="text-5">
<p>
For this prototype's <a href="#org21406da">constraints</a>, a PackageFormer will generally declared as
</p>
<div class="org-src-container">
<pre class="src src-agda"><span style="color: #ba2f59; font-weight: bold;">PackageFormer Semigroup</span> (<span style="color: #0000cd;">v</span> :<span style="color: #ba2f59; font-weight: bold;"> Variation</span>) : <span style="color: #cd6600;">Set</span> &#8467; <span style="color: #cd6600;">where</span>
   <span style="color: #cd6600;">field</span>
     &#8942;
</pre>
</div>

<p>
The body, <code>⋮</code>, of such a declaration mentions <code>Semigroup v</code>, which we would like to rewrite
with other names when the package is instantiated. Likewise, we also want to erase or rewrite
the sole parameter, and possibly increment the level. Let's form a type to work with these components
rather than meddle with strings all the time.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">defstruct</span> package-former
  <span style="color: #da8b55;">"Record of components that form a PackageFormer."</span>
  name variation-symbol level fields
<span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
With this in hand, let's produce a robust parser.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">defun</span> <span style="color: #6c3163; font-weight: bold;">parse-package-former</span> <span style="color: #6c3163;">(</span>lines<span style="color: #6c3163;">)</span>
  <span style="color: #da8b55;">"The input &#8216;</span><span style="color: #4e3163;">lines</span><span style="color: #da8b55;">&#8217; must be a list of lines forming a full PackageFormer declaration;</span>
<span style="color: #da8b55;">   e.g., obtained by calling &#8216;</span><span style="color: #4e3163;">get-children</span><span style="color: #da8b55;">&#8217;.</span>

<span style="color: #da8b55;">   It is parsed and a &#8216;</span><span style="color: #4e3163;">package-former</span><span style="color: #da8b55;">&#8217; value is returned.</span>
<span style="color: #da8b55;">  "</span>

  <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Precondition Example, with intentionally strange whitespacing:</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">header &#8776; &#8220;PackageFormer Semigroup   (v : Variation) : Set  ( &#8467;expr)   where&#8221;</span>

  <span style="color: #6c3163;">(</span><span style="color: #cd6600;">-let</span> <span style="color: #2d9574;">[</span>header <span style="color: #67b11d;">(</span>car lines<span style="color: #67b11d;">)</span><span style="color: #2d9574;">]</span>
	       <span style="color: #2d9574;">(</span>make-package-former
		   <span style="color: #3a81c3;">:name</span>             <span style="color: #67b11d;">(</span>substring-delimited-$ <span style="color: #2d9574;">"PackageFormer $here ("</span> header<span style="color: #67b11d;">)</span>
		   <span style="color: #3a81c3;">:variation-symbol</span> <span style="color: #67b11d;">(</span>substring-delimited-$ <span style="color: #2d9574;">"($here : Variation"</span>    header<span style="color: #67b11d;">)</span>
		     <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#8216;</span><span style="color: #4e3163; background-color: #ecf3ec;">level</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#8217; may be &#8220;&#8221;, that's okay.</span>
		   <span style="color: #3a81c3;">:level</span>            <span style="color: #67b11d;">(</span>substring-delimited-$ <span style="color: #2d9574;">"Set $here where"</span>       header<span style="color: #67b11d;">)</span>
		   <span style="color: #3a81c3;">:fields</span>           <span style="color: #67b11d;">(</span>cdr lines<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
  <span style="color: #6c3163;">)</span>
<span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
Let's try this out.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span>parse-package-former <span style="color: #6c3163;">(</span>car <span style="color: #2d9574;">(</span>get-children <span style="color: #2d9574;">"PackageFormer"</span> test<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">#s(package-former Semigroup v  (  field     <span class="underline">⨾</span> : Semigroup v → Semigroup v → Semigroup v     Id  : Semigroup v     assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)))</td>
</tr>
</tbody>
</table>

<p>
Conversely, let's have a pretty printer &#x2014;for testing purposes, if anything.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">cl-defmethod</span> <span style="color: #6c3163; font-weight: bold;">show</span> <span style="color: #6c3163;">(</span><span style="color: #2d9574;">(</span>p package-former<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span>
  <span style="color: #da8b55;">"Pretty print a package-former record value"</span>

  <span style="color: #6c3163;">(</span>concat
    <span style="color: #2d9574;">(</span>format <span style="color: #2d9574;">"PackageFormer %s (%s : Variation) : Set %swhere\n"</span>
	    <span style="color: #67b11d;">(</span>package-former-name p<span style="color: #67b11d;">)</span>
	      <span style="color: #67b11d;">(</span>package-former-variation-symbol p<span style="color: #67b11d;">)</span>
	      <span style="color: #67b11d;">(</span>package-former-level p<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span>s-join <span style="color: #2d9574;">"\n"</span> <span style="color: #67b11d;">(</span>package-former-fields p<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
  <span style="color: #6c3163;">)</span>
<span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
At a first glance, <code>%swhere\n"</code> is in desperate need of some spacing, however
this space miserliness permits us to phrase an approximation of the opinion
that parsing and showing should be inverses.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #3a81c3;">(</span><span style="color: #cd6600;">-let</span> <span style="color: #6c3163;">[</span>pf <span style="color: #2d9574;">(</span>car <span style="color: #67b11d;">(</span>get-children <span style="color: #2d9574;">"PackageFormer"</span> _test<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">]</span>
  <span style="color: #6c3163;">(</span>equal <span style="color: #2d9574;">(</span>s-join <span style="color: #2d9574;">"\n"</span> pf<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">(</span>show <span style="color: #67b11d;">(</span>parse-package-former pf<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span>
  <span style="color: #3a81c3;">)</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">t</td>
</tr>
</tbody>
</table>
<div class="org-center">
<p>
( <i>In Lisp, <code>t</code> denotes “true”!</i> )
</p>
</div>
</div>
</div>
</div>
</body>
</html>
