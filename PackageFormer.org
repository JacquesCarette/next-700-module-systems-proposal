# (org-babel-load-file "PackageFormer.org")
# Export all Lisp blocks into a file then load it.
#
# (setq test outsidetest)
# (defun org-strip-quotes (x) (prin1-to-string x t))
# (defun org-strip-quotes (x) "Testing.agda")

# To do:
# + Form library of common or useful variations or combinators, using the meta-primitives.
#   - renaming :: Given a function f, apply it to all names.
#   - map-elements f :: Apply function f to each element.
#   - prefix-elements :: Given a list of new elements, prepend them to the current list of elements.
#   - postfix-elements :: Given a list of new elements, postpend them to the current list of elements.
#   - drop-elements :: Given a predicate, drop the fields that satisfy it.
#     - Moreover, drop additional fields if they depend on dropped fields? (maybe).
#   - opening f :: Module renaming according to f.
#   - manifest :: Mention one form; briefly mention others.

#   Note that package formation has been liberated from the backend and brought to the user
#   via our 5 meta-primitives: preamble, kind, waist, waist-strings, level, alter-elements.

# + Allow “:level” to be ‘inc, dec, omit’ where the last option omits the “: Set ℓ” declaration altogether.
#   - Useful for module setups.

# + Make a “raw” variation that allows meta-primitives to be invoked whenever.
#   - Maybe called 𝓌𝒾𝓉𝒽 ?
#     ➱ Look at load variations, if there are any 𝓌𝒾𝓉𝒽 clauses, then add them to the
#        variation's pairs. assoc ensures only latest items are picked up and so
#        these would overwrite whatever the variation wanted; neato.
#        Perhaps check that 𝓌𝒾𝓉𝒽 clauses only allow meta-primitives?

* COMMENT Changelog
1. Dropped the *builtin* variation tags, ‘v’,
   in-favour of *extensible* “variationals”
   ---which may even have arguments! ♥‿♥

   → §2.3 demonstrates how to use meta-primitives to
     form common built-in operations.
   → §2.4 uses the variationals from §2.3 to solve
     a common problem.

   The monster functions “instantiate” and “reify-package-formers”
   are now much much more manageable: All the built-in logic to
   cater to particular operations on grouping mechanisms has been
   thrown away in favour of a general template.

2. Solve the single-sorted problem.
   → Motivating example in §1 is now two sorted!
   → §2.3 shows how it can be used and even reduced to a single sort.

3. Massive re-organisation:
   → At the document level
   → At the code level
   → At the design level
     ➱ The presentation of PackageFormers has changed from that in
       the thesis proposal and in Paper0.

* Preamble :ignore:
:Idea:
TODO: Maintain a list of instantations-loaded, then use that to obtain
the elements of an instance to determine how an ‘opening’ should be
performed. For example, given ⟪params ❙ fields⟫ we know that the
opening module must have ⟪params, ℛ : instance⟫ as parameters,
and the remaining list of fields will then avilable for renaming.
This scheme will work for arbitrary typeclasses ^_^
:End:

#+TITLE: Making Modules with Meta-Programmed Meta-Primitives
#+SUBTITLE: Liberating Package Formation from the Backend
# Prototyping PackageFormers with Elisp
#+DESCRIPTION: Generalising ADTS, records, typeclasses to “package formers”.
#+AUTHOR: Musa Al-hassy
#+EMAIL: alhassy@gmail.com
#+PROPERTY: header-args :results none :tangle no :comments link :noweb yes

#+CATEGORIES: Agda MetaProgramming Lisp
#+OPTIONS: html-postamble:nil toc:nil d:nil tag:nil

# IMAGE: ../assets/img/org_logo.png
# SOURCE: https://raw.githubusercontent.com/alhassy/org-agda-mode/master/literate.lagda

#+TODO: TODO | Future
:Threading_Remarks:

;; The “thread-first x forms” syntax feeds initial value ‘x’ as the first argument into the
;; next form, which in-turn is then fed as the first argument to the form following it, and so on.
;; It provides a nice way to avoid lots of parenthesising on a particular argument; thereby being clearer.
;;
;; (insert (format "\n⇒ %s" (macroexpand '(thread-first x₀ (f₁ x₁¹ … x¹ₘ) ⋯ (fₙ xₙ¹ … xⁿₖ)))))
;; ⇒ (fₙ (⋯ (f₁ x₀ x₁¹ … x¹ₘ)) xₙ¹ … xⁿₖ)
;;
;; A simple implementation can be found [[https://www.emacswiki.org/emacs/ThreadMacroFromClojure][here]].
;;
;; Dually, thread-last behaves the same but being at the final-most
;; form position;
;; that is, it is essentially “forwards function application”.
;; More generally, the dash library provides ‘-as->’ which allows us to bind a name
;; such as ‘res’, which is then an alias for all intermediate results.
;;
;; (insert (format "\n⇒ %s" (macroexpand '(-as-> x₀ res (f₁ x₁¹ … res ⋯ x¹ₘ) ⋯res⋯))))
;; ⇒ (let ((res x₀)) (-as-> (f₁ x₁¹ … res ⋯ x¹ₘ) res ⋯res⋯))
;;
;; It is defined recursively to make use of the same name.
;;
;; The operator ‘-->’ uses the name ‘it’ by default.
:End:
:Testing_Remarks:
#+BEGIN_SRC emacs-lisp
 ;; ⇒ crashes since equality is nil.
 ; (assert (= (+ 1 2) 4))

;; M-x ert RET t ⇒ crashes explaining that (3 = 4) ≡ nil; much better!
;; ‘should’ shows intermediate values.
(ert-deftest addition-test ()
  ;; “I know it fails, tell me but don't provide report.”
  ;; :expected-result :failed
    (should (equal (+ 2 2) 4)))

;; There are also ‘should-not’ and ‘should-error’.

;; ‘Mocking’: We can elimitate side-effects from functions we wish to test by using Lisp's dynamic
;; binding to locally redefine the side-effects to, say, do nothing and yield true.
(defun go () (if (file-exists-p "nice.txt") 'yay 'boom))
(ert-deftest eg-mock ()
  (flet ((file-exists-p (file) t))
    (should (equal (go) 'yay))))

;; Run all tests; run tests tᵢ with: (ert (or 't0 ... 'tN))
;; (ert t)

;; Execute all blocks, then run all tests.
;; (progn (org-babel-execute-buffer) (ert t))

;; Shortcut
(local-set-key (kbd "C-x e")
  (lambda () (interactive) (ert t)))
#+END_SRC

In the ~*ert*~ buffer, press ~r~ on a test to re-run it.
+ Re-run failed tests to ensure that they are deterministic before trying to find
  the cause for the failure.
  - ~m~ to see the messages that the test may have emitted, and ~b~ to see the backtrace.
+ The logical error may be in the test, rather than the code.
+ See [[https://www.gnu.org/software/emacs/manual/html_node/ert/Interactive-Debugging.html#Interactive-Debugging][here]] for more tips.
  + [ ] See [[http://www.gigamonkeys.com/book/][Practical Common Lisp]]'s Chapter 9 on [[http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html][Practical: Building a Unit Test Framework]].
:End:

#+EXCLUDE_TAGS: :noexport:

* COMMENT org/ob-agda setup :load_me:

Just C-c C-c this block (•̀ᴗ•́)و
#+begin_src emacs-lisp
(add-to-list 'org-src-lang-modes '("results-agda" . org-agda))

;; No code execution on export
;; ⟪ For a particular block, we use “:eval never-export” ⟫
;;
(setq org-export-use-babel nil)

(progn "Set up some colours *before* loading org-agda-mode"

  (setq org-agda-extra-word-colours nil)
(add-to-list 'org-agda-extra-word-colours '("typeclass" 0 'agda2-highlight-keyword-face))
(add-to-list 'org-agda-extra-word-colours '("PackageFormer" 0 'font-lock-type-face))
(add-to-list 'org-agda-extra-word-colours '("_⨾_" 0 'font-lock-type-face))
(add-to-list 'org-agda-extra-word-colours '("assoc" 0 'font-lock-type-face))

;; Treat the following words as if they were ‘types’; i.e., bold red.
(dolist (word (s-split " " "PackageFormer _⨾_ assoc rightId leftId Semigroup-semantics Semigroup-syntax SemigroupOn M.*") org-agda-extra-word-colours)
  (add-to-list 'org-agda-extra-word-colours `(,word 0 'font-lock-type-face))
  )

  ; (load-file "~/org-agda-mode/org-agda-mode.el")
  (load-file "~/org-agda-mode/literate.el")
)

;; org-agda-mode.el has now deviated as follows:
;;
; (defvar org-agda-extra-word-colours nil "other words that user of org-mode wants coloured, along with their specified font-lock-type-face")
;
; (define-generic-mode
;     'org-agda-mode                      ;; name of the mode
;     (list '("{-" . "-}"))               ;; comments delimiter
;     org-agda-keywords
;     ;; font lock list: Order of colouring matters;
;     ;; the numbers refer to the subpart, or the whole(0), that should be coloured.
;     (-concat  ;; ★★★★★★★★★★★★★★ org-agda-extra-word-colours is a free variable, user should define it /before/ loading org-agda-mode ★★★★★★★★★★★★★★
           (if (boundp (quote org-agda-extra-word-colours)) org-agda-extra-word-colours nil)
;     (list ⋯) ⋯))

;; Also this so people use “agda” instead of being forced to use “org-agda”
;;
;;  If an Emacs major-mode named <lang>-mode exists, where <lang> is the language identifier from code block’s header line, then the edit buffer uses that major-mode. Use this variable to arbitrarily map language identifiers to major modes.
;;
(add-to-list 'org-src-lang-modes '("agda" . ob-agda))

;; The following allows me to do “C-c C-c” on agda org-src blocks.
;; The result is just the src body parroted to us, no “evaluation” performed.
;;
;;
;; (async-shell-command "cp  ~/.emacs.d/elpa/org-9.2.3/ob-C.el ~/org-agda-mode/ob-agda.el")

; (async-shell-command "ln -s ~/org-agda-mode/ob-agda.el ~/.emacs.d/elpa/org-plus-contrib-20190408/ob-agda.el")
(load-file "~/org-agda-mode/ob-agda.el")

;; Execute this for alias:
(add-to-list 'org-src-lang-modes '("results-agda" . ob-agda))
;; (defalias 'results-agda 'org-agda)

;;
(org-babel-do-load-languages
 'org-babel-load-languages
 '((agda . t)))
#+end_src

#+RESULTS:

* HTML Stuffs :ignore:
# super brief intro to tables: https://www.w3schools.com/html/html_tables.asp
# See here for a nice intro to tables: https://www.w3.org/TR/CSS2/tables.html
# Here for borders: https://www.w3schools.com/css/css_border.asp
#
#
#+begin_export html
<style>

/* wrap lengthy lines for code blocks */
pre{white-space:pre-wrap}

/* inline code; see here for other colours: https://www.w3schools.com/colors/colors_names.asp */
code { background: Cyan;
       border-radius: 5px; /* How curvy the borders should be. */
}

table {
    background: pink;
    border-radius: 10px; /* How curvy the borders should be. */
    /* width:90% */

    border-bottom: hidden;
    border-top: hidden;

    /* Put table in the center of the page, horizontally. */
    margin-left:auto;margin-right:auto;

    font-family:"Courier New";
    font-size:90%;
}

/* table ‘d’ata elements */
td {
    border: 1px solid red; padding: 1em;
    /* border: none;
    border-left: 1px solid transparent;
    border-right: 1px solid transparent; */


}


/* Alter visible labels of source blocks */
pre.src-agda:before { content: 'Agda'; }
pre.src-haskell:before { content: 'Agda'; }
pre.src-org:before { content: 'Text'; }

/* Using source blocks “agda-results” as pink-background coloured blocks in HTML. */
/* pre.src-results-agda:before { content: 'Results: Agda'; } */
pre.src-results-agda { background: pink;}
/* Execute this for alias: (add-to-list 'org-src-lang-modes '("results-agda" . org-agda)) */

</style>
#+end_export

** Macro: fold                                                      :ignore:
# Folding up some code blocks in the resulting html.
#
# Usage: {{{fold(title here)}}} contents {{{end-fold}}}
#
#+MACRO: end-fold  #+HTML: </details>
#+MACRO: fold      #+HTML: <details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> $1 </font> </strong> </summary>

* Abstract       :ignore:
#+BEGIN_CENTER org
*Abstract*
#+END_CENTER
#+begin_quote org
This article is about implementing a prototype supporting [[https://alhassy.github.io/next-700-module-systems-proposal/][“the next 700 module systems” proposal]]
as an editor extension. In particular, we show how intimately related presentations of a type
can be /derived automatically/ from a single generic declaration which we call a ~PackageFormer~.

Think of a language that does not support currying and you need to have a function of
10 arguments that needs to support accepting any number of arguments less than 10, say
for partial application. In such languages, one must utilise the builder design pattern,
or quickly copy-paste the function 10 times, altering it slightly each time.
In general, if such a function definition requires /N/ lines and /M/ forms of the function
are needed, then nearly /N × M/ lines of code are written manually.

Our prototype deals with this problem, among others, for functions on /types/
---i.e., type constructors--- and reduces this quadractic count to a linear
count /N + M/: One declaration of /N/ lines, then /M/ lines, each being an instantiation
of the desired form. These ideas are discussed in the pre-print
[[https://github.com/alhassy/next-700-module-systems-proposal/blob/master/Paper0.pdf][A Language Feature to Unbundle Data at Will]].

The [[Aim: /Scrap the Repetition/][first section]] below quickly elaborates on our goal,
after that is a ‘[[User Manual][user manual]]’, then the remainder of
the article serves as literate documentation of the prototype;
as well as an opportunity for me to explore emojis.
To follow along, it may be useful to look at an [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]].
#+end_quote

# In some sense, we are “continuing” the story of Z's schemas.

#+BEGIN_CENTER org
/Everything here works with Agda version 2.6.0./
#+END_CENTER

| Results of tests will be in pink, like this. |

#+TOC: headlines 3

* Aim: /Scrap the Repetition/

We're going to write a code generator in Lisp that is going to interpret
fictitious Agda code ---henceforth referred to as “700 code”---
into currently legitimate Agda code.

For example, something like the following, henceforth referred to as ~test~:
#+NAME: test
#+BEGIN_Src agda :results replace :exports code
PackageFormer M-Set : Set₁ where
   Scalar  : Set
   Vector  : Set
   _·_     : Scalar → Vector → Vector
   𝟙       : Scalar
   _×_     : Scalar → Scalar → Scalar
   leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)

Semantics     = M-Set record
Syntax        = M-Set data with tags (Scalar; Vector)
UntypedSyntax = M-Set data with identified carrier (Scalar; Vector)
ScalarSyntax  = M-Set data with identified carrier (Scalar)
Stream        = M-Set parameterised codata with identified carrier (Vector) renaming (_·_₁ to head; _·_₂ to tail)
VectorSyntax  = M-Set data with identified carrier (Vector) and variables (embed) from (Scalar)
NearMonoid    = M-Set record renaming (Scalar to Carrier; Vector to Carrier; _·_ to _⨾_; _×_ to _⨾_)
#+END_Src

:Hide:
#+RESULTS: test
#+begin_example
PackageFormer M-Set : Set₁ where
   Scalar  : Set
   Vector  : Set
   _·_     : Scalar → Vector → Vector
   𝟙       : Scalar
   _×_     : Scalar → Scalar → Scalar
   leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)

Semantics     = M-Set record
Syntax        = M-Set data with tags (Scalar; Vector)
UntypedSyntax = M-Set data with identified carrier (Scalar; Vector)
ScalarSyntax  = M-Set data with identified carrier (Scalar)
Stream        = M-Set parameterised codata with identified carrier (Vector) renaming (_·_₁ to head; _·_₂ to tail)
VectorSyntax  = M-Set data with identified carrier (Vector) and variables (embed) from (Scalar)
NearMonoid    = M-Set record renaming (Scalar to Carrier; Vector to Carrier; _·_ to _⨾_; _×_ to _⨾_)
#+end_example

#
# The “:results replace” is since we actually want the results of this
# block later on when using “test” as a org-provided variable to org-src blocks.
:End:

:Hide_Needs_CcCvCb:
# Someplaces I want to use ‘test’ without having it in the header, whence:
#+BEGIN_SRC emacs-lisp :var outsidetest = test :exports both :results none
(setq test outsidetest)
#+END_SRC
:End:

Will behave as if it were written:
#+BEGIN_Src agda
record Semantics : Set₁ where
  field
    Scalar  : Set
    Vector  : Set
    _·_     : Scalar → Vector → Vector
    𝟙       : Scalar
    _×_     : Scalar → Scalar → Scalar
    leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
    assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)

data SyntaxTag : Set where Scalar Vector : SyntaxTag
data Syntax : SyntaxTag → Set₁ where
    _·_     : Syntax Scalar → Syntax Vector → Syntax Vector
    𝟙       : Syntax Scalar
    _×_     : Syntax Scalar → Syntax Scalar → Syntax Scalar

data UntypedSyntax : Set₁ where
    _·_     : UntypedSyntax → UntypedSyntax → UntypedSyntax
    𝟙       : UntypedSyntax
    _×_     : UntypedSyntax → UntypedSyntax → UntypedSyntax

data ScalarSyntax : Set₁ where
    𝟙       : ScalarSyntax
    _×_     : ScalarSyntax → ScalarSyntax → ScalarSyntax

{- Nutshell: Keep items ending in “Stream Carrier”, then discard that ending,
         then form a subscripted version for each argument.
-}
record Stream (Carrier : Set) : Set₁ where
  coinductive
  field
    head : Carrier
    tail : Stream Carrier

data VectorSyntax (Scalar : Set) : Set₁ where
    embed   : Scalar → VectorSyntax
    _·_     : Scalar → VectorSyntax → VectorSyntax

record NearMonoid : Set₁ where
  field
    Carrier : Set
    _⨾_     : Carrier → Carrier → Carrier
    𝟙       : Carrier
    leftId  : {𝓋 : Carrier}  →  𝟙 ⨾ 𝓋  ≡  𝓋
    assoc   : {a b : Carrier} {𝓋 : Carrier} → (a ⨾ b) ⨾ 𝓋  ≡  a ⨾ (b ⨾ 𝓋)
#+END_Src
This is a more than a <<<200% increase>>> in size; that is, our fictitious code will
save us a lot of repetition.

Below is a sample source file which contains special comments that are picked up
by the prototype which then copy-paste-cuts to produce a generated file.

#+begin_quote
⇋ For now, in this document, I will demonstrate how the provided meta-primitives
may be used to form the above excluded the following, which the reader may
form their self, or await the next edition of this document. ⇋

⟱ Not demonstrated: Syntax, UntypedSyntax, Stream, VectorSyntax.

⟰ I doubt the outermost two would be any difficulty for the reader;
the inner two may require some familiarity with the code-base or Lisp.
#+end_quote

:momentarily_ignore:
{{{fold(Testing.agda)}}}
#+INCLUDE: "Testing.agda" src agda
{{{end-fold}}}

{{{fold(Testing_Generated.agda)}}}
#+INCLUDE: "Testing_Generated.agda" src agda
{{{end-fold}}}
:End:

 For this prototype, we have the following <<<constraints>>>:

1. The type of a PackageFormer is ~Set ℓ~ where ~ℓ~ is the empty string
   or a parenthesised expression of type ~Level~.
   - In-particular, subscript types are not yet supported.

2. The ~where~ keyword appears on the same line as the ~PackageFormer~ key-phrase.

3. The name of the PackageFormer should not contain ~PackageFormer~ as a sub-identifier.
   - Likewise, no element should be named ~to~.

4. We are only considering single-sorted structures, for now.

   The research [[https://alhassy.github.io/next-700-module-systems-proposal/][proposal]] addresses how to move beyond this issue.

There are many useful features outlined in the proposal, such as default implementations, that we
hope to include in the future. For now, we just want something that works, is decently documented, and
can be useful.
* User Manual
:PROPERTIES:
:CUSTOM_ID: user-manual
:END:

If the previous section is unclear regarding the aims and uses of this prototype,
please consult the pre-print [[https://github.com/alhassy/next-700-module-systems-proposal/blob/master/Paper0.pdf][A Language Feature to Unbundle Data at Will]]
or [[https://alhassy.github.io/next-700-module-systems-proposal/][the next 700 module systems proposal]].

** Installation

Click here to obtain [[https://raw.githubusercontent.com/alhassy/next-700-module-systems-proposal/master/PackageFormer.el][PackageFormer.el]], place it somewhere, open an Agda file, execute
~M-x your/locatio/PackageFormer.el~, then enable the mode by executing ~M-x 700-mode~.

*Alternatively*, add the following to your Emacs configuration file:
#+BEGIN_SRC emacs-lisp :tangle no
;; Ensure you have the pre-requsite libraries ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                                       ;;
;; String and list manipulation libraries                                                ;;
;; https://github.com/magnars/dash.el                                                    ;;
;; https://github.com/magnars/s.el                                                       ;;
(package-install 's)                ;; “The long lost Emacs string manipulation library” ;;
(package-install 'dash)             ;; “A modern list library for Emacs”                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Next, obtain the Elisp file, load it, and attach it to Agda.

(shell-command (concat "curl "
  "https://raw.githubusercontent.com/alhassy/next-700-module-systems-proposal/master/PackageFormer.el "
  ">> ~/.emacs.d/PackageFormer.el"))

(load-file "~/.emacs.d/PackageFormer.el")

(add-hook 'agda2-mode-hook #'700-mode)
#+END_SRC

When you enable ~700-mode~:

0. A menu-bar ~700PackageFormers~ will be added.

1. It will allow you to temporarily disable and enable this new feature,
   as well as providing a help menu. Invoke ~M-x 700-mode~ to toggle turning off this feature
   completely.

2. The string icon ~700 (•̀ᴗ•́)و~ is displayed in the mode line ---near the bottom of Emacs.

3. You may use ~C-c c-l~ as usual, but it will now recognise 700-comments and generate
   legitimate Agda code from them ---more on this later.

   - PackageFormer syntactical items are coloured green, PackageFormer names are
     coloured yellow, and their instantations are simply bolded. To update a coloured
     item, simply save then revert-buffer (F5), then reload with C-c C-l.

     | *─colouring currently disabled─* |

If you need any assistance, please contact me!

** Syntax

The prototype works by translating fictitious 700-syntax into legitimate Agda;
as follows:
#+BEGIN_SRC agda
...agda code here...
{-700
       ...700-syntactical items here...
-}
...more agda code...
#+END_SRC
Since the first section provides an example source fragment with both 700-comments as well
as instantiations, we shall only enclose 700-syntax in 700-comments when it is surrounded
by other Agda code, and otherwise leave it free standing.

/We will provide full source listings at the end of discussions that only display fragments!/

 <<<700-syntax>>> is defined informally as follows:
#+BEGIN_EXAMPLE text
⟪700-syntax⟫    ::=  ⟪PackageFormer⟫ | ⟪Instantiation⟫ | ⟪Agda⟫

⟪PackageFormer⟫ ::= PackageFormer ⟪Identifier⟫ : Set (⟪level⟫) where
               ⟪newline-with-indentation⟫ ⟪Element⟫*

⟪Element⟫       ::=  ⟪Identifier⟫ : ⟪Any-Agda-Type⟫

⟪Instantiation⟫ ::= ⟪Identifier⟫ = ⟪Identifier⟫ ⟪VariationalClause⟫

⟪VariationalClause⟫ ::= [⟪Identifier⟫] (:key (value))* (⟴ ⟪VariationalClause⟫)*
#+END_EXAMPLE

:Old:
#+BEGIN_EXAMPLE text
{- Only listing the currently implemented -}
⟪Variation⟫     ::= typeclass | data | record
⟪VOp⟫           ::=   renaming ⟪ToList⟫
            | unbundling ⟪ℕ⟫
            | exposing (⟪Semicolon-seperated-list-of-Identifiers⟫)
            | with     ⟪ToList⟫

⟪ToList⟫ ::= (⟪Identifier₀⟫ to ⟪Identifier₀⟫; ⋯; ⟪Identifierₙ⟫ to ⟪Identifierₙ⟫) {- for any n : ℕ -}
#+END_EXAMPLE
:End:

+ One derives many presentations of a grouping mechanism by what we call ‘variational clauses’.
  - In a multiline comment, a non-700-comment, one declares ‘varitionals’ such as
     | ~𝒱-typeclass height = :kind record :level dec :waist-strings ("field") :waist height~   |

     These are functions whose names begin with ~𝒱-~, they may have arguments on the left-hand-side,
     and their right hand side may invoke any of the 5 meta-primitives
     ~kind, waist, waist-strings, level, alter-elements~ with any mixture of
     arguments and concrete values.

     - These is limited Agda syntax support; in doubt, Lisp syntax is used.

     - To invoke a varitional in an instantiation clause, arguments are not positional
       but instead are passed by name ---e.g., ~:key value~.

#   Note that package formation has been liberated from the backend and brought to the user
#   via our 5 meta-primitives: preamble, kind, waist, waist-strings, level, alter-elements.

+ Example uses of the variational clauses could be seen in the ~Testing.agda~ listing in the first section above.

** Example Variationals

*** Records and Meta-Primitives ~:kind~ & ~:waist-strings~
   Let's begin with the simplest thing: Realising these fictitious ‘PackageFormers’ as records.

   An Agda ‘record’ is just a PackageFormer where the qualifier ~PackageFormer~ has been
   replaced with ~record~ and the line separating parameters and fields ---the ‘waist’--- has the special
   Agda keyword ~field~. We may declare this particular configuration using the meta-primitives
   ~:kind~ and ~:waist-strings~, as follows.
#+BEGIN_SRC agda
    {-
    𝒱-record = :kind record :waist-strings (\"field\")
    -}
#+END_SRC

   Unsurprisingly, we have elected to name this grouping mechanism configuration as ~𝒱-record~.
   The prefix ~𝒱-~ signals to the Elisp meta-program that this particular equation is intended
   to be a variational and should be loaded into the database as such.

   Remember: The prefix only occurs at the definition site, the call site omits it.
   Indeed, we may now perform the following invocation ---within 700-comments.

#+BEGIN_src agda
{-700
    M-Set-Record = M-Set record
-}
#+END_SRC

   The system picks this up, looks up ~M-Set~ which was defined in the first section earlier,
   looks up the variational ~record~, then runs that configuration to generate:
#+BEGIN_SRC results-agda
record M-Set-Record : Set₁ where
 field
   Scalar  : Set
   Vector  : Set
   _·_     : Scalar → Vector → Vector
   𝟙       : Scalar
   _×_     : Scalar → Scalar → Scalar
   leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src

  Nothing too remarkable; the keyword ~field~ has been inserted and the rewrite ~PackageFormer ↦ record~
  has been performed.

  Even though this is a prototype, we wish it to be useful to ourselves and to others
  ---especially those who take a quick glance, think they got it, and try things out only to not have them work
  immediately. As such, we have implemented a cute little error-reporting system.
  | If you try to load, ~C-c C-l~, but your 700-syntax is wrong, you get an immediate error explaining why ♥‿♥ |

  For example, suppose we accidentally wrote ~recorder~ instead of ~record~ for the ~:kind~ as in the following.
#+BEGIN_SRC agda
    {-
    𝒱-whoops  = :kind recorder :waist-strings ("field")
    -}
#+END_SRC
  Even thought we have the correct invocation, say ~M-Set-Record = M-Set whoops~,
  when we try to load our Agda file the Agda process is interrupted and we are warned:
#+BEGIN_SRC text
 700: This kind “recorder” is not supported by Agda!
      Valid kinds: record, data, module, PackageFormer.

    ⇨	M-Set-Record = M-Set whoops
    ⇨	whoops ≈ (nil ((kind . recorder) (waist-strings field)))
#+END_SRC
  The 700 system informs us of our fault in “quotes”, suggests a solution,
  and points to the offending declaration hierarchy. Neato (•̀ᴗ•́)و

  | Caution |
  We have taken care, in this subsection, to present the variation-invocation-generation stages separately
  as they should be ---include the *important* new lines.
  However, in the subsequent examples, we shall tersely present the three in one
  in code fragment, as below. This is for exposition only; the three stages do not coexist in such close proximity.
#+BEGIN_SRC results-agda
    {- 0. 𝒱ariation declaration
       1. Invocation declaration -}
       2. Resulting Generation
#+END_SRC

*** Typeclasses ---Parameterised Records--- and Meta-Primitives ~:waist~ & ~:level~

    We mentioned the <<<“waist”>>> before, but what is it exactly?
    I propose that the difference between ‘field’ and ‘parameter’
    is as illusion ---as is that of ‘input’ and ‘output’ when one
    considers relations rather than deterministic functions.

    For example, let's alter the previous variation declaration to
    lift the waist up 2 levels.
#+BEGIN_src results-agda
{- 𝒱-typeclass-attempt  =  :kind record :waist-strings ("field") :waist 2
   M-Set-TypeClass = M-Set typeclass-attempt
-}
record M-Set-TypeClass (Scalar : Set) (Vector : Set) : Set₁ where
 field
   _·_     : Scalar → Vector → Vector
   𝟙       : Scalar
   _×_     : Scalar → Scalar → Scalar
   leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src

   Notice that the first two elements of the PackageFormer have been lifted
   into being parameters, while the rest have been construed as fields.

   While this typechecks according to Agda standards, it is not ideal to human
   standards since the level of the resulting package is larger than necessary.
   The meta-primitive ~:level~ allows us to ~inc~-rement or ~dec~-crement the
   current level of a PackageFormer, so we may instead define:
#+BEGIN_src results-agda
{- 𝒱-typeclass₂  =  :kind record :waist-strings ("field") :waist 2 :level dec
   M-Set-Typeclass₂ = M-Set typeclass₂
-}
record M-Set-Typeclass₂ (Scalar : Set) (Vector : Set) : Set₁ where
 field
   _·_     : Scalar → Vector → Vector
   𝟙       : Scalar
   _×_     : Scalar → Scalar → Scalar
   leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src

  Unlike records, typeclasses scream to have an argument: The height of the waist.
  Variationals may have arguments and we will cover this issue in a later subsection
  in preference to continuing our purview of the meta-primitives.

*** Primed Decoration and the Meta-Primitive ~alter-elements~

    When we have two occurances of a structure, we may want one of them to be decorated
    say with a prime so as to disambiguate them easily rather than have to qualify all
    of their components.

#+BEGIN_src results-agda
{- 𝒱-primed-record = :kind record :waist-strings ("field") :alter-elements (λ f → (map-name (concat name "′") f))"
   M-Set-Record′ = M-Set primed-attempt -}
record M-Set-Record′ : Set₁ where
 field
   Scalar′ : Set
   Vector′ : Set
   _·′_ : Scalar → Vector → Vector
   𝟙′ : Scalar
   _×′_ : Scalar → Scalar → Scalar
   leftId′ : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc′ : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src

   There are number of issues to address.

   1. The system comes with a Lisp methods ~map-name~ and ~map-type~ that yield the name and type part,
      respectively, of a typed-name such as ~the-name : the-type~.

      Upon invocation, their second argument may mention ~name~, or ~type~ respectively, to refer to
      that part of their third argument ---the typed-name ~f~ above.

   2. Everything after the ~→~ must be legitimate Lisp.

      The basics of list processing, such as maps/filters/folds, with Lisp suffice for a rich
      inventory of possible configurations. Moreover, the functional nature of such higher-order
      functions ought to be familiar to any Agda coder [[https://www.phrases.org.uk/meanings/worth-ones-salt.html][worth their salt]].

      Here's a terse tutorial rendered as an [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]].

   3. One would expect catenating a prime to the mixfix name ~_×_~ would yield ~_×_′~ but above
      it yielded ~_×′_~. Indeed, the former would yield confusing expressions of the form
      ~1 × 2 ′~ whereas the latter permits ~1 ×′ 2~. It is with the pragmatic usage that
      ~map-name~ performs an rewrite to a name by jumping over the Agda mixfix marker ~_~
      if it occurs at the start or end of a name.

      As an additional example, the name
      ~_≈_∶_~, under the above scheme, would have rewritten to ~_≈_∶′_~ thereby
      allowing terms such as ~x ≈ y ∶ A  →  f x ≈ f y ∶′ B~ ---a elegant way to
      express that, say, ~f~ is a setoid homomorphism.
      If the prime scheme were instead a prepend, we would have obtained the name
      ~_′≈_∶_~.

*** Primed Decoration, Composition ~⟴~, and First-class PackageFormers

    The previous variational duplicated the ~record~'s definition in full.

    Just because we can be silly, does not mean we must.

    Let us drop that repeated porition.
#+BEGIN_src results-agda
{- 𝒱-primed = :alter-elements (λ f → (map-name (concat name \"′\") f))"
   M-Set′ = M-Set primed -}
PackageFormer M-Set′ : Set₁ where
   Scalar′ : Set
   Vector′ : Set
   _·′_ : Scalar → Vector → Vector
   𝟙′ : Scalar
   _×′_ : Scalar → Scalar → Scalar
   leftId′ : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc′ : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src

    This is interesting: We have not generated a concrete ---legitimate Agda construct---
    but instead yielded a new abstract grouping mechanism which may be instantiated later on,
    whenever desired.

    For example, we have already declared ~M-Set-Record = M-Set record~ and now we may apply
    our ~primed~ variational.
    #+BEGIN_src results-agda
{- M-Set-Record′ = M-Set-Record primed -}
record M-Set-Record′ (Scalar′ : Set) (Vector′ : Set) : Set₁ where
 field
   _·′_ : Scalar → Vector → Vector
   𝟙′ : Scalar
   _×′_ : Scalar → Scalar → Scalar
   leftId′ : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc′ : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src

    | /We may apply  variationals even to concrete Agda packaging constructs!/ |

    Of-course, we may simply want to obtain ~M-Set-Record′~ without having first
    to define ~M-Set-Record~, and so we may use the variational composition operator ~⟴~.

#+BEGIN_src results-agda
{- M-Set-Record′ = M-Set-Record record ⟴ primed -}
record M-Set-Record′ (Scalar′ : Set) (Vector′ : Set) : Set₁ where
 field
   _·′_ : Scalar → Vector → Vector
   𝟙′ : Scalar
   _×′_ : Scalar → Scalar → Scalar
   leftId′ : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc′ : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src

   Since the ~record~ and ~primed~ configurations are ‘disjoint’, they commute
   with respect to composition. The reader may want to confirm the following identifications:
#+BEGIN_SRC agda
      M-Set-Record′
   ≈  M-Set record ⟴ primed
   ≈  M-Set primed ⟴ record
   ≈  M-Set′ record
   ≈  M-Set-Record primed
#+END_SRC

*** Variationals with Arguments
# Renaming and Variationals with Arguments

    Thus far our variationals have been nullary, let's consider otherwise.

    For example, let's add arguments to the typeclass variational from earlier.
    #+BEGIN_src results-agda
{- 𝒱-typeclass height level = :kind record :waist-strings ("field") :waist height :level level
   M-Set-Typeclass₃ = M-Set-Record typeclass :height (3) :level (dec) :comment (why hello there) -}
record M-Set-Typeclass₃ (Scalar : Set) (Vector : Set) (_·_ : Scalar → Vector → Vector) : Set₂ where
 field
   𝟙       : Scalar
   _×_     : Scalar → Scalar → Scalar
   leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src

   + Argument come before the ~=~ in a variational's definition and
     the may be used as if they were constants on the right-hand side.
     - Above we introduced the named arguments ~height~ and ~level~.
     - We then passed the /argument/ ~level~ to the /meta-primitive/ ~:level~.

   + Invocation of variationals with arguments uses named invocation, rather than
     positional application. One supplies an argument in the form ~:argument-name the-value~.

     Consequently, position is irrelevant in such invocations.

     - Supplying ~:key value~ pairs where the ~key~ is not a named argument of
       the variational has no impact and is merely ignored ---e.g., see the ~:comment~ supplication above.

   + For now, arguments must be enclosed in parenthesis.
     - This is likely to be dropped in a future edition of the system.

   ➱ If an argument is not supplied or its value is unacceptable, the cute
   error-reporting mechanism is activated ---as is the case with other
   pertinent aspects of loading such declarations.

   /Anyhow, like ~record~ and ~primed~, this ~typeclass~ variational is actually useful in practice./

   # Let's turn to a slightly more complicated example: Generalising ~primed~ to take arguments.


   ----------------------------------------------------------------------------------------------------

*** Forming Syntax and the Special ~$𝑛𝑎𝑚𝑒~ Variable

    Records provide a semantics, what if we want the syntax?
Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.
To do so, we use the helper function ~target~ which takes a declaration ~name : type0 → ⋯ → typeN~~ and yields ~typeN~.

#+BEGIN_src results-agda
{- 𝒱-data-with carrier = :kind data :level dec :alter-elements (λ f → (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $𝑛𝑎𝑚𝑒 type) f) ""))

   ScalarSyntax = M-Set data-with :carrier ("Scalar")
-}
data ScalarSyntax : Set where



   𝟙 : ScalarSyntax
   _×_ : ScalarSyntax → ScalarSyntax → ScalarSyntax


#+END_src

The meta-primitive ~:alter-elements~ is instructed to map over those
fields ~f~ that contain the ~carrier~ in their ~target~ type
by replacing the given ~carrier~ with the newly-minted ~$𝑛𝑎𝑚𝑒~ of
the grouping mechanism being constructed. Those that do not
contain the given ~carrier~ in their target type are zeroed out to ~""~,
whence the extra whitespace in the generated code.

Notice that $𝑛𝑎𝑚𝑒 is a special variable that refers to the newly defined PackageFormer's name.
- It is written using ~\Mi~ with Agda input; e.g., ~\Min~ gives ~𝑛~.
- The ‘$’ is intended to further mark the special nature of this variable.

*** COMMENT Lisp code that generates the code is the previous subsections

 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(let* ((variationals nil) (instantiations-remaining nil)
       (vs (load-variationals (s-join "\n" '(
      "𝒱-identity = "
      "𝒱-record  = :kind record :waist-strings (\"field\")"
      "𝒱-whoops  = :kind recorder :waist-strings (\"field\")"
      "𝒱-typeclass-attempt  = :kind record :waist-strings (\"field\") :waist 2"
      "𝒱-typeclass₂  = :kind record :waist-strings (\"field\") :waist 2 :level dec"
      "𝒱-primed-record = :kind record :waist-strings (\"field\") :alter-elements (λ f → (map-name (concat name \"′\") f))"
      "𝒱-primed = :alter-elements (λ f → (map-name (concat name \"′\") f))"
      "𝒱-typeclass height level = :kind record :waist-strings (\"field\") :waist height :level level"
; TODO:	  ; "𝒱-renamed with = :alter-elements (λ e → (map-name (funcall with name) e))"
      "𝒱-data-with carrier = :kind data :level dec :alter-elements (λ f → (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $𝑛𝑎𝑚𝑒 type) f) \"\"))"
      ))))
       (pf (load-package-former (second (get-children "PackageFormer" test)))))

  (--map (load-instance-declaration it)
    '(

      ; TODO: "M-Set-PF = M-Set identity :waist 2" ;; nope.

      ; "M-Set-Record = M-Set record"
      ; "M-Set-Record = M-Set whoops"
      ; "M-Set-Typeclass = M-Set typeclass-attempt"
      ; "M-Set-Typeclass₂ = M-Set typeclass₂"
      ; "M-Set-Record′ = M-Set primed-record"
      ; "M-Set′ = M-Set primed"
      ; "M-Set-Record′ = M-Set-Record primed"
      ; "M-Set-Record′ = M-Set-Record record ⟴ primed"
      ; "M-Set-Typeclass₃ = M-Set-Record typeclass :height (3) :level (dec) :comment (why hello there)"

      ; TODO: "M-Set₁ = M-Set renamed :with ((λ x → x))"

      "ScalarSyntax = M-Set data-with :carrier (\"Scalar\")"
      ))

  (reify-instances)
)
 #+END_SRC

 :old:
 Let ~PF~ denote the name of a PackageFormer, then
 ~PF′ = PF Clause~ behaves as follows:
 | _Clause_                 | _Behaviour_                                         |
 | ~data~                   | A data, ADT, is declared                          |
 | ~record~                 | A record having a new field ‘Carrier’             |
 | ~typeclass~              | A record with one parameter ‘Carrier’             |
 | ~v unbundling N~         | Instantiation  ~v~ with first ~N~ items as parameters |
 | ~v exposing (e₀;…;eₙ)~   | Instantiation ~v~ with parameters ~eᵢ~                |
 | ~v hiding (e₀;…;eₙ)~     | Instantiation ~v~ discarding ~eᵢ~                     |
 | ~v renaming (eᵢ to eᵢ′)~ | Instantiation ~v~ with specified renames            |
 | ~v with (eᵢ to eᵢ′)~     | Instantiation ~v~ with specified rewrites           |
 :end:

** Currying for Datatypes

   :Lisp_code_that_generates_the_code_for_this_subsection:
#+BEGIN_SRC emacs-lisp :var monoid = monoid :exports both :results replace :wrap "src results-agda"
(let* ((variationals nil) (instantiations-remaining nil)
       (vs (load-variationals (s-join "\n" '(
      "𝒱-identity = "
      "𝒱-record  = :kind record :waist-strings (\"field\")"
      "𝒱-whoops  = :kind recorder :waist-strings (\"field\")"
      "𝒱-typeclass-attempt  = :kind record :waist-strings (\"field\") :waist 2"
      "𝒱-typeclass₂  = :kind record :waist-strings (\"field\") :waist 2 :level dec"
      "𝒱-primed-record = :kind record :waist-strings (\"field\") :alter-elements (λ f → (map-name (concat name \"′\") f))"
      "𝒱-primed = :alter-elements (λ f → (map-name (concat name \"′\") f))"
      "𝒱-typeclass height level = :kind record :waist-strings (\"field\") :waist height :level level"
; TODO:	  ; "𝒱-renamed with = :alter-elements (λ e → (map-name (funcall with name) e))"
      "𝒱-data-with carrier = :kind data :level dec :alter-elements (λ f → (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $𝑛𝑎𝑚𝑒 type) f) \"\"))"
      ))))
       (pf (load-package-former (second (get-children "PackageFormer" monoid)))))

  (--map (load-instance-declaration it)
    '(

      ; TODO: "M-Set-PF = M-Set identity :waist 2" ;; nope.

      ; "Monoid-Record = Monoid record"
      ; "Monoid-Classical = Monoid typeclass :height (1) :level (dec)"
       "MonoidOp = Monoid typeclass :height (2) :level (dec)"
      ; "M-Set-Record = M-Set whoops"
      ; "M-Set-Typeclass = M-Set typeclass-attempt"
      ; "M-Set-Typeclass₂ = M-Set typeclass₂"
      ; "M-Set-Record′ = M-Set primed-record"
      ; "M-Set′ = M-Set primed"
      ; "M-Set-Record′ = M-Set-Record primed"
      ; "M-Set-Record′ = M-Set-Record record ⟴ primed"
      ; "M-Set-Typeclass₃ = M-Set-Record typeclass :height (3) :level (dec) :comment (why hello there)"

      ; TODO: "M-Set₁ = M-Set renamed :with ((λ x → x))"

      ; "ScalarSyntax = M-Set data-with :carrier (\"Scalar\")"
      ))

  (reify-instances)
)
#+END_SRC

#+RESULTS:

:End:

Suppose you're a Haskell programmer and want to have multiple monoid instances for the Booleans.
You may make isomorphic copies of the Booleans, say ~And~ and ~Any~, and implement the desired instance
for each. What about if you want a Monoid instance but insist only that the unit be ~false~, what do you do then?

With this prototype, you expose the carrier and the operation in the first case, and expose the identity in the second case.
Moreover, you only write the definition of monoid once, leading to our motto:
#+BEGIN_CENTER
/Write once, derive many!/
#+END_CENTER

Here's a formalisation of monoids:
#+NAME: monoid
#+BEGIN_SRC agda :results replace :wrap "src results-agda"
PackageFormer Monoid : Set₁ where
    Carrier : Set
    _⨾_     : Carrier → Carrier → Carrier
    Id      : Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : ∀ {x : Carrier} → Id ⨾ x ≡ x
    rightId : ∀ {x : Carrier} → x ⨾ Id ≡ x
#+END_SRC
:Hide:
#+RESULTS: monoid
#+BEGIN_src results-agda
PackageFormer Monoid : Set₁ where
    Carrier : Set
    _⨾_     : Carrier → Carrier → Carrier
    Id      : Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : ∀ {x : Carrier} → Id ⨾ x ≡ x
    rightId : ∀ {x : Carrier} → x ⨾ Id ≡ x
#+END_src
:End:

We regain the Haskell-style typeclass definition with the following declaration:
#+BEGIN_SRC agda
 Monoid-Classical = Monoid typeclass :height (1) :level (dec)
#+END_SRC
Loading the script, with ~C-c C-l~ as usual, produces a generated file that elaborate this definition as follows:
#+BEGIN_SRC results-agda
record Monoid-Classical (Carrier : Set) : Set where
  field
    _⨾_     : Carrier → Carrier → Carrier
    Id      : Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : ∀ {x : Carrier} → Id ⨾ x ≡ x
    rightId : ∀ {x : Carrier} → x ⨾ Id ≡ x
#+END_SRC
Notice that a name ~Carrier~ has been lifted to being a parameter instead of a field.
This is the result of the ~:height~ argument to the ~typeclass~ variational defined
in the previous subsection.

:TODO_FIXME:
We could use the letter ~m~ in-place of ~Carrier~, as is done in Haskell, as follows.
#+BEGIN_SRC agda
 Monoid-m = Monoid typeclass renaming (Carrier to m)
#+END_SRC
Which propagates ~Carrier = m~ into the fields. The propagation is necessary
if we were, for example, to rename ~_⨾_ to _⊕_~ ---otherwise we would need to parse
mixfix applications of this operator, as in ~assoc~!
#+BEGIN_SRC agda
record Monoid-m (m : Set) : Set where
  field
    _⨾_     : let Carrier = m in m → m → m
    Id      : let Carrier = m in m
    assoc   : let Carrier = m in ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : let Carrier = m in ∀ {x : let Carrier = m in m} → Id ⨾ x ≡ x
    rightId : let Carrier = m in ∀ {x : let Carrier = m in m} → x ⨾ Id ≡ x
#+END_SRC
:END:

Since Agda supports ‘named instances’, the Haskeller's first problem is solved. However, we demonstrate
an alternative solution that will allow us to solve the second problem in a fashion that current Agda
can only awkwardly approximate.

For example, with the current setup, we may go about requesting multiple monoid instances for the Booleans:
#+BEGIN_SRC agda
open Monoid-Classical using () renaming (_⨾_ to Op)

yuck-one :  (X Y : Classical 𝔹)
     →  Op X  ≡ _∧_  →  Op Y  ≡ _∨_
     →  Set
yuck-one = ???
#+END_SRC

The following declaration lets us ‘uncurry’ the first ~N = 2~ elements
from the field-position to the parameter-position.
#+BEGIN_SRC agda
MonoidOp = Monoid typeclass :height (2) :level (dec)
#+END_SRC

This then yields:
#+BEGIN_src results-agda
record MonoidOp (Carrier : Set) (_⨾_ : Carrier → Carrier → Carrier) : Set where
  field
    Id      : Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : ∀ {x : Carrier} → Id ⨾ x ≡ x
    rightId : ∀ {x : Carrier} → x ⨾ Id ≡ x
#+END_src

Which let's us solve the first problem elegantly as so:
#+BEGIN_SRC agda
first-problem : MonoidOp 𝔹 _∧_  →  MonoidOp 𝔹 _∨_  → Set
first-problem = ???
#+END_SRC

Neato ^_^ Short and sweet.

Now for the second problem. Rather than forming a new data-type,
we hoist up the ~Id~-entity field as a parameter.
| ~TODO: Write this section~ |
:TODO:
#+BEGIN_SRC agda
 MonoidId = Monoid record exposing (Carrier; Id)
#+END_SRC
Which results in:
#+BEGIN_SRC agda
record MonoidId (Carrier : Set) (Id : Carrier) : Set where
  field
    _⨾_     : Carrier → Carrier → Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : ∀ {x : Carrier} → Id ⨾ x ≡ x
    rightId : ∀ {x : Carrier} → x ⨾ Id ≡ x
#+END_SRC

Resulting in the solution type:
#+BEGIN_SRC agda
second-problem-okay : (X Y : MonoidId 𝔹 false) → Set
second-problem-okay = ???
#+END_SRC
However, this too can get tedious if we wish to only consider monoids
with unit ~false~. In that case, we /treat/ the fields as if they where
manifest fields and instantiate them to form a new type.
#+BEGIN_SRC agda
{-700 Monoid-false = Monoid record with (Carrier to 𝔹; Id to false) -}

record Monoid-false : Set where
  field
    _⨾_     : 𝔹 → 𝔹 → 𝔹
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftfalse  : ∀ {x : 𝔹} → false ⨾ x ≡ x
    rightfalse : ∀ {x : 𝔹} → x ⨾ false ≡ x

second-problem-better : (X Y : Monoid-false) → Set
second-problem-better = ???
#+END_SRC

The full source of this discussion is as follows.
{{{fold(CaseStudy.agda)}}}
#+INCLUDE: "CaseStudy.agda" src agda
{{{end-fold}}}
:End:

* Strings and Things

Since our prototype is intended to be as minimally obtrusive as possible, we will
need to extract our special 700-syntactical items between delimited tokens
and process them.

The following subsections introduce:
+ ~get-children~ :: Obtaining intended items from a hierarchical listing.
+ ~sub-string-delimited-$~ :: Finding the shortest substring between a prefix
      ~𝑳~ and a postfix ~𝑹~ by using the ‘metavariable’ ~$here~; e.g., ~“𝑳 $here 𝑹”.~
+ ~buffer-substring-delimited-whole-buffer~ :: Yield all portions of the
     buffer enclosed in the given delimiters, as a list of strings.
+ ~extract-imports~ :: Obtain all ‘import’ clauses so that they can be
     ported over to the generated file.
+ ~itify~ :: A macro that generates macros!

  A common pattern I've observed is code of the form
  ~(f (lambda (x) body-with-x) arg)~ ---i.e., there is a useful
  function ~f~ that is invoked with two arguments; the first being a
  function. The declaration ~(itify f~) will produce a macro named ~f-it~
  that takes two arguments where the first is an expression involving
  a free variable ~it~ such that
         | /(f-it expr-with-it more)  ≈  (f (λ (it) expr-with-it) more)/  |

  We then test this out on the utility ~rename-mixfix~.
  - ~rename-mixfix~ :: Ignore outermost Agda argument markers ‘_’
             when renaming an mixfix argument;
             e.g., ~_[_⊗_]  ↦  _₀[_⊗_]¹~ where this particular renaming
             is a prefix subscript 0 and postfix 1.

First some useful libraries:
#+BEGIN_SRC emacs-lisp :tangle no
;; String and list manipulation libraries
;; https://github.com/magnars/dash.el
;; https://github.com/magnars/s.el
(require 's)               ;; “The long lost Emacs string manipulation library”
(require 'dash)            ;; “A modern list library for Emacs”
#+END_SRC

** Finding Children in the Wild

Being a prototype, we are talking a mostly string-based approach to working
with hierarchical phrases.
For example, consider the following todo list,
#+NAME: children-example
#+BEGIN_SRC org :results replace
+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3
#+END_SRC

#+RESULTS: children-example
+ item 1
  - subitem 1.1
    * subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3

:Example:
#+BEGIN_SRC emacs-lisp :var it = children-example
(message it)
#+END_SRC

#+RESULTS:
: + item 1
:   - subitem 1.1
:     * subsubitem 1.1.1
:   - subitem 1.2
: + item 2
:   - subitem 1.2
: + item 3
:End:

We would think that ~item 1~ has two ‘children’, and, moreover, one grand-child.
Whereas ~item 2~ has a single child and ~item 3~ is barren.

Here's my intuitive algorithm: We obtain the indentation of the first child,
then all subsequent lines with at least that much indentation have the same ancestor.

{{{fold(get-indentation Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(defun get-indentation (string)
  "How many spaces are there at the front of ‘string’?

  Property: The resulting number is ‘≤ length string’.
  "
  (if string (length (s-shared-start string (s-repeat (length string) " "))) 0)
)
#+END_SRC
{{{end-fold}}}

{{{fold(get-children Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun get-children (parent the-wild &key (then #'identity))
  "Go into ‘the-wild’ seeking out the first occurence of ‘parent’,
   who once found, ought to have a minimal indentation for its children.

   “Minimal” in that if there are items with a greater indentation,
    then they are children of children and should be kept.

   The first input argument is of type ‘string’,
   the second argument may be of type ‘string’ or ‘list’ of strings
   ---if it's a string, we split along new lines---,
   the optional ‘then’ is a function acting on children strings.

   Result is the parent followed by its children, as a list of lines,
   where each child has been altered using the optional ‘then’ function.
   Moreover, we also return the rest of the unconsidered portion of ‘the-wild’:

   Result list: (  unconsidered-prefix-of-the-wild
           (cons parent-line children-lines)
           unconsidered-remaining-lines )

   The first element is the porition that does not contain an occurence
   of ‘parent’. The second is the parent and its children, if possible.
   The third is the remainder of the wild.

   Implementation: Look at the indentation of the
   first child, then use that as a lower bound to find the indentation
   of the remaining children.
  "

  (let ((lines (if (stringp the-wild) (s-lines the-wild) the-wild))
    (indentation -1)
    prefix
    parent-line)

    ;; Ensure: lines ≈ (cons (not-here-prefix) (cons parent-here more-lines) )
    (setq lines (--split-with (not (s-contains? parent it)) lines))

    ;; Discard prefix, for now.
    (setq prefix (car lines))
    (setq lines (cadr lines))

    ;; Discard parent, but remember its contextual line.
    (setq parent-line (car lines))
    (setq lines (cdr lines))

    ;; How far is the first child indented?
    (setq indentation (get-indentation (car lines)))

    ;; Keep only the children that have at least this level of indentation.
    (setq lines&more (--split-with (<= indentation (get-indentation it)) lines))
    (setq lines (car lines&more))
    (setq unconsidered (cadr lines&more))

    ;; Alter the children according to the given function.
    (setq lines (mapcar then lines))

    ;; Yield the parent line along with the children lines; and the unconsumed wild's prefix and suffix.
    `(,prefix ,(cons parent-line lines) ,unconsidered)
  )
)
#+END_SRC
{{{end-fold}}}

Let's try this out on our example hierarchy, ~eh~, from earlier.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(cadr (get-children "+ item 1" eh))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 |

Excellent! Let's looks at the other parents.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(get-children "+ item 2" eh)
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 |
| + item 2 | - subitem 2.2 |                    |               |
| + item 3 |               |                    |               |

Notice that we found the parent ~+ item 2~ and its only child ~- subitem 1.2~, and
we kept the prefix of ~eh~ that did not contain the parent as well as
the remaining unconsidered portion of ~eh~. ---Moreover, it looks like we obtained
the transpose of the example hierarchy 😛

Finally, the barren parent.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(get-children "+ item 3" eh)
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 | + item 2 | - subitem 2.2 |
| + item 3 |               |                    |               |          |               |

Everything before it is considered the prefix. Yay :smile:

Before we move on, let's try altering a child clause; e.g., I'd like
~* subitem 1.1.1~ to be renamed to ~* subitem that is super deep~.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(cadr (get-children "+ item 1" eh
 :then (lambda (x) (s-replace "1.1.1" "that is super deep" x))))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem that is super deep | - subitem 1.2 |

Nice :grin:

Now the moment of truth, let's try this out on our example.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace :wrap "src results-agda"
(cadr (get-children "PackageFormer" test))
#+END_SRC

   #+RESULTS:
#+begin_src results-agda
| PackageFormer M-Set : Set₁ where | Scalar  : Set | Vector  : Set | _·_     : Scalar → Vector → Vector | 𝟙       : Scalar | _×_     : Scalar → Scalar → Scalar | leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋 | assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋) |
#+end_src

Also, does the list variant work:
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace  :wrap "src results-agda"
(cadr (get-children "PackageFormer" (s-lines test)))
#+END_SRC

#+RESULTS:
#+begin_src results-agda
| PackageFormer M-Set : Set₁ where | Scalar  : Set | Vector  : Set | _·_     : Scalar → Vector → Vector | 𝟙       : Scalar | _×_     : Scalar → Scalar → Scalar | leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋 | assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋) |
#+end_src

Test-driven development doesn't seem bad 😲

These pretty-coloured tests and results may be nice for exposition,
however for maintenance it is ideal to include unit tests that can
be checked without human intervention. ~M-x ert <RET> t <RET>~, after
executing the following block, will report which tests pass and tries to explain
why tests fail.

{{{fold(Tests)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest get-ind ()
  (loop for s in '(nil "" "x" "  x" "  x ")
    do (should (<= (get-indentation s) (length s))))
  )

(ert-deftest get-child ()
  (-let [eh
"+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3"]

    ;; Consider each line above as a parent, with ‘eh’ as the wild.
    (loop for parent in (s-split "\n" eh) do
      (let* ((cs (get-children parent eh))
         (children (cdadr cs)))

      ;; Result is a list of lists: Each is either nil or a cons.
      (loop for r in cs do (should (listp r)))

      ;; The parent line contains the parent.
      (should (equal parent (caadr cs)))

      ;; The children all have the same indentation.
      (loop for c in children for d in children do (should (equal (get-indentation c) (get-indentation d))))

      ;; Extensionality: Orginal input can be regained from resulting parts.
      (should (equal eh (s-trim (s-join "\n" (--map (s-join "\n" it) cs)))))
    )
  )
))
#+END_SRC
{{{end-fold}}}

** Substrings Delimited by Tokens

#+begin_center
/How do we find a string delimited by two tokens?/
#+end_center

Before we can get to the real stuff, we need to produce a few low-level ---string manipulation---
utilities, so that we can work with higher-level abstract datatypes.

+ ~substring-delimited~: Given ~prefix~ and ~suffix~,
  this operation takes a string of the form  ~⋯‘prefix’⟪needle⟫‘suffix’⋯~ and yields ~needle~.
+ ~substring-delimited-$~: Given ~"⟪prefix⟫ $here ⟪suffix⟫"~
  this operation takes a string of the form  ~⋯‘prefix’⟪needle⟫‘suffix’⋯~ and yields ~needle~.

{{{fold(substring-delimited Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun substring-delimited
    (prefix suffix string)
  "Assuming ‘string’ ≈ ⋯‘prefix’⟪needle⟫‘suffix’⋯, return the /first/ such needle.

    NOTE: Delimiters ‘prefix’ and ‘suffix’ may be empty.

  We convert all adjacent whitespace
  characters to a single space in the input ‘string’ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (unless (stringp string) (error "substring-delimited: Argument ‘string’ must be a string."))
  (let* ((new (s-collapse-whitespace string)))

  (when (not (s-blank? prefix))
    (setq new (car (-take-last (if (equal prefix suffix) 2 1) (s-split prefix new)))))

  (when (not (s-blank? suffix))
    (setq new (car (s-split suffix new))))

  (s-trim new)
  ))

#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest subst-delimit ()
  (-let [str "𝟘 𝟙 𝟚 𝟛 𝟜 𝟝 𝟜 𝟞"] ;; Intentionally repeated ‘𝟜’.
    ;; Pattern for loop: (prefix postfix expected-needle :comment))
    (loop for it in `( ( "" "" ,str            :Identity)
               ( "𝟘" "𝟞" "𝟙 𝟚 𝟛 𝟜 𝟝 𝟜"  :Boundaries)
               ( "" "𝟞" "𝟘 𝟙 𝟚 𝟛 𝟜 𝟝 𝟜" :NoLeft)
               ( "𝟘" "" "𝟙 𝟚 𝟛 𝟜 𝟝 𝟜 𝟞" :NoRight)
               ( "𝟠" ""  ,str          :BogusL)
               ( "" "∞"  ,str          :BogusR)
               ( "𝟠" "∞" ,str          :BogusLR)
             )
      do (should (equal (third it) (substring-delimited (first it) (second it) str))))

    (should (equal "𝟛" (substring-delimited "𝟚" "𝟜" str)))

    ;; Identical boundaries.
    (should (equal "𝟙" (substring-delimited "𝑳" "𝑳" "𝑳 𝟙 𝑳")))
    (should (equal ""  (substring-delimited "𝑳" "𝑳" "𝑳 𝑳")))
    (should (equal ""  (substring-delimited "𝑳" "𝑳" "𝑳𝑳")))

    ;; Multiple occurances of prefix or postfix
    (should (equal "y"  (substring-delimited "𝑳" "𝑹" "𝑳 x 𝑳 y 𝑹")))
    (should (equal "x"  (substring-delimited "𝑳" "𝑹" "𝑳 x 𝑹 y 𝑹")))
    ))
#+END_SRC
{{{end-fold}}}

{{{fold(substring-delimited-$ Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun substring-delimited-$
    (context string &key preserve-spaces longest-substring)
  "Assuming ‘context’ = “⟪prefix⟫ $here ⟪suffix⟫”
   and ‘string’ ≈ ⋯‘prefix’⟪needle⟫‘suffix’⋯, return the /first/ such needle
   by default, unless ‘longest-substring’ is true, in which case yield /longest/
   such needle.

  NOTE: ⟪prefix⟫ and ⟪suffix⟫ cannot be emptry strings!

  Unless ‘preserve-spaces’ is true, we convert all adjacent whitespace
  characters to a single space in the input ‘string’ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (-let [pre-post (s-split "$here" context)]
    (substring-delimited (s-trim (car pre-post)) (s-trim (cadr pre-post)) string)
  )
)

(ert-deftest subst-delimit-$ ()
  (-let [str "𝟘 𝟙 𝟚 𝟛 𝟜 𝟝 𝟜 𝟞"] ;; Intentionally repeated ‘𝟜’.
    ;; Pattern for loop: (prefix postfix expected-needle :comment)
    (loop for it in `( ( "$here" ,str              :Identity)
               ( "𝟘 $here 𝟞" "𝟙 𝟚 𝟛 𝟜 𝟝 𝟜"  :Boundaries)
               ( "$here 𝟞" "𝟘 𝟙 𝟚 𝟛 𝟜 𝟝 𝟜"  :NoLeft)
               ( "𝟘 $here"  "𝟙 𝟚 𝟛 𝟜 𝟝 𝟜 𝟞" :NoRight)
               ( "𝟠 $here"   ,str          :BogusL)
               ( "$here ∞"   ,str          :BogusR)
               ( "𝟠 $here ∞" ,str          :BogusLR)
             )
      do (should (equal (second it) (substring-delimited-$ (first it) str))))

    ;; Longest substring
    (should (equal "𝟛" (substring-delimited-$ "𝟚 $here 𝟜" str)))

    ;; Identical boundaries.
    (should (equal "𝟙" (substring-delimited-$ "𝟘 $here 𝟘" "𝟘 𝟙 𝟘")))
    (should (equal ""  (substring-delimited-$ "𝟘 $here 𝟘" "𝟘 𝟘")))
    (should (equal ""  (substring-delimited-$ "𝟘 $here 𝟘" "𝟘𝟘")))

    ;; Multiple occurances of prefix or postfix
    (should (equal "y"  (substring-delimited-$ "𝑳 $here 𝑹" "𝑳 x 𝑳 y 𝑹")))
    (should (equal "x"  (substring-delimited-$ "𝑳 $here 𝑹" "𝑳 x 𝑹 y 𝑹")))

    ;; Space irrelevance for keyword ‘$here’:
    (should (equal "𝟙" (substring-delimited-$ "𝑳 $here 𝑹" "𝑳 𝟙 𝑹")))
    (should (equal "𝟙" (substring-delimited-$ "𝑳 $here𝑹" "𝑳 𝟙 𝑹")))
    (should (equal "𝟙" (substring-delimited-$ "𝑳$here 𝑹" "𝑳 𝟙 𝑹")))
    (should (equal "𝟙" (substring-delimited-$ "𝑳$here𝑹" "𝑳 𝟙 𝑹")))
    (should (equal "𝟙" (substring-delimited-$ "𝑳      $here  𝑹" "𝑳 𝟙 𝑹")))
    ))
#+END_SRC
{{{end-fold}}}

Suppose a user provides us with an awkwardly spaced PackageFormer header,
our string manipulation setup is robust enough to get at the constituents:
#+BEGIN_SRC emacs-lisp :results replace :exports both
(-let [header "PackageFormer  Semigroup   (  v : Variation) : Set (  ℓexpr)   where"]
  ;; Three kinds of invocations; the last is my preferred choice ♥‿♥
  `( ,(substring-delimited "PackageFormer " "(" header :preserve-spaces t :longest-substring t)
     ,(substring-delimited "PackageFormer " "(" header)
     ,(substring-delimited-$ "PackageFormer $here (" header)
   )
)
#+END_SRC

#+RESULTS:
| Semigroup   (  v : Variation) : Set | Semigroup | Semigroup |

The aim is to eventually have an interface that interacts with an buffer containing Agda code.
To that end, we propose that our fictitious syntax be directly embedded via special comments,
~{-700 ⋯ -}~, henceforth referred to as “<<<700-comments>>>”.

+ ~(buffer-substring-delimited starting-regexp ending-regexp)~ yields the /next/ portion of the buffer
  as a string, relative to the current position of the cursor, that is contained in the ‘parenthesis’
  ~starting-regexp~ and ~ending-regexp~.

+ ~(buffer-substring-delimited-whole-buffer starting-regexp ending-regexp)~ yields /all/ portions of the buffer,
  contained in the ‘parenthesis’ ~starting-regexp~ and ~ending-regexp~, as a list of strings.

  - Cursor position is saved.
  - This function let's us obtain the contents of /all/ 700-comments.

{{{fold(buffer-substring-delimited Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun buffer-substring-delimited (start end &optional (highlight nil))
  "
  Get the current buffer's /next/ available substring that is delimited
  between the regexp tokens ‘start’ up to ‘end’, exclusively.

  If no tokens are found, an error is thrown.

  The ‘highlight’ option simply highlights the selected region ---visual feedback
  for the user.
  "
  (let (p1 p2)
    (re-search-forward start)
    (setq p1 (point))

    (re-search-forward end)
    (backward-word)
    (setq p2 (point))

    (when highlight ;; do we want to highlight the region?
      (goto-char p1)
      (push-mark p2)
      (setq mark-active t)
    )

    ;; (copy-region-as-kill p1 p2)
    (buffer-substring-no-properties p1 p2)
))
#+END_SRC
{{{end-fold}}}

{{{fold(buffer-substring-delimited-whole-buffer Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun buffer-substring-delimited-whole-buffer (start end)
  "Return a list of all substrings in the current buffer that
   are delimited by regexp tokens ‘start’ and ‘end’, exclusively.
  "
  (save-excursion
    (let ((l nil) (continue t))
     (beginning-of-buffer)

     (while continue
       (condition-case nil
     ;; attemptClause
     (setq l (cons (buffer-substring-delimited start end) l))
     ;; recoveryBody
     (error (setq continue nil))))

     ;; We've collected items as we saw them, so ‘l’ is in reverse.
    (reverse l)
    )
  )
)
#+END_SRC
{{{end-fold}}}

Here are some possible invocations, the last one being our use case.
#+BEGIN_SRC emacs-lisp
;; Get text delimited by quotes
(buffer-substring-delimited "^\"" "^\"")

;; Get text delimited by usual Agda comments
(buffer-substring-delimited "^\{-" "^-\}")

;; Execute the following in an Agda buffer to see this function in action.
(setq it (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}"))
#+END_SRC

We also want to prefix the generated file with the imports of the current file.
{{{fold(extract-imports Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun extract-imports ()
  "Return substring of buffer whose lines mention “import”.
   Throw away any that mention the substring “⟪FileName⟫_Generated”.
  "
  (thread-last (buffer-substring-no-properties (point-min) (point-max))
    (s-split "\n")
    (--filter (s-contains? "import" it))
    (--remove (s-contains?
           (format  "%s_Generated" (file-name-sans-extension (buffer-name))) it))
    (s-join "\n")
  )
)
#+END_SRC
{{{end-fold}}}

So much string meddling, hopefully no more 🙈 :hear_no_evil: :speak_no_evil:

** ~Itify~: A macro that makes macros ♥‿♥

  A common pattern I've observed is code of the form
  ~(f (lambda (x) body-with-x) arg)~ ---i.e., there is a useful
  function ~f~ that is invoked with two arguments; the first being a
  function. The declaration ~(itify f~) will produce a macro named ~f-it~
  that takes two arguments where the first is an expression involving
  a free variable ~it~ such that
         | ~(f-it expr-with-it more)  ≈  (f (λ (it) expr-with-it) more)~ |

I'm only considering binary functions, since they're my most common
case ---it's little trouble to move to the general case.

Let's consider the simplest binary operator whose first argument is
necessarily a function ---namely, function application.
#+BEGIN_SRC emacs-lisp
(defun ap (f x) "bye" (funcall f x))
#+END_SRC

Let's form the desired macro:
#+BEGIN_SRC emacs-lisp
(defmacro ap-it (itbody more)
  (list 'ap (list 'lambda '(it) itbody) more)
  ;; ≈ `(ap (lambda (it) ,itbody) ,more)
  )
#+END_SRC

We have elected to present this with the ~list~ form
rather than the quasi-quote, since it's clear how to
yield the former as part of a macro /result/.

#+BEGIN_SRC emacs-lisp :tangle yes
(defmacro itify (fname)
  "
   From a function (h f x), obtain a macro (h-it (⋯it⋯) x) that rewrites into
   the orginal such that the first (functional) argument  may now be an expression
   with free variable ‘it’. One declates (itify h) for a named top-level function ‘h’.

   NOTE: Since functions are of the form (cons 'macro-or-fun (function (lambda args body)))
   we can obtain the number of args by getting ‘args’ and taking its length.
   Then we can change any of its indices to take an expression rather than a function.
   Indeed, (macroexpand '(itify ap))
     ⇒ (defalias (quote ap-it) (cons (quote macro) (function (lambda (itbody more)
         (list (quote ap) (list (quote lambda) (quote (it)) itbody) more)))))      .
  "

  `(defmacro ,(intern (format "%s-it" (symbol-name fname))) (itbody more)
       (list (quote ,fname) (list 'lambda '(it) itbody) more))
)
#+END_SRC

Let's test this out.
#+BEGIN_SRC emacs-lisp
;; 0. Too clunky
(ap (lambda (it) (+ 2 it)) 3) ;; ⇒ 5

;; 1. Desired
(itify ap)
(ap-it (+ 2 it) 3) ;; nice.

;; 2. Works with lambdas?
((lambda (e) (ap-it (+ 2 it) e)) 2)

;; 3. Scoping is fine?
;; Outermost ‘it’ belongs to --map; inner-most ‘it’ belongs to ap-it. (─‿‿─)
(--map (ap-it (+ 2 it) it) '(1 2 3)) ;; ⇒ (3 4 5)

;; 4. Works well with read/eval?
(ap-it (eval (car (read-from-string "(+ 2 it)"))) 3) ;; ⇒ 5
#+END_SRC

A common use of the following will be when ‘threads’ are used for
sequential processing.
#+BEGIN_SRC emacs-lisp :tangle yes
(itify funcall)
#+END_SRC

Now for a more useful and complex setting.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun rename-mixfix (f op)
  "Given an Agda mixfix operator, apply a function on strings ‘f’ on
   the inner-most delimiting tokens of the operator, in-particular ignoring
   outer argument markers ‘_’.

   For example, if you wish to decorate an operator with a prime or a subscript,
   we cannot simply catenate else we obtain “_⊕_₁” rather than “_⊕₁_”.

   Here are some sample results, assuming “f ≈ (λ (it) (format “₀%s¹” it))”:
   _⊕_     ↦  _₀⊕¹_
   _[_⊗_]  ↦  _₀[_⊗_]¹
   he_lo   ↦  ₀he_lo¹
   he-lo   ↦  ₀he-lo¹
  "

  (let* ((parts (s-split "_" op)) (front (s-blank? (first parts))) (rear (s-blank? (car (last parts)))))

  (--> (concat (when front "_") "$here" (when rear "_"))
       (substring-delimited-$ it op :longest-substring t)
       (funcall f it)
       (concat (when front "_") it (when rear "_"))
   )))

;; Need this for ‘reify-instances’.
(itify rename-mixfix)
#+END_SRC

{{{fold(Unit Tests)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest rename-mixfix ()

  (should (equal (rename-mixfix #'identity "_⊕_") "_⊕_"))

  (should (equal "_⊕′_" (rename-mixfix-it (eval (car (read-from-string "(concat it \"′\")"))) "_⊕_")))

  (should  (equal (--map (rename-mixfix-it (format "₀%s¹" it) it) '("_⊕_" "_[_⊗_]" "he_lo" "he-lo"))
       ;; Outermost ‘it’ belongs to --map; inner-most ‘it’ belongs to rename-mixfix-it.
  '("_₀⊕¹_" "_₀[_⊗_]¹" "₀he_lo¹" "₀he-lo¹"))))
#+END_SRC
{{{end-fold}}}

* The ~package-former~ Datatype

For this prototype's constraints, a PackageFormer will generally declared as
#+BEGIN_SRC agda :tangle no
PackageFormer Name : Set level where
     ⋮
#+END_SRC

The body, ~⋮~, of such a declaration mentions ~Name~, which we would like to rewrite
with other names when the package is instantiated. Likewise, we also want to erase or rewrite
the sole parameter, and possibly increment the level. Let's form a type to work with these components
rather than meddle with strings all the time.

#+BEGIN_SRC emacs-lisp :tangle yes
(defstruct package-former
  "Record of components that form a PackageFormer.

   - ‘docstring’: Relevant documentation about this structure; e.g.,
      what is the instance declaration that generated this type, if any.

   - ‘type’: PackageFormer, record, data, module, function, etc.

   - ‘name’: The name of the grouping mechanism schema.

   - ‘level’: The universe level that the instantiations will inhabit.
          The universe level of the PackageFormer.

   - Finally, the children fields are the typed-names that constitute the body of the
     grouping mechanism. As long as consistent indentation is selected, it does not matter how much.
     As such, we keep track of these indentation numerics ourselves in case we need to tweak them.

   - Internally, the zeroth element always refers to the variation symbol whereas the first element
     refers to the ‘universe of discourse 𝒰’, if any is explicitly provided, and the next ‘waist’-many
     elements are considered parameters. Note that for an ADT, 𝒰 is the ADT name, the 𝒰 of a record
     is the record name, but for a typeclass 𝒰 is generally specfiied as a set, say “Carrier : Set ℓ”.
     TODO: MA: Outdated; eventually need to support variations?
  "
  docstring
  type
  name
  level

  waist ;; Delimits elements into parameters and fields.
  waist-strings

  ;; children
  indentation ;; useful for when new elements are added.
  elements
)
#+END_SRC

It will get rather redundant to write ~(package-former-X p)~ to project the constituents of a PackageFormer ~p~. As such, let's introduce
a useful macro to “open p” locally.
#+BEGIN_SRC emacs-lisp :tangle yes
;; An anaphoric macro ^_^
(defmacro open-pf (p &rest body)
  `(let*
    ((docstring             (package-former-docstring ,p))
     (type                  (package-former-type ,p))
     (name                  (package-former-name ,p))
     (level                 (package-former-level ,p))
     (waist                 (package-former-waist ,p))
     (waist-strings         (package-former-waist-strings ,p))
     (indentation           (package-former-indentation ,p))
     (elements              (package-former-elements ,p))

    ;; It is the user's repsonsibility to pop-off the variation,
    ;; if it is undesirable.
    ;; TODO: MA: Outdated; eventually need to support variations?

    ; (carrier               (nth 1 elements))
    (parameters            (-take waist elements))
    (fields                (-drop waist elements)))
    ,@body
  )
)
#+END_SRC

( Lisp convention would advise this function to be named ~with-pf~, but I'm using the prefix ~open~,
as it is closer to the object language, Agda. )

  It is crucial to realise that we have just established a convention
  that partitions the elements of a PackageFormer:
  + <<<parameters>>> are the elements before the waist line.
  + <<<fields>>> are the elements after the waist line.

Finally, it seems we need support for typed names ---pairs ~“name : type”~.
We could use ~car~ and ~cdr~ on pairs, but let's use named projections instead
so we don't have this extra mental strain and implicit type-checking to ensure.
{{{fold(Working with “name : type” Pairs)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(defun make-tn (name type)
  "Produce a typed-name pair."
  (concat (s-trim name) " : " (s-trim type)))

(defun get-name (tn)
  "Given a string “name : type”, return the ‘name’;
   which will not have any colons in it.
   Whitespace at the edges is trimmed away.
  "
  (s-trim (car (s-split " : " tn))))

(defun get-type (tn)
  "Given a string “name : type”, return the longest possible ‘type’ substring.
  Whitespace at the edges is trimmed away."
  (s-trim (s-join " : " (cdr (s-split " : " tn)))))

;;

(defmacro map-name (fbody tn)
  "Apply string expression ‘fbody’ to the ‘name’ position of a typed-named structure.
   ‘fbody’ may mention ‘name’.
  "
  `(make-tn (rename-mixfix (lambda (name) ,fbody) (get-name ,tn)) (get-type ,tn))
)

(defmacro map-type (fbody tn)
  "Apply string expression ‘fbody’ to the ‘type’ position of a typed-named structure.
   ‘fbody’ may mention ‘type’.
  "
  `(let ((type (get-type ,tn)))
       (make-tn (get-name ,tn) ,fbody))
)

(ert-deftest tn ()
  ;; Superflous space
  (should (equal "name" (get-name "name   : type")))
  ;; Multiple “:”.
  (should (equal "∀ {X : Obj 𝒞} → (X ⟶ X)"
         (get-type"Id : ∀ {X : Obj 𝒞} → (X ⟶ X)") ))
  )

#+END_SRC
{{{end-fold}}}

#+BEGIN_SRC emacs-lisp  :tangle yes
(defvar package-formers nil
  "The list of PackageFormer schema declarations in the current Agda buffer.")
#+END_SRC

** Package Former Parsing and Pretty Printing

With this in hand, let's produce a robust parser.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun load-package-former (lines)
  "The input ‘lines’ must be a list of lines forming a full PackageFormer declaration;
   e.g., obtained by calling ‘get-children’.

   It is parsed and a ‘package-former’ value is returned.

   - Whitespace is stripped off of items.
   - Docstrings are ignored.
  "

  (if (not lines)
      (error "load-package-former: Error: Input must be non-empty list.")

(catch 'exit
  (let* (pf
     (header (or (car lines) (throw 'exit nil)))
     (name (substring-delimited-$ "PackageFormer $here :" header))
     (level (substring-delimited-$ "Set $here where" header)))

    ;; MA: Replace with a hook.
    ;; (--map (highlight-phrase (s-trim it) 'hi-yellow) (cdr lines))

    (setq pf
       (make-package-former
    :type                     "PackageFormer"
    :name                     name
    ;; ‘level’ may be “”, that's okay. It may be a subscript or implicitly zero & so no space after ‘Set’.
    :level                    level
    :waist                    0 ;; TODO: Currently no parameter support for arbitrary PackageFormers.
    :indentation              (get-indentation (cadr lines))
    :elements                 (--map (s-trim it) (cdr lines))
     ))

    (push (cons name pf) package-formers)

    ;; return value
    pf

))))

(ert-deftest pf-parse ()

  ;; Error on empty list of lines.
   (should-error (load-package-former nil))

   ;; No crash on empty line.
   ;; (should (load-package-former (list "")))

   ;; No crash on PackageFormer with no elements.
   (should (load-package-former (list "PackageFormer PF : Set ℓ where")))

   ;; Levels
   (should (equal "ℓ" (package-former-level (load-package-former (list "PackageFormer PF : Set ℓ where")))))
   (should (equal "" (package-former-level (load-package-former (list "PackageFormer PF : Set  where")))))
   (should (equal "₃" (package-former-level (load-package-former (list "PackageFormer PF : Set₃ where")))))
   (should (equal "(Level.suc ℓ)" (package-former-level (load-package-former (list "PackageFormer PF : Set (Level.suc ℓ) where")))))

   ;; Full parsing.
   (-let [pf (load-package-former (cadr (get-children "PackageFormer" test)))]
     (should (equal (format "%s" pf)
            "#s(package-former nil PackageFormer M-Set ₁ 0 3 (Scalar  : Set Vector  : Set _·_     : Scalar → Vector → Vector 𝟙       : Scalar _×_     : Scalar → Scalar → Scalar leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋 assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)))")))
   )
#+END_SRC

Let's try this out.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace
(load-package-former (cadr (get-children "PackageFormer" test)))
#+END_SRC

#+RESULTS:
| #s(package-former nil PackageFormer M-Set ₁ 0 nil 3 (Scalar  : Set Vector  : Set _·_     : Scalar → Vector → Vector 𝟙       : Scalar _×_     : Scalar → Scalar → Scalar leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋 assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋))) |

Conversely, let's have a pretty printer.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun special (f)
  "Special elements, for whatever reason are exceptional, and so
   are maked as singleton lists and their indentation is lessened.
   That is, these denote sibling fields rather than more children.

   Special elements include: field, private.

   See ‘show-package-former’ for their use and how their printed.
  "
  (--any? (s-contains? it f) '("field" "private")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun show-package-former (p &key extra-waist-strings
                 (omit-level nil) omit-docstring omit-car-element)
  "Pretty print a package-former record value.

   -‘waist-strings’: Arbitrary new elements that are input at the location of the
     PackageFormer's waist. E.g., the following results in a new local alias ‘n’
     before the remaining constitutents are printed under a “field” clause.

     :waist-strings (list “private” “n : ℕ” “n = 3” “field”)
  "

  (open-pf p (s-join "\n" (-cons*

     ;; 0. The documentation string
     (and (not omit-docstring) docstring (format "{- %s -}" docstring))

     ;; 1. The schema declaration
      (s-collapse-whitespace (s-join " " (list type name (s-join " " (--map (concat "(" it ")") parameters)) (unless omit-level (concat ": Set" level))
                    "where")))


     ;; The elements of a PackageFormer
       (thread-last fields

    (-concat waist-strings)
    (-concat extra-waist-strings)

    ;; Indent all elements, less indentation for the specials.
    (--map (concat (s-repeat (- indentation (if (special it) 2 0)) " ") it))
    (funcall (if omit-car-element #'cdr #'identity))
    )
    ))))
#+END_SRC

Let's test it out by /introducing/ a whole new local variable and trying
to include the ~field~ Agda keyword.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(let* ((raw (cadr (get-children "PackageFormer" test)))
       (pf (load-package-former raw))
       )
  (setf (package-former-waist pf) 2)
   (show-package-former pf
    :omit-car-element t
    :extra-waist-strings (list "." "private" "n : ℕ" "n = 3" "field {- elements -} "))
   ))
#+END_SRC

#+RESULTS:
#+begin_src results-agda

PackageFormer M-Set (Scalar : Set) (Vector : Set) : Set₁ where
 private
   n : ℕ
   n = 3
 field {- elements -}
   _·_     : Scalar → Vector → Vector
   𝟙       : Scalar
   _×_     : Scalar → Scalar → Scalar
   leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+end_src

The call to ~s-collapse-whitespace~ permits us to phrase an approximation of the opinion
that parsing and showing should be inverses.

#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace
(-let [pf (cadr (get-children "PackageFormer" test))]
  (equal (concat "\n" (s-join "\n" pf))
     (show-package-former (load-package-former pf))))
#+END_SRC

#+RESULTS:
| t |

#+begin_center
( /In Lisp, ~t~ denotes “true”!/ )
#+end_center

:Assert_based_test:
Since this test makes use of a ‘test’ output variable, we cannot
encode it using ert; instead we use a raw assert.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace
  (-let [pf (cadr (get-children "PackageFormer" test))]
  (assert (equal (s-concat "\n" (s-join "\n" pf))
         (show-package-former (load-package-former pf)))))
#+END_SRC

#+RESULTS:

:End:

* Variational Language

  A variational has the syntactic form specfied by

#+BEGIN_SRC text
        𝓋  ::= [identifier] (:key value)* (⟴ 𝓋)*
             | identifier (identifier)* = 𝓋
#+END_SRC

  With the intention that ~l a = r~ is a list of key-value pairs
  determined from the right-hand side where the arguments ~a~
  are to be considered place-holders. Whenever one mentions free variables,
  or terms, one actually speaks of functions. Hence, let's reify these as functions.

#+BEGIN_SRC emacs-lisp :results replace
(defun rec-replace (old new thing)
  "Traverse ‘thing’ and seek out all, possibly nested, instances
   of ‘old’ and replace them with ‘new’."
  (cond
   ((equal thing old) new  )
   ((atom thing)      thing)
   ((consp thing)     (cons (rec-replace old new (car thing))
                            (rec-replace old new (cdr thing))))))

;; test
;; (rec-replace 'it 3
;;              '(1 2 it 4 (5 it) 7 (+ 8 it))
;;             )
;; Neato!
#+END_SRC

#+BEGIN_SRC emacs-lisp :results replace
;; Posterity
(defmacro 𝒱₀ (name &rest body)
  "lhs args = key-value pairs   ⇒  a Lisp lambda taking args, yielding the pairs"
  (let* ((it body) (args-pairs (-split-on '= body)) args pairs pp)
    (pcase (length args-pairs)
      (2 (setq args  (car args-pairs)
               pairs (cadr args-pairs)))
      (t (setq pairs (car args-pairs))))

    `(lambda ,args
    ,(-let [res
        `,(loop for key   in pairs by #'cddr
                      for value in (cdr pairs) by #'cddr
                      collect (cons key value))]

       ;; Stage the formal names *now*, then evaluate their values at run time.
       ;; Traverse the list of pairs and change the nested formal names with the
       ;; given values. Praise the Lord!
      `(loop for a in (quote ,args)
            collect (rec-replace a (eval a) (quote ,res)))

  ))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results replace
(defun 𝒱𝒸 (body-list)
  "Parse a single 𝒱ariational 𝒸lause, as a list, of the form “[label] (:key :value)*”.

   If there is a ‘label’, then yield ‘(label :key value ⋯)’
   since ‘label’ is assumed to exist as a variational having the given
   keys as arguments. The result should be a list of pairs.

   If there is no label, the parse the list of pairs.

  For example,
     (cl-defun test (&key height kind) (format \"%s & %s\" height kind))
     (𝒱₁ '(test :height 3 :kind 'data)) ⇒ “3 & data” ≈ (test :height 3 :kind data)
     (𝒱₁ '(     :height 3 :kind data)) ⇒ ((:height . 3) (:kind . data))

   Newer items c₀ ⟴ ⋯ ⟴ cₙ should be at the front of the list;
   access should then be using ‘assoc’.
  "

  (let* (res)
    (loop for clause in (-split-on '⟴ body-list)
          do (setq res (-concat
                 ;; Symbols starting with “:” are keywords.
                 (if (not (keywordp (car clause)))
                     ;; Function invocation case
                     (eval `(,(car clause) ,@(cdr clause)))
                   ;; List of key-value pairs
                   `,(loop for key   in clause by #'cddr
                           for value in (cdr clause) by #'cddr
                           collect (cons key value)))
                   ;; Newer items c₀ ⟴ ⋯ ⟴ cₙ should be at the front of the list;
                   ;; access should then be using assoc.
                   res)))
    res
    ))

; DONE
; (𝒱𝒸 '(test₁ :height 3 ⟴ :kind module)) ;; ⇒ ((:kind . module) ((:kind . record) (:waist . 3)))
; (𝒱𝒸 '(:height 3 :kind data)) ;; ⇒ ((:height . 3) (:kind . data))

(defmacro 𝒱 (name &rest body)

  (let* ((it body) (args-body (-split-on '= body)) args body res)
    (pcase (length args-body)
      (2 (setq args  (car args-body)
               body (cadr args-body)))
      (t (setq body (car args-body))))

    (setq res (𝒱𝒸 body))

    `(cl-defun ,name (&key ,args)


       ;; Stage the formal names *now*, then evaluate their values at run time.
       ;; Traverse the list of pairs and change the nested formal names with the
       ;; given values. Praise the Lord!
       (if (not (quote ,args)) (quote ,res)
      (loop for a in (quote ,args)
            collect (rec-replace a (eval a) (quote ,res))))

 )))

(𝒱 test₁ heightish = :kind record :waist heightish)
(𝒱 test₂  = :kind data ⟴ test₁ :heightish 2)
(test₁ :heightish 6) ;; ⇒ (((:kind . record) (:waist . 6)))
(test₂) ;; ⇒ (((:kind . record) (:waist . 2)) (:kind . data))

(thread-last "𝒱-typeclass = :kind record :waist 1"
  (s-replace "𝒱-" "𝒱 ")
  (format "(%s)")
  read-from-string
  car
  eval)

(typeclass) ;; ⇒ ((:kind . record) (:waist . 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results replace
(defun show-me ()
  "Evaluate a Lisp expression and insert its value
   as a comment at the end of the line.

   Useful for documenting values or checking values.
  "
  (interactive)
  (-let [it
         (thread-last (thing-at-point 'line)
           read-from-string
           car
           eval
           (format " ;; ⇒ %s"))]
    (end-of-line)
    (insert it)))
#+END_SRC


#+begin_src emacs-lisp :tangle yes :results replace

(cl-defun load-variational (variation-string)
  "Obtain lines of the buffer that start with “𝒱-”.
   Realise them as Lisp association lists.

   A line is something like:

      𝒱-name x₀ … xₙ  =  ([label₀] :key₀ val₁ ⋯ :keyₘ valₘ ⟴)*

   The result is a list of 3-tuples (name (x₀ ⋯ xₙ) ((key₀ val₀) ⋯ (keyₘ valₘ))),
   containing the clause's name, argument list, and key-value pairs.

   If the optional ‘string-list’ is provided, then use
   that instead of searching the buffer. This feature
   has been added on to make the presentation of tests
   and examples easier to digest ---without the mockup
   of fletting ‘buffer-substring-no-properties’ to return
   what could instead be ‘string-list’. It was the addition
   of a simple ‘or’ ---far less than this string explaning it.

   For now, the RHS must be an expression of the form “:key₀ value₀ ⋯ :keyₙ valueₙ”
   - where the valueᵢ are legitmate Lisp expressions
   - and the LHS is an atomic name.

   Note: The space around the “:” is irrelevant; no valueᵢ may contain a colon or an equals sign.
  "

  (thread-last variation-string
    (s-replace "𝒱-" "𝒱 ")
    (format "(%s)")
    read-from-string
    car
    eval))
#+end_src


#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(load-variational "𝒱-primed-record = :kind record")

; (load-variational "𝒱-primed-record = :kind record :waist-strings (\"field\") :alter-elements (λ f → (map-name (concat name \"′\") f))")
#+END_SRC

* Loading an Agda Buffer

Before we can parse an Agda buffer, we need to be able to parse an instantiation declaration;
for which we would later generate code.

# Let's keep track of the user-defined variationals.
    #+BEGIN_SRC emacs-lisp :tangle yes
(defvar instantiations-remaining nil
  "The PackageFormer instantiations that need to be performed.")

(defvar variationals nil
  "Association list of Agda-user defined variational operators.")
#+END_SRC

** COMMENT Variationals  :old_approach:

   Let's parse arguments as legitimate Lisp forms.
#+begin_src emacs-lisp :tangle yes
(cl-defun to-lisp (string)
  "Parse Agda ‘string’ to obtain a Lisp expression.

   + (λ x → B)   ↦  (lambda (x) B′)
   + B may contain ++, in which case the result is a ‘concat’.
   - B may not contain ‘→’.

  If B is a parens-enclosed expression, then we expect it to
  already be a legitimate Lisp form and so leave it alone.
  "

  (assert (stringp string))

  (let* ((expr (s-collapse-whitespace string))
     args
     (body expr)
     (isλ (equal "(λ" (s-shared-start "(λ" expr))))

    (when isλ
      (thread-last string
    (s-chop-prefix "(λ")
    (s-chop-suffix ")")
    (s-split "→")
    (setq expr))

      (setq args (car expr))
      (setq body (cadr expr))
    )

    ;; (error "%s" body)

    ;; Ensure ‘body’ is a lisp expression.
    (when  (and (s-blank? (s-shared-start "(" body))
        (s-blank? (s-shared-end ")" body)))

     (when (and isλ (s-contains? " ++ " body))
       (thread-last body
         (s-replace "++" " ")
         (format "(concat %s)")
         (setq body)))

     )

    ;; Realise it as Lisp
    (setq expr (if isλ (format "(lambda (%s) %s)" args body)
           body))
    (car (read-from-string expr))
))

(ert-deftest to-lisp ()
  (should (equal 'data (to-lisp "data")))
  (should (equal '(list 'a 'b 'c) (to-lisp "(list 'a 'b 'c)")))
  (should (equal '('a 'b 'c) (to-lisp "('a 'b 'c)")))
  (should (equal '("a" "b") (to-lisp "(\"a\" \"b\")")))
  (should (equal '(lambda (x) Bx) (to-lisp "(λ x → Bx)")))
  (should (equal '(lambda (x) (when t x)) (to-lisp "(λ x → (when t x))")))
  (should (equal '(lambda (x) just this) (to-lisp "(λ x → just this")))
  (should (equal '(lambda (x) (concat x "′")) (to-lisp "(λ x → x ++ \"′\")")))
)
#+end_src

A variational clause is of the following form
---with normal forms being lists of key-value pairs.
#+BEGIN_SRC text
𝓋  ::=  𝓋 (⟴ 𝓋)*
     | [⟨identifier⟩] (:key value)*
#+END_SRC

#+begin_src emacs-lisp :tangle yes :results replace
(cl-defun update-state (xs ys)
  "Given ys, a list of key-value pairs, where the keys appear free in list of pairs xs,
   update the values of xs making use of these new pairs.

   E.g., (setq xs '((a . (list b d)) (c . d)))
         (setq ys '((b . 𝒷) (d . 𝒹)))
         ⇒    (update-state xs ys)
            ≈ '((a . (list “𝒷” “𝒹”)) (c . “𝒹”)))
  "
  (loop for (key . val) in xs
         collect (cons key
            (eval `(progn ,@(--map `(setq ,(car it) ,(format "%s" (cdr it))) ys)
              ,(car (read-from-string (format "%s" val)))))))
  )

;; (update-state xx yy)
#+end_src

#+RESULTS:
: update-state

#+begin_src emacs-lisp :tangle yes :results replace
(cl-defun parse-variational-clause (line)

  "Given a string of items “name :key₀ val₀ … :keyₙ valueₙ”
   seperated by ⟴, and where the ‘name’ string may be empty,
   turn it into a list of such items; i.e., a list of tuples
   (name pairs) where the ‘pairs’ refers to the key-value
   components."

  (let (variations label alterations)

  ;; For now, variation must be separated by ⟴.
     (setq variations (s-split "⟴" line))

     (setq alterations
     (loop for va in variations
       do (setq label (car (s-split " " (s-trim va))))
         ;; If the variation begins with a “:key value” pair, then
         ;; it is anonymous & its label is nil;
         ;; otherwise it is a variational application.
         (setq label (unless (equal ":" (s-shared-start ":" (s-trim va)))
             (car (s-split " " (s-trim va)))))
         collect
         (thread-last
             ;; Split along “:key value” pairs;
             ;; Drop first non-key item, the label, if any.
             (s-split ":" (s-join " "
                                  (funcall (if label #'cdr #'identity)
                                           (s-split " " va :omit-nulls))))

             ;; Split along the space to get key and value.
           (--map (s-split " " it :omit-nulls))
           cdr
           (--map (cons (to-lisp (car it))           ;; Transform it into legitimate Lisp.
                (to-lisp (s-join " " (cdr it)))))
           (cons (or label 'anonymous)))))

     ;; We know have the declared alterations in the given order.
     ;; alterations ≈ list of (name (list-of (key value))) tuples
     ;; (should (--every? (equal 2 (length it)) alterations))

     alterations
    )
  )


;; TODO: Might as well throw away load-instance-declaration now.
;
(parse-variational-clause ":waist 2 ⟴ :kind record ⟴ more :yarg x :barg y")
#+end_src

#+RESULTS:
| anonymous | (waist . 2)     |            |
| anonymous | (kind . record) |            |
| more      | (yarg . x)      | (barg . y) |

#+begin_src emacs-lisp :tangle yes :results replace

(cl-defun load-variationals (&optional string-list)
  "Obtain lines of the buffer that start with “𝒱-”.
   Realise them as Lisp association lists.

   A line is something like:

      𝒱-name x₀ … xₙ  =  ([label₀] :key₀ val₁ ⋯ :keyₘ valₘ ⟴)*

   The result is a list of 3-tuples (name (x₀ ⋯ xₙ) ((key₀ val₀) ⋯ (keyₘ valₘ))),
   containing the clause's name, argument list, and key-value pairs.

   If the optional ‘string-list’ is provided, then use
   that instead of searching the buffer. This feature
   has been added on to make the presentation of tests
   and examples easier to digest ---without the mockup
   of fletting ‘buffer-substring-no-properties’ to return
   what could instead be ‘string-list’. It was the addition
   of a simple ‘or’ ---far less than this string explaning it.

   For now, the RHS must be an expression of the form “:key₀ value₀ ⋯ :keyₙ valueₙ”
   - where the valueᵢ are legitmate Lisp expressions
   - and the LHS is an atomic name.

   Note: The space around the “:” is irrelevant; no valueᵢ may contain a colon or an equals sign.
  "
  (let (variations name args new-body)

    (thread-last (or string-list (buffer-substring-no-properties (point-min) (point-max)))
      (s-split "\n")
      (--map (s-collapse-whitespace it))
      (--filter (not (s-blank? (s-shared-start "𝒱-" it))))
      (--map (s-chop-prefix "𝒱-" it))
      (setq variations)

      (--map (s-split "=" it))
      (setq variations)
    )

    (loop for (name-args body) in variations
      do (setq name-args (s-split " " name-args :omit-nulls))
         (setq name (car name-args))
         (setq args (cdr name-args))

         (setq body (parse-variational-clause body))

         ;; (thread-last (s-split ":" body :omit-nulls)
         ;;   (--map (s-split " " it :omit-nulls))
         ;;   cdr
         ;;   (--map (cons (to-lisp (car it))
         ;;        (to-lisp (s-join " " (cdr it)))))
         ;;   (list name args)
         ;;   (add-to-list 'variationals))

         ; (message-box "%s" body)
         (should (listp body))

         ;; ‘body’ is now a list of tuples ---optional label with key-value pairs.
         ;; We want it to just be a list of pairs of key-value pairs.
         ;; If there's no label, add the pair;
         ;; if there's a label then add the label's pairs with the given key-value context.
         (setq new-body nil)
         (loop for clause in body
               do ; (message-box "%s" (caaddr (assoc (car clause) variationals)))
                  ; (message-box "%s" (cadr clause))
                  (if (equal 'anonymous (car clause)) (setq new-body (-concat new-body (cdr clause)))
                    (setq new-body (-concat new-body (update-state (caaddr (assoc (car clause) variationals))
                                        (cadr clause))))))

         ; (message-box "%s\n%s\n%s" name args new-body)
         ; (setq body (--map (progn (message-box "%s" it) (if (consp (car it)) (car it) it)) new-body))
         (add-to-list 'variationals (list name args new-body))  ;
         )

    variationals
))
#+end_src

#+RESULTS:
: load-variationals

# (org-babel-load-file "PackageFormer.org")

 # NOTE:
 # Breaks since I'm not allowing “:” in variationals since it acts as an invocation to the meta-primitives.
 #
 # :alter-elements (λ f → (s-contains? pf-name (target (cadr (s-split \":\" f))))) "

:anonoymous_argument_test:
 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"𝒱-form₁ height ty = :waist height :kind ty
𝒱-form₂            = :level inc :kind module ⟴ :kind record ⟴ form₁ :height 2 :ty data"
))
  (setq variationals nil)
  (load-variationals)
)
#+END_SRC
#+RESULTS:
#+begin_src results-agda
| form₁ | (height ty) | ((waist . height) (kind . ty)) |
#+end_src


Desired shape
#+begin_src results-agda
| form₂ | nil         | ((kind . record) (height . 2) (ty . data)) |
| form₁ | (height ty) | ((waist . height) (kind . ty))             |
#+end_src
current shape:
#+begin_src results-agda
| form₂ | nil         | ((anonymous ((kind . record))) (form₁ ((height . 2) (ty . data)))) |
| form₁ | (height ty) | ((anonymous ((waist . height) (kind . ty))))                       |
#+end_src

:End:
:Simple_argument_test:
 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"𝒱-data-with-carrierN arg₀ arg₃ = :kind arg₃"))
  (setq variationals nil)
  (load-variationals)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set data-with-carrierN :arg₃ (HelloWorld oh my) :comment This's so cool")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
))
#+END_SRC
:End:
:all_argument_test:
 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"𝒱-test arg₀ arg₁ arg₂ a₃ a₄ = :kind arg₀ :waist arg₁ :waist-strings arg₂ :level a₃ :alter-elements a₄ "))
  (setq variationals nil)
  (load-variationals)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set test :a₄ ((lambda (x) (concat \"₂\" x))) :a₃ (inc) :arg₀ (record) :arg₁ (1) :arg₂ ((\"field BdRO\"))")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
))
#+END_SRC

#+RESULTS:
#+BEGIN_src results-agda
{- NewName = M-Set test :a₄ ((lambda (x) (concat "₂" x))) :a₃ (inc) :arg₀ (record) :arg₁ (1) :arg₂ (("field BdRO")) -}
record NewName (₂Scalar : Set) : Set₂ where
 field BdRO
   ₂Vector  : Set
   ₂_·_     : Scalar → Vector → Vector
   ₂𝟙       : Scalar
   ₂_×_     : Scalar → Scalar → Scalar
   ₂leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   ₂assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src
:End:
:using_⟴_:
 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"𝒱-test kind  = :kind kind
𝒱-test′ height = :waist height
"))
  (setq variationals nil)
  (load-variationals)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set test :kind (module) ⟴ test′ :height (3)")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
))
#+END_SRC

#+RESULTS:
#+BEGIN_src results-agda
{- NewName = M-Set test :kind (module) ⟴ test′ :height (3) -}
module NewName (Scalar : Set) (Vector : Set) (_·_ : Scalar → Vector → Vector) : Set₁ where
   𝟙       : Scalar
   _×_     : Scalar → Scalar → Scalar
   leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src
:End:
:more_anonymous_testing:
 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"𝒱-test        = :kind record ⟴ test′ :height 2
𝒱-test′ height = :waist height
"))
  (setq variationals nil)
  (load-variationals)
)
(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "LHS = M-Set test ⟴ :level dec")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
))
#+END_SRC

#+RESULTS:
#+begin_src results-agda
{- LHS = M-Set test ⟴ :level dec -}
record LHS : Set where
   Scalar  : Set
   Vector  : Set
   _·_     : Scalar → Vector → Vector
   𝟙       : Scalar
   _×_     : Scalar → Scalar → Scalar
   leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+end_src
:End:

** Instantiations Remaining
Herein we define the datatype of ~instance-declaration~, describe how
to parse such entities, and monitor them within a list.

An instance declaration is of the form:
#+BEGIN_SRC results-agda
PF′ = PF variational₁ (args₁) ⋯ variationalₙ (argsₙ)
#+END_SRC

This gives rise to a simple nice structure:
#+BEGIN_SRC emacs-lisp :tangle yes
(defstruct instance-declaration
  "Record of components for an PackageFormer instance declaration:
   ⟪name⟫ = ⟪package-former⟫ (⟪variation⟫ [⟪args⟫])*
  "

  docstring      ;; What the declaration looks like, useful for reference.
  name           ;; Left-hand side
  package-former ;; Parent grouping mechanism
  alterations    ;; List of variationals along with their arguments.
)
#+END_SRC

For uniformity, the ~args~ will generally be a single function.
We introduce “to lists” as a nice concrete syntax for functions involving
case analysis. These meta-lists occur in existing Agda notation and so
we overload them for sake of familiarity ---in actuality, we are generalising the existing form.
{{{fold(~parse-labelled-to-list~)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun parse-labelled-to-list (label the-list &key (no-to nil))

     "Given a “to-list” of the form “label (x₀ to y₀; …; xₙ to yₙ; λ x → Bx)”
      yield the Lisp list of dotted pairs “( ((x₀ . y₀) ⋯ (xₙ . yₙ)) “(lambda (x) Bx)”)”
      where the *optional* final clause of the to-list is considered a default or ‘otherwise’
      case and is converted into a legitimate Lisp function.

      No label results in to-list becoming a dotted list.
      When the otherwise clause is absent, it defaults to the identity function.

      If “no-to” is true, then we do not parse the to-clauses, yielding
      a list of strings.

      Errors on an empty list. Yields nil if the label is not found.
      Note that n = 0 is fine, provided the otherwise clause
      is present.
     "

     (when (or (equal (car (s-split " " (s-trim the-list))) label) (s-blank? (s-trim label)))

     (-let* ( ;; (label "var") (the-list "var ()") no-to
         (result (thread-last the-list

              ;; Discard identifying label
              (substring-delimited-$ (format "%s ($here)" label))

              ;; Split along semicolons.
              (s-split ";")

              ;; Removed superflous whitespace
              (--map (s-trim it))))

         otherwise var)

       ;; If there is a “otherwise” function to apply,
       ;; then turn it into a Lisp function and drop it
       ;; from the prefix of the to-list. Else, set otherwise to identity.
       (if (not (s-contains? "λ" (car (-take-last 1 result))))

       (setq otherwise #'identity)

     ;; Drop the Agda's λ→ in-favour of Lisp's (lambda ⋯).
     ;; Replace Agda catenation's with Lisp concat.
     (setq otherwise (thread-last (car (-take-last 1 result))
           (s-replace "++" " ")
           (substring-delimited-$ "λ $here")
           (s-split " → ")
           (funcall-it (format "(lambda (%s) (concat %s))" (car it) (cadr it)))
           read-from-string
           car
           ))

     (setq result (-drop-last 1 result)))

       ;; Turn into dotted pairs, unless suggested otherwise.
       ;; Need to ensure ‘result’ is non-empty; since it may
       ;; be a singleton that was dropped into the ‘otherwise’.
       (when (and result (not no-to))
     (setq result (thread-last result
         (--map (s-split " to " it))
         ;; Need to ensure it's a list of pairs; otherwise something went wrong.
         ;; Suffices to ensure the head element has a second component.
         (funcall-it (if (cadar it)
         (--map (cons (s-trim (first it)) (s-trim (second it))) it)
         (message "parse-labelled-to-list: Is this “to-list” well-formed: %s ⁇" (pp it)) it))))) ;; No desire to error since we may parse non 700-syntax.
       (list result otherwise)
)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest parse-tos ()

  ;; Expected use
  (should (equal '(("a" . "b") ("c" . "d")) (car(parse-labelled-to-list "map"  "map (a to b; c to d)"))))
  (should (equal '(("a" . "b")) (car(parse-labelled-to-list "map"  "map (a to b)"))))
  (should (equal '(("a" . "b")) (car(parse-labelled-to-list "map"  "map (a to b; λ x → x)"))))
  (should (equal (lambda (x) (concat x)) (cadr(parse-labelled-to-list "map"  "map (a to b; λ x → x)"))))
  (should (equal (lambda (x) (concat x "′")) (cadr(parse-labelled-to-list "map"  "map (a to b; λ x → x ++ \"′\")"))))
  (should (equal (lambda (x) (concat x "′")) (cadr(parse-labelled-to-list "map" "map (λ x → x ++ \"′\")"))))

  ;; Empty list is fine.
  (should (equal '((("")) identity)  (parse-labelled-to-list "map" "map ()")))

  ;; Singleton list
  (should (equal '(("a" . "b")) (car (parse-labelled-to-list "map"  "map (a to b)"))))
    (should (equal '(("one-arg")) (car (parse-labelled-to-list "map" "map (one-arg)"))))

  ;; No label results in to-list becoming a dotted list.
  (should (equal '(("a" . "b") ("c" . "d")) (car(parse-labelled-to-list ""  "(a to b; c to d)"))))

  ;; Unmatched label.
  (should (equal nil (car(parse-labelled-to-list "mapp"  "map (a to b)"))))

  ;; Not ill-formed list ---one arg list!
  (should (parse-labelled-to-list "map"  "map (a what b)"))
)
#+END_SRC
{{{end-fold}}}

Loading an instantiation into our list is now trivial.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun load-instance-declaration (line)
  "If the current ‘line’ string is an instance declaration,
   then parse and add it to the list of ‘instantiations-remaining’;
   else do nothing.

   Returns the instance-declaration that was loaded, otherwise nil.

   Whitespace is automatically collopased from ‘line’.
  "

  ;; Example instance declaration:
  ;; “MagmaR = Magma record renaming (Carrier to C; _⨾_ to _∘_)”
  ;; ⇒ ≥4 pieces, separated by spaces, where second item must be an equality.
  ;; Note: (cddddr nil) ≈ nil

  (let* (inst
     (pieces (s-split " " (s-collapse-whitespace line)))
     (new-name   (nth 0 pieces))
     (eqSymb     (nth 1 pieces))
     (parent     (nth 2 pieces))
     (variations (nthcdr 3 pieces))
     alterations
     label
     )

    ;; Minimal check that the the declaration is well-formed.
   ;; if nil ;; (not (and (== 4 (length pieces)) (equal (nth 1 pieces) "=") (not (s-blank? (s-trim (nth 0 pieces))))))
   ;;    (message "load-instance-declaration: Declarations should have at least 4 non-empty pieces; %s ⁇" line)
       ;; We do not crash here since we also arbitrary Agda to flow through the 700-comments as well.

  (when (not (or (s-blank? (s-trim new-name)) (not (equal "=" eqSymb)) (not parent)))

     (thread-last  variations
       (s-join " ")     ;; Stick the rest back together.
       (format "'(%s)") ;; Construe as a lisp list
       read-from-string
       cadar
       𝒱𝒸
       (setq alterations))

     ;; ;; For now, variation must be separated by ⟴.
     ;; (setq variations (s-split "⟴" variations))

     ;; ;; (push (cons label (parse-labelled-to-list label va)) alterations)
     ;; (loop for va in variations
     ;;   do (setq label (car (s-split " " (s-trim va))))
     ;;     ;; If the variation begins with a “:key value” pair, then
     ;;     ;; it is anonymous & its label is nil;
     ;;     ;; otherwise it is a variational application.
     ;;     (setq label (unless (equal ":" (s-shared-start ":" (s-trim va)))
     ;;         (car (s-split " " (s-trim va)))))

     ;;     (thread-last
     ;;         ;; Split along “:key value” pairs;
     ;;         ;; Drop first non-key item, the label, if any.
     ;;         (s-split ":" (s-join " "
     ;;                              (funcall (if label #'cdr #'identity)
     ;;                                       (s-split " " va :omit-nulls))))

     ;;         ;; Split along the space to get key and value.
     ;;       (--map (s-split " " it :omit-nulls))
     ;;       cdr
     ;;       (--map (cons (to-lisp (car it))           ;; Transform it into legitimate Lisp.
     ;;            (to-lisp (s-join " " (cdr it)))))
     ;;       (list (or label 'anonymous))
     ;;       (add-to-list 'alterations)))

     (setq inst (make-instance-declaration
         :docstring      line
         :name           (nth 0 pieces)
         :package-former (nth 2 pieces)
         :alterations    alterations))

     (add-to-list 'instantiations-remaining inst)

   ;; Return value.
   inst
  )
))

(load-instance-declaration "LHS = PF :arg₀ val₀ ⟴ test₁ :heightish 23")

     ;; PackageFormer names are in yellow; instances are are bolded.
     ;; (highlight-phrase (format "%s " (nth 2 pieces)) 'hi-yellow)
     ;; (highlight-phrase (nth 0 pieces) 'bold) ;; 'warning) ;; i.e., orange
     ;;
     ;; MA: Replace with a hook.
#+END_SRC

TODO: fix tests.
{{{fold(Tests)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest lid ()

  (let (id)

  ;; Anonymous variational
  (setq id (load-instance-declaration "LHS = PF :arg₀ val₀ ⟴ var₁ :arg₁ val₁"))

  ;; Basic invocation shape
  ;; “to”! (setq id (load-instance-declaration "NewName = PF var₁ :arg (λ x₁ → B₁) ⟴ var₂ :arg (a to b; λ x₂ → B₂)"))
  (setq id (load-instance-declaration "NewName = PF var₁ :arg₀ (λ x₁ → B₁) :val₀ nice ⟴ var₂ :arg (λ x₂ → B₂)"))
  (cdr (instance-declaration-alterations id))
  (should (equal "NewName" (instance-declaration-name id)))
  (should (equal "PF" (instance-declaration-package-former id)))
  (should (equal "((var₂ ((a . b)) (lambda (x₂) (concat B₂))) (var₁ nil (lambda (x₁) (concat B₁))))"
         (format "%s" (instance-declaration-alterations id))))

  ;; Ill-formed: LHS name is empty string.
  (should (not (load-instance-declaration " = PF var")))

  ;; Ill-formed: Not even a declaration.
  (should (not (load-instance-declaration "private n : ℕ")))

  ;; Variation has no args.
  (should (load-instance-declaration "LHS = PF var ()"))

  ;; Arbitrary variational
  ;; There are parens around each arg since each should be a pair.
  (should (equal "((some-variational ((arg₀) (…) (argₙ)) identity))" (format "%s" (instance-declaration-alterations (load-instance-declaration
   "LHS = Magma some-variational (arg₀; …; argₙ)")))))
  (should (equal "((some-variational nil (lambda (x) (concat x ′))))" (format "%s" (instance-declaration-alterations (load-instance-declaration
  "LHS = Magma some-variational (λ x → x ++ \"′\")")))))
))
#+END_SRC
{{{end-fold}}}

** ~load-700-comments~

   We already two global lists ---for our loaded PackageFormers and instantions
   remaining--- we need two additional lists: One for the contents of 700-comments,
   primarily for basic efficiency, and the other to port whatever is within
   700-comments but is not 700-syntax. The latter is for when we want definitions
   or generalised variables to be accessible in /both/ 700-comments and the
   surrounding script. Which is achieved since the matter is exported to
   the generated file in the Elisp stage, then imported at the Agda level.

#+BEGIN_SRC emacs-lisp  :tangle yes
(defvar 700-comments nil
  "The contents of the 700-comments.

   If this variable does not change, we short-circut all processing.
   See step ‘½’ below.
  ")

(defvar porting-list nil
  "List of items in 700-comments that are neither PackageFormer declarations
   nor instantations, and so are ported to the generated file.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun load-700-comments ()
  "Parse comments of the form “{-700 ⋯ -}” and add all PackageFormer declarations
   to the ‘package-formers’ list and all instantations to the
   ‘instantiations-remaining’ list.
  "
  (interactive)

  ;; For now, ‘item’ is a PackageFormer, instantiation declaration, or other Agda code.
  (let (item lines 700-cmnts)

  ;; 0. Catenate all 700-comments into a single string.
  (setq 700-cmnts (s-join "\n" (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}")))

  (if (equal 700-comments 700-cmnts) (message "700-comments Unchanged.")

    ;; ½. Update global.
    (setq 700-comments 700-cmnts)

    ;; 1. View comments as a sequence of lines, ignore empty lines ---which are not in our grammar.
    (setq lines (--remove (s-blank? (s-collapse-whitespace it)) (s-lines 700-comments)))

    ;; 2. Traverse the 700-comments:
    ;; If we view a “lhs = rhs” equation, add to global ‘instantiations-remaining’ list.
    ;; If we view a PackageFormer declaration, add to global ‘package-formers’ list.
    (while lines
     (setq item (car lines))

     (if (load-instance-declaration item) (setq lines (cdr lines))

       ;; Else we have a PackageFormer declaration and other possiblly-non-700 items.
       (setq item (get-children "PackageFormer" lines))
       ;; port non-700 items to generated file
       (push (s-join "\n" (car item)) porting-list)
       ;; acknowledge PackageFormer declaration, if any
       (when (cadr item) (load-package-former (cadr item)))
       ;; Update lines to be the unconsidered porition of the wild comments.
       (setq lines (caddr item))))

  (message "Finished parsing 700-comments.")
  )
))
#+END_SRC

Let's test this out on our sample input file, ~Testing.agda~.
#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(ert-deftest l7c ()
(let (this)
  (flet ((buffer-substring-delimited-whole-buffer (x y) (s-split "\n" this))
     (same (x y) (progn (setq this y)
             (setq 700-comments nil porting-list nil)
             (load-700-comments)
             (should (equal x this)))))

       (same (car porting-list) "variable
   ℓ : Level"))
))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(let (package-formers
      700-comments
      porting-list
      instantiations-remaining)

  (find-file "Testing.agda")
  (load-700-comments)
  (switch-to-buffer "PackageFormer.org")

  (s-join "\n\n"
      (list (s-trim 700-comments)
        (pp package-formers) (pp instantiations-remaining)))
)
#+END_SRC

#+RESULTS:
#+begin_src results-agda
variable
   ℓ : Level

PackageFormer MonoidP : Set₁ where
    Carrier : Set
    _⨾_     : Carrier → Carrier → Carrier
    Id      : Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : ∀ {x : Carrier} → Id ⨾ x ≡ x
    rightId : ∀ {x : Carrier} → x ⨾ Id ≡ x

MonoidR  = MonoidP record
MonoidR′ = MonoidR renaming (λ x → x ++ "′")

(#s(package-former nil "PackageFormer" "MonoidP" "₁" 0 4
           ("Carrier : Set" "_⨾_     : Carrier → Carrier → Carrier" "Id      : Carrier" "assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)" "leftId  : ∀ {x : Carrier} → Id ⨾ x ≡ x" "rightId : ∀ {x : Carrier} → x ⨾ Id ≡ x")))


(#s(instance-declaration "MonoidR′ = MonoidR renaming (λ x → x ++ \"′\")" "MonoidR′" "MonoidR"
             (("renaming" nil
               (lambda
                 (x)
                 (concat x "′")))))
   #s(instance-declaration "MonoidR  = MonoidP record" "MonoidR" "MonoidP"
               (("record"
                 (("record"))
                 identity))))
#+end_src

* ~instantiate~ ---the core utility
# TODO:
Let's put the pieces together.
#+BEGIN_SRC emacs-lisp  :tangle yes
(cl-defun instantiate (id)

  "Given an instance-declaration ‘id’, produce a new PackageFormer.
  "

  (should (instance-declaration-p id))
  (let ((self (copy-package-former (cdr (assoc (instance-declaration-package-former id) package-formers))))
        variation op $𝑛𝑎𝑚𝑒)

    ;; “(⁉ 'c)” ≈ Get component c, if present, from op.
    ;;              Moreover, if its result references one of op's arguments
    ;;              then evaluate it (as a Lisp expression)
    ;;              otherwise return it as is.
;    (flet ((⁉ (c) nil)
      ; (-as-> (cdr (assoc c (cadr op))) 𝓇
      ;       (if (--any (s-contains? (format "%s" it) (format "%s" 𝓇)) (car op))
      ;       (eval 𝓇)  𝓇)))
       ;; Don’t bother generating non-working Agda code: Better see the error now rather than at Agda typechecking.
 ;      (700-wf (c m) (unless c (error (format "700: %s\n\n\t⇨\t%s\n\t⇨\t%s ≈ %s" m (instance-declaration-docstring id) variation op))))

;      (700-wf self (format "Parent “%s” not defined." (instance-declaration-package-former id)))

      (setf (package-former-docstring self) (instance-declaration-docstring id))
      (setq $𝑛𝑎𝑚𝑒 (instance-declaration-name id))
      (setf (package-former-name self) $𝑛𝑎𝑚𝑒)

                ;; :kind ≈ The vocabulary that replaces “PackageFormer”.
          (when-let ((kind (cdr (assoc ':kind (instance-declaration-alterations id)))))
              (should (symbolp kind))
              ; (700-wf (-contains? '(record data module PackageFormer) kind)
              ;    (format "This kind “%s” is not supported by Agda!\n     Valid kinds: record, data, module, PackageFormer." kind))
              (setf (package-former-type self) (format "%s" kind)))

      ;; We've just formed a new PackageFormer, which can be modified, specialised, later on.
      (add-to-list 'package-formers (cons (instance-declaration-name id) self))

      (show-package-former self)
))

        ;; loop ;; for (variation args *otherwise*) in (instance-declaration-alterations id)
        ;;   for (variation args) in (instance-declaration-alterations id)
        ;;   do
        ;;   (setq op (cdr (assoc variation variationals)))

          ;; Ensure op is well-formed: It's a list of length two: Arguments and body.
          ;; (should (= 2 (length op)))
          ;; Not true for anonymous variationals, which are sensibly only a body.
          ;;
          ;; When the variation is anonymous then the “args” are actually
          ;; the body.
          ;; (if (not (equal variation 'anonymous))

          ;;     (700-wf op (format "Variational “%s” not defined." variation))

          ;;     (setq op (list () args))) ;; Empty args list along with body.

          ;; ;; Substitute all formal variables for ‘op’ with their values.
          ;; (loop for arg in (cadr (assoc variation variationals))
          ;;   do
          ;;   ; (setq args (--map (mapcar (lambda (x) (quote x)) it) args))
          ;;   ; (message-box "%s ; %s; %s" args arg (assoc (intern arg) args))
          ;;   (--> (cdr (assoc (intern arg) args)) (700-wf (consp it) (format "Arguments for “%s” must be provided as nonempty ()-enclosed lists." arg)))
          ;;   (set (intern arg) (car (cdr (assoc (intern arg) args))))
          ;;    ;; TODO: MA: Only considering the first argument of a list; for now.

          ;; :kind ≈ The vocabulary that replaces “PackageFormer”.
          (when-let ((kind (cdr (assoc ':kind (instance-declaration-alterations id)))))
              (should (symbolp kind))
              ; (700-wf (-contains? '(record data module PackageFormer) kind)
              ;    (format "This kind “%s” is not supported by Agda!\n     Valid kinds: record, data, module, PackageFormer." kind))
              (setf (package-former-type self) (format "%s" kind)))

          ;; ;; :waist ≈ The division between parameters and remaining elements.
          ;; (when-let ((waist (⁉ 'waist)))
          ;;   (700-wf (numberp waist) (format "The “waist” should be a number; which “%s” is not." waist))
          ;;   (setf (package-former-waist self) waist))

          ;; ;; :waist-strings ≈ Extra strings to insert at the waist position.
          ;; (when-let ((strings (⁉ 'waist-strings)))
          ;;   (assert (listp strings))
          ;;   (setf (package-former-waist-strings self) strings))

          ;; ;; :level ≈ Either 'inc or 'dec, for increment or decrementing the level.
          ;; (when-let ((key (⁉ 'level)) (lvl (package-former-level self))
          ;;        (toLevel (lambda (n) (s-join "" (-concat
          ;;               (-repeat n "Level.suc (") (list "Level.zero") (-repeat n ")")))))
          ;;        (subs `("" "₁" "₂" "₃" "₄" "₅" "₆" "₇" "₈" "₉" ,(funcall toLevel 10))))

          ;;   (700-wf (-contains? '(inc dec) key) "The “level” must be “inc” or “dec”.")

          ;;   (if-let ((here (-elem-index (s-trim lvl) subs)))

          ;;     (setq lvl (pcase key
          ;;   ('inc (nth (1+ here) subs))
          ;;   ('dec (nth (1- here) subs))))

          ;;     (setq lvl (pcase key
          ;;   ('inc (format "Level.suc (%s)" lvl))
          ;;   ('dec (s-join "suc" (cdr (s-split "suc" lvl :omit-nulls)))))))

          ;;   (setf (package-former-level self) lvl))

          ;; ;; :alter-elements ≈ Map over the typed name constituents.
          ;; (when-let ((ae (⁉ 'alter-elements)))
          ;;   (setf (package-former-elements self)
          ;;     (-map ae (package-former-elements self))))
          ;;     ;; (setq fsnew (funcall op otherwise fs)) ;; MA: TODO: Incorporate ‘args’!

      ;; We've just formed a new PackageFormer, which can be modified, specialised, later on.
      (add-to-list 'package-formers (cons (instance-declaration-name id) self))

      (show-package-former self)

#+END_SRC

# DONE:
Let's instantiate our test example from earlier to produce a super simple record;
i.e., legitimate Agda. Moreover, let's decorate each field name with a prime
and lift-up the first two items to be parameters.

#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
;   "𝒱-primed-record = :kind record :waist-strings (\"field\") :alter-elements (λ f → (map-name (concat name \"′\") f))")
(load-variational "𝒱-primed-record = :kind record")
(setq package-formers nil)
(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewNasme = M-Set :kind record")))
  (instantiate mid)
)



(cdr (assoc ':kind '((:kind . record))))
#+END_SRC

# RESULTS:
#+begin_src results-agda
{- NewNasme = M-Set primed-record ⟴ :waist 2 -}
record NewNasme (Scalar′ : Set) (Vector′ : Set) : Set₁ where
 field
   _·′_ : Scalar → Vector → Vector
   𝟙′ : Scalar
   _×′_ : Scalar → Scalar → Scalar
   leftId′ : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc′ : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+end_src

:asserts:
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"

(assert (equal "NewNasme = {! Undefined Parent: M-Sset !}"
        (instantiate (load-instance-declaration "NewNasme = M-Sset var"))))

(assert (equal "NewNasme = {! Undefined Variational: do-the-thing !}"
        (instantiate (load-instance-declaration "NewNasme = M-Set do-the-thing"))))
#+END_SRC
:End:

# DONE:
Let's form a Haskell-like typeclass; more precisely, a record where the first two
fields are exposed as parameters.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
  "𝒱-typeclass₂ = :kind record :level dec :waist-strings (\"field\") :waist 2"))
  (setq variationals nil)
  (load-variationals)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set typeclass₂")))

  (instantiate mid)
))
#+END_SRC

#+RESULTS:
#+BEGIN_src results-agda
{- NewName = M-Set typeclass₂ -}
record NewName (Scalar : Set) (Vector : Set) : Set where
 field
   _·_     : Scalar → Vector → Vector
   𝟙       : Scalar
   _×_     : Scalar → Scalar → Scalar
   leftId  : {𝓋 : Vector}  →  𝟙 · 𝓋  ≡  𝓋
   assoc   : {a b : Scalar} {𝓋 : Vector} → (a × b) · 𝓋  ≡  a · (b · 𝓋)
#+END_src

The Vector & Scalar sorts are exposed!
Moreover, the level of the resulting record is as minimal as possible ^_^ Neato! 🐺

# What about a bundled up record declaration? Simple, we leave the waist with default value zero.

Records provide a semantics, what if we want the syntax?
Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

First, a helper function.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun target (field)
  "Given a declaration “name : type0 → ⋯ → typeN”, yield “typeN”. "
  (ignore-errors (car (-take-last 1 (s-split "→" field))))
  ;; Ignore errors since field may be nil.
)
#+END_SRC

Let's test it out:
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace
(-let [pf-name "Semigroup-syntax"]

  (list (s-contains? pf-name (target "Id    :  Semigroup-syntax"))
    (s-contains? pf-name (target "_⨾_   :  Semigroup-syntax → Semigroup-syntax → Semigroup-syntax"))
    (s-contains? pf-name (target "assoc :  ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)"))
    (s-contains? pf-name (target "Semigroup-syntax : Set")))
)
#+END_SRC

#+RESULTS:
| t | t | nil | t |

As the last test case shows, the name position of a declaration could have
a data-type name --which is not allowed in Agda since constructors share the
same namespace as types, yet this property is not ensured in our generation;
so let's sanitise for it.

Now a real use case.

# DONE:
 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"𝒱-data-with carrier = :kind data :level dec :alter-elements (λ f → (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $𝑛𝑎𝑚𝑒 type) f) \"\"))"))
  (setq variationals nil)
  (load-variationals)
  (setq package-formers nil)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "ScalarSyntax = M-Set data-with :carrier (\"Scalar\")")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
  ))
#+END_SRC

#+RESULTS:
#+BEGIN_src results-agda
{- ScalarSyntax = M-Set data-with :carrier ("Scalar") -}
data ScalarSyntax : Set where



   𝟙 : ScalarSyntax
   _×_ : ScalarSyntax → ScalarSyntax → ScalarSyntax


#+END_src

Notice that $𝑛𝑎𝑚𝑒 is a special variable that refers to the newly defined PackageFormer's name.
- It is written using ~\Mi~ with Agda input; e.g., ~\Min~ gives ~𝑛~.
- The ‘$’ is intended to further mark the special nature of this variable.

Yeehaw! We've got three variations and possibly much more from a small core interface
🤠 We can emulate generative modules this way too! 😻

Let's package these particular toggle configurations into their own functions.

:TODO:
That's a lot of mumbo jumbo, let's have a sanity check.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(s-join "\n\n" (list
 (instantiate-as-unbundled 1 test :name-suffix "On") ;; typeclass
 (instantiate-as-unbundled 0 test :name-suffix "semantics") ;; record
 (instantiate-as-data test)
))
#+END_SRC

#+RESULTS:
#+begin_src results-agda
{- This was generated from the PackageFormer Semigroup . -}
record Semigroup-On (Carrier : Set) : Set where
  field
    _⨾_ : Carrier → Carrier → Carrier
    Id  : Carrier
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

{- This was generated from the PackageFormer Semigroup . -}
record Semigroup-semantics : Set (Level.suc Level.zero) where
  field
    Carrier : Set
    _⨾_ : Carrier → Carrier → Carrier
    Id  : Carrier
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

{- This was generated from the PackageFormer Semigroup . -}
data Semigroup-syntax : Set where
    _⨾_ : Semigroup-syntax → Semigroup-syntax → Semigroup-syntax
    Id  : Semigroup-syntax
#+end_src

Notice that the results contained generated names since no names were provided.

Woah, look at that: This' reminiscent of that 200% increase from earlier ;-)
*Moreover*, with ~unbundled~ we may expose any or all constituents of a package
at will.

{{{fold(Unit Tests)}}}
#+BEGIN_SRC emacs-lisp :var test = test
(ert-deftest inst ()

  ;; Parameterised record
  (should (equal (instantiate test :carrier "Carrier" :docstring "" :waist-strings (list "field") :waist 2)
         "{-  -}
record Semigroup- (Carrier : Set) (_⨾_ : Carrier → Carrier → Carrier) : Set where
  field
    Id  : Carrier
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)"))

  (should (equal  (instantiate-as-unbundled 1 test :name-suffix "On")
          "{- This was generated from the PackageFormer Semigroup . -}
record Semigroup-On (Carrier : Set) : Set where
  field
    _⨾_ : Carrier → Carrier → Carrier
    Id  : Carrier
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)"))

  ;; ADT, data declaration
  (should (equal  (instantiate test :type "data" :new-name "𝒮" :docstring "" :inc-level nil
                   :keep-fields (lambda (f) (s-contains? "𝒮" (target (cadr (s-split ":" f))))))
          "{-  -}
data 𝒮 : Set where
    _⨾_ : 𝒮 → 𝒮 → 𝒮
    Id  : 𝒮"))

   (should (equal (instantiate-as-data test)
          "{- This was generated from the PackageFormer Semigroup . -}
data Semigroup-syntax : Set where
    _⨾_ : Semigroup-syntax → Semigroup-syntax → Semigroup-syntax
    Id  : Semigroup-syntax")))

#+END_SRC
{{{end-fold}}}
:END:

** TODO COMMENT Module instantions

We can emit module declarations as follows; which may be useful for ADT instantions
of PackageFormers that contain derived operations.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(instantiate test   :new-name "Semantics₁"
            :type "module"
            :carrier "Carrier"
            :omit-level-decl t
            :waist 4
            )
#+END_SRC

#+RESULTS:
#+begin_src results-agda
{- This was generated from the PackageFormer Semigroup . -}
module Semantics₁ (Carrier : Set) (_⨾_ : Carrier → Carrier → Carrier) (Id : Carrier) (assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)) where
#+end_src

For now, a common scenario is forming modules that re-export a type under a new superficial disguise;
e.g., in the setting where we want to have multiple references to a structure, as in when defining homomorphisms.
#  :tangle yes
#+BEGIN_SRC emacs-lisp exports both :results replace :wrap "src results-agda"
(cl-defun instantiate-as-opening (decls inst)

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - ‘decls’ is immediately provided to ‘get-children’, so it may be a string,
      a list, or a value of type ‘package-former’.

   - ‘inst’ is an instance declaration value whose ‘openings’ componenet is non-nil.
  "

  (let* ((openings (instance-declaration-openings inst))
     (new-name (instance-declaration-name inst))
     (kind (car openings))
     (renames (cadr openings))
     (otherwise (caddr openings)))

    (s-replace "\t" "    " ;; replace rabs with spaces
    (instantiate decls    :new-name new-name
            :type "module"
            :docstring (instance-declaration-docstring inst)
            :omit-level-decl t
            :waist 1
            :alter-fields (lambda (fs)
             (let (fsnew)


               (loop for (old . new) in renames
                 do (push (format "%s to %s" old new) fsnew))

               ;; TODO: MA: To consider default ‘otherwise’ via opening λ x → x ++ "′"
               ;; (read-from-string "(lambda (x) xt)")
               ;;

               ;; HACK: Terrible.
               (setq fs (cons (map-name "Carrier" (car fs)) (cdr fs)))

               (loop for f in fs
                 do (unless (assoc (get-name f) renames)
                  (push (format "%s to %s" (get-name f)
                        (rename-mixfix otherwise (get-name f)))
                    fsnew)))

               (thread-last
            ;; Resulting elements must be a list, so we make a singleton list.
            (format "\t\t( %s\n\t\t\t)" (s-join "\n\t\t\t; " (reverse fsnew)))
            list

            ;; Stick on the renaming, which in turn requires an opening clause;
            ;; which in turn requires a module parameter.
            (cons "\t renaming")
            (cons (format "open %s ℛ public" kind))
            (cons (format "ℛ : %s" kind))
               )

    ))))))
#+END_SRC

#+RESULTS:
#+begin_src results-agda
instantiate-as-opening
#+end_src

Let's test it out.
#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(-let [inst (load-instance-declaration "Monoid′ = MonoidPF opening Monoid (Carrier to 𝒮; _⨾_ to _⊕_; λ x → x ++ \"′\")")]
  (instantiate-as-opening test inst))
#+END_SRC

#+RESULTS:
#+begin_src results-agda
{- Monoid′ = MonoidPF opening Monoid (Carrier to 𝒮; _⨾_ to _⊕_; λ x → x ++ "′") -}
module Monoid′ (ℛ : Monoid) where
    open Monoid ℛ public
     renaming
        ( Carrier to 𝒮
        ; _⨾_ to _⊕_
        ; Id to Id′
        ; assoc to assoc′
        )
#+end_src

This utility shines when we use it wholesale; as follows.
#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(let ((inst₁ (load-instance-declaration "Monoid₁ = MonoidPF opening Monoid (λ x → x ++ \"₁\")"))
      (inst₂ (load-instance-declaration "Monoid₂ = MonoidPF opening Monoid (λ x → x ++ \"₂\")")))
  (s-join "\n\n" (list (instantiate-as-opening test inst₁) (instantiate-as-opening test inst₂))))
#+END_SRC

#+RESULTS:
#+begin_src results-agda
{- Monoid₁ = MonoidPF opening Monoid (λ x → x ++ "₁") -}
module Monoid₁ (ℛ : Monoid) where
    open Monoid ℛ public
     renaming
        ( Carrier to Carrier₁
        ; _⨾_ to _⨾₁_
        ; Id to Id₁
        ; assoc to assoc₁
        )

{- Monoid₂ = MonoidPF opening Monoid (λ x → x ++ "₂") -}
module Monoid₂ (ℛ : Monoid) where
    open Monoid ℛ public
     renaming
        ( Carrier to Carrier₂
        ; _⨾_ to _⨾₂_
        ; Id to Id₂
        ; assoc to assoc₂
        )
#+end_src

We have written this kind of boilerplate so often that we welcome the
sweet relief provided by the editor tactic being developed herein.

** Instantiate all items in ~instantiations-remaining~

#+BEGIN_SRC emacs-lisp :tangle yes
;; Function combinators; e.g., -partial/-cut, -const, -compose, -orfn & -andfn for generalised ∃/∀.
(use-package dash-functional) ;; https://github.com/magnars/dash.el
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun reify-instances ()
 "Instantiate all items in ‘instantiations-remaining’."

 (interactive)

 (let* (result)

   ;; We parsed them top-down, so they're in the wrong order.
   ;; Order matters since declarations yield new PackageFormers
   ;; which may be used in subsequent declarations.
   (dolist (inst (reverse instantiations-remaining))

     ;; Add to list of results. The empty string yields a new line between each generated instantiation.
      (setq result (-cons* (instantiate inst) "" result))
     )

   ;; Output results as a string.
     (s-join "\n" (reverse result))
))
#+END_SRC

Super cool stuff ~(งಠ_ಠ)ง~

:Thoughts_TODO:
#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
;; As always, let's ensure this works as intended.
(let (package-formers instantiations-remaining 700-comments porting-list variationals)

  (find-file "Testing.agda")
  (load-700-comments)
  (load-variationals)

  (switch-to-buffer "PackageFormer.org")

  (reify-instances)
)

#+END_SRC



Note that the renaming clause must have its old forms appear in the same order that they appear in the original declaration.
This could be avoided by obtaining the names of the continents, then intersecting that with the renames list, along the first component.
:End:

NOTE: Level polymorphism with generalised variables does not work for
data declaration.

* Advising our Beloved ~C-c C-l~

Let's give the current buffer access to the location of the generated file.
#+BEGIN_SRC emacs-lisp  :tangle yes
(defun insert-generated-import (name-of-generated-file)
  "In the current file, find the top-most module declaration
   then insert an import of the generated file.
  "
  (interactive)

  (save-excursion
    (beginning-of-buffer)
    (condition-case the-err
      ;; attemptClause:
      (re-search-forward (concat "open import " name-of-generated-file))
       ;; recoveryBody:
      (error ;; (message-box (format "%s" the-err))
     (re-search-forward "\\(module.*\\)")
     (replace-match (concat "\\1\nopen import " name-of-generated-file))
    )
    )
  )
)
#+END_SRC

The aim is to process test enclosed in ~{-700 ⋯ -}~ comments,
produce legitimate Agda from that, and ensure the generated Agda is accessible to the
current buffer automatically.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun reify-package-formers (orig-fun &rest args)
  (interactive)

  (let (generated-file-name
    (parent-imports (extract-imports))
       )

  ;; Sometimes we may want the full name due to files being in a nested
  ;; directory hierarchy: (file-name-sans-extension buffer-file-name)
  (setq generated-file-name (concat(file-name-sans-extension (buffer-name))
          "_Generated"))

  ;; Load variationals, PackageFormers, instantiations, and porting list.
  ;; Setting the following to nil each time is not ideal.
  (setq	variationals              nil
    package-formers           nil
    instantiations-remaining  nil
    700-comments              nil
    porting-list              nil)

  (load-variationals)
  (load-700-comments)

  (with-temp-buffer
    (beginning-of-buffer)

    ;; Copy/paste imports from parent file.
    (insert (s-join "\n" `(
         "{- This file is generated ;; do not alter. -}\n"
         ,parent-imports
         "open import Level as Level"
         ,(format "module %s where " generated-file-name)
         , (s-join "\n" porting-list)
         ,(reify-instances))))

    (write-region (beginning-of-buffer) (end-of-buffer)
          (concat generated-file-name ".agda"))
    )

  (insert-generated-import generated-file-name)
  )

  ;; Need to revert buffer to discard old colours.
  ;; (save-buffer) (revert-buffer t t t)

  ;; call agda2-load
  (apply orig-fun args)

   ;; Colour 700 keywords
  ;; (loop for kw in '("PackageFormer" "Variation" "hiding" "renaming" "unbundling" "exposing" "renaming" "with")
  ;;  do (highlight-phrase kw 'hi-green))
  ;; Replace with a hook.

  (highlight-phrase "700" 'error)

  (message "700 ∷ All the best coding! (•̀ᴗ•́)و")
)

(advice-add 'agda2-load :around #'reify-package-formers)
#+END_SRC

Personal note:
Using ~(write-file "Generated.agda")~ means we make a file
then the temporary buffer /visits/ the Agda file, which loads the
Agda process therein, which is undesirable since it could leave
Agda working on the buffer even after it has been killed!
+ This would necessiate calling ~(agda2-restart)~ afterwards.
+ Instead we write the whole region, without visiting the resuting file.

* Menu matter
Let's quickly add a menu bar that allows users to enable or disable using PackageFormer's;
along with a brief help menu.

{{{fold(The global map)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar 700-menu-bar (make-sparse-keymap "700 PackageFormers"))

(define-key global-map [menu-bar 700menu] (cons "700PackageFormers" 700-menu-bar))
#+END_SRC
{{{end-fold}}}

{{{fold( Enabling the feature )}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [enable-package-formers]
  '(menu-item "Enable PackageFormer Generation" enable-package-formers))

(defun enable-package-formers ()
 (interactive)
 (advice-add 'agda2-load :around #'reify-package-formers)
 (message-box "C-c C-l now reifies “700-comments” into legitimate Agda.")
)
#+END_SRC
{{{end-fold}}}

{{{fold( Disabling the feature )}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [disable-package-formers]
  '(menu-item "Disable PackageFormer Generation" disable-package-formers))

(defun disable-package-formers ()
 (interactive)
 (advice-remove 'agda2-load #'reify-package-formers)
 (setq global-mode-string (remove "700 (•̀ᴗ•́)و " global-mode-string))
  (message-box "C-c C-l now behaves as it always has.")
)
#+END_SRC
{{{end-fold}}}

{{{fold( About menu )}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [package-formers-about]
  '(menu-item "About PackageFormers" package-formers-about))

(defun package-formers-about ()
 (interactive)
 (switch-to-buffer "*PackageFormer-About*") (insert
  " This is an editor extension prototyping “the next 700 module systems” proposed research.

    An informal documentation, with examples, page can be found at
    https://alhassy.github.io/next-700-module-systems-proposal/PackageFormer.html

    The technical matter can be found at https://alhassy.github.io/next-700-module-systems-proposal/

    If you experience anything “going wrong” or have any ideas for improvement,
    please contact Musa Al-hassy at alhassy@gmail.com; thank-you ♥‿♥
  "
 )
)

#+END_SRC
{{{end-fold}}}

Let's pack these together into a minor mode.
{{{fold( Minor mode )}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(define-minor-mode 700-mode
    "This is an editor extension prototyping “the next 700 module systems” proposed research.

    An informal documentation, with examples, page can be found at
    https://alhassy.github.io/next-700-module-systems-proposal/PackageFormer.html

    The technical matter can be found at https://alhassy.github.io/next-700-module-systems-proposal/

    If you experience anything “going wrong” or have any ideas for improvement,
    please contact Musa Al-hassy at alhassy@gmail.com; thank-you ♥‿♥
  "
  :lighter " 700 (•̀ᴗ•́)و)" ;; Icon to display indicating the mode is enabled.
  :require 'foo

  ;; Toggle the menu bar
  ;; (define-key global-map [menu-bar 700menu] t)(not 700-mode))
  (define-key global-map [menu-bar 700menu] (and 700-mode (cons "700PackageFormers" 700-menu-bar)))

  (letf (( (symbol-function 'message-box) #'message))
  (if 700-mode
      ;; Initilisation
      (enable-package-formers)

      ;; Closing
      (disable-package-formers)
  ))

)
#+END_SRC
{{{end-fold}}}

* TODO COMMENT tooltips

https://stackoverflow.com/questions/293853/defining-new-tooltips-in-emacs

http://kitchingroup.cheme.cmu.edu/blog/2016/03/16/Getting-graphical-feedback-as-tooltips-in-Emacs/

;; List of pairs of strings that denote words and their associated tool tips.
;; May move to a hash.
(setq 700-words nil)

(push '("GNUU" . "Editor MACroS") 700-words)

(loop for (key . value) in 700-words
      do (font-lock-add-keywords nil
      `(( ,key
         0
         '(face font-lock-keyword-face help-echo
            (lambda (window object position) "t" ,value))))))
* Future Work

Well, that was a lot of Lisp I had to learn ~(งಠ_ಠ)ง~

Hopefully the resulting prototype will be useful to others;
drop me a line if you're interested in this effort or have
any feedback or pointers!

#+begin_center org
★ ★ ★
#+end_center

Below are some desirable features to work on.

#
# Check them off, rather than deleting them,
# to produce a ‘tada’ list of features ;-)
#

+ [ ] Colouring for 700-syntactical items.

+ [ ] Tooltips

+ [ ] MA: WK: hiding ↦ dropping

+ [ ] Use buffer-substring-delimited-whole-buffer to parse /multiple/
      700-comments!

+ [ ] Add a level component to an instance structure; reduce it if Carrier is a parameter and otherwise leave it alone.
      Instead, let the level of a PackageFormer denote the level of the typeclass instantiation, then with this in mind
      we increase the level component of an instance structure only for those variations that keep the carrier as a field.
      When we move to multi-sorted, as in Graphs, this issue will need to be revisited.

+ [ ] Currently can only perform simple variational clauses; need to support complex clauses.

+ [ ] Currently variational clauses apply as follows ~PF v clause~, it would be useful to have them also apply
  as ~I clause~ where ~I = PF v~ has already been declared. This would requuire we keep a list of instances and their parent PF;
  our current list is consumed and thrown away.

   # TODO: Give an example making use of suffix-fields to ‘extend’ a packageformer with new fields. E.g., PackageFormer B = A extended-by cs ought to be valid but so should I = A vs extended-by cs which is amicable syntax for the instantation (A extended-by cs) vs. Should this automatically yield forgetful coercisions “I⇒A”? For now, maybe yes by default and no if we use, say, fields instead of extended-by. There will be issues of coherency when we add items.

+ [X] Need to implement a *front-end* system to extend variational clauses.

+ [ ] The ~elements~ of a PackageFormer should be  an alist, ~'(name . type)~.
  - Maybe not, the front-end lets users treat them as strings, easily.
  - Maybe such a view is useful for the user? It is provided via ~get-name~ and ~get-type~.

+ [ ] Refactor load-instantions function to make use of an ~alter~ field rather than overloading alter-fields in reify-instances.

+ [ ] Refactor ~instantiate~ to make use of an ~instance~ structure, rather than 13 arguments.

+ [ ] Why does ‘buffer-substring-delimited-whole-buffer’ return a list of strings? Why not join its result to simply return a list?

+ [ ] Generated.agda needs to inherit all open/import declarations from parent.

+ [ ] Give an example PackageFormer with some definitions or derived constructs, then hoist-up your waist so that the non-defined items are ~module~ parameters.

+ [ ] ~B = cs ⟨+ A ⟨+ cs′~ where each cs is a single name-type declaration and the operation is left-associative, and A is an existing packageformer. This gives us a nice way to build a hierarchy. Note that since only A has a name, we may form a forgetful coercion B⇒A automatically.
  E.g., ~Monoid = Type ⟨+ Pointed ⟨+ (Magma renaming (_⊕_ to _⨾_)) ⟨+ LeftUnital ⟨+ RightUnital ⟨+ assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)~ gives, automatically, ~Monoid⇒Type, Monoid⇒Pointed, Monoid⇒Magma, Monoid⇒LeftUnital, Magma⇒RightUnital~ (•̀ᴗ•́)و MA: To begin with, ignore the rename and work up the sequence one ⟨+ at a time.

+ [ ] PF's should account for equations. For simplicity they become components of a record & module, but derived operations on datatypes.

+ [ ] Demonstrate how generative modules can be emulated.

+ [ ] For now, PackageFormer's have no other parameters besides the variation symbol.

+ [ ] The global variables package-formers & instance-declaration should be /buffer/ specific?

+ [ ] Assign to a local var, check equality against global 700-comments,
      if identical, no more processing since everything already generated.

+ [ ] Make use of docstring so that when a user enters a key sequence or selects from a menu, we can show them a listing of all ‘major’ components of a program: An org-mode file is displayed with an enumeration of the items, each being a link to the source, and only their docstring is shown. This is a nice ‘overview’ of the program source.

+ [ ] Currently it looks like we are a minor mode, but this is not true. We only have a menu and the icon (•̀ᴗ•́)و is displayed when our feature is supported.

+ [ ] Generate all instances of a PackageFormer schema.

+ [ ] Allow package formers to have explicit ~Variation~ parameters; but
      how do we then deal with nested invocations? What are the uses of
      having differing invocations?

      For example,
      #+BEGIN_SRC agda
PackageFormer LawfullyPointed (v : Variation) : Set where
   point : LawfullyPointed v
   law   : LawfullyPointed FOL {- Concrete variation -}

                         #+END_SRC
      Would elaborate to something like:
      #+BEGIN_SRC agda
       data LP-Term (Vars : Set) : Set where
        {- Abstract fields from constituents of packageformer -}
        Point    : LP-Term
        {- Fragment of first order logic term formation -}
        _′       : Vars → LP-Term {- Injection of vars as terms -}
        _≈_      : LP-Term → LP-Term → LP-Term
        ∀′ ∃′    : (Vars → LP-Term) → LP-Term

       record LP : Set₁ where
     constructor _,_,_
     field
        Carrier : Set
        point   : Carrier
        law     : LP-Term Carrier
#+END_SRC

      With the following example uses.
      #+BEGIN_SRC agda
      Contractable : (A : Set) (a : A) → LP
      Contractable A a =  A , a , ∀′ (λ x → x ≈ a ′)

      Indistinguishable : (A : Set)  →  LP hiding point
      Indistinguishable A a =  A , ∀′ (λ x → ∀′ (λ y → x ≈ y))
      #+END_SRC
      Where ~PF hiding c~ is the largest sub-PackageFormer of ~PF~ with constituent ~c~
      removed ---in particular, constituents that depend on ~c~ would also be dropped.

      :Hide:
    #+BEGIN_SRC emacs-lisp
(defun generate-all-instances () ;; TODO
  "For each PackageFormer ‘pf’, produce the default instances:
   ‘pf-record’, ‘pf-typeclass’, ‘pf-data’.

   Use: You want a particular instance in rapid developement and don't want
   to be bothered to give it a name. Or experimenting and unsure which instance
   is most desirable, so have access to all of them.

   Possible extensions:
   0. Introduce concrete syntax “GenerateDefaultInstances pf” to invoke this command.
   1. Have a global list of default instances.
  "

  (interactive)

    ;; Keep this around since we may want to produce variations wholesale with
  ;; names: packageformer-variation; e.g., Magma-typeclass.
  ;;
  ;;
  ;; the variations
;;  (setq the-vars-shush (--map (car it) (--map (-take-last 1 it) (--map (s-split " " it) decls-vars-shush))))
  ;;
  ;; (dolist (variation the-vars-shush ll)
  ;;  (setq ll (cons (make-typeclass decls (concat pf-name "-" variation)) ll)))

  )
#+END_SRC
      :End:

* COMMENT ~instantiate~ ---the /backend/ core utility                         :posterity:
Let's put the pieces together.
#+BEGIN_SRC emacs-lisp
(cl-defun instantiate (decls &key
  new-name (type "record") carrier
  name-suffix
  (variation-replacement "")
  (prefix-fields "") (suffix-fields "") omit-field-header
  (keep-fields (lambda (x) t))
  (alter-raw-fields #'identity)
  (alter-fields #'identity)
  )

  "Given a PackageFormer declaration, instantiate it into a concrete Agda type.

   Remarks or example values:

   - ‘decls’ is immediately provided to ‘get-children’, so it may be a string
      or a list.

   - ‘type’: The replacement for “PackageFormer”; default is “record”.

   - ‘carrier’: What is the carrier of this new instance? E.g., “Carrier”.
      By default it's the ‘new-name’; but this is unresonable when, say, a typeclass
      variation is requested.

   - ‘name-suffix’: When no ‘new-name’ is provided, the default is
      “⟪PackageFormer'sName⟫-⟪variation⟫-g*”, where ‘*’ is an arbitrarily generated number.

     This may be useful for rapid development when one does not want to provide
     a name to an instance, but simply wants the instance to exist.

   - ‘variation-replacement’: “(Carrier : Set)”; empty string by default.

   - ‘prefix-fields’: List of fields, “name : type”, to be added at the beginning
      of the field declaration. Default is empty string.

   - ‘suffix-fields’: List of fields, “name : type”, to be added at the beginning
      of the field declaration. Default is empty string.

   - ‘omit-field-header’: Should the “field” word be removed? No by default.

   - ‘keep-fields’: Predicate that determines which fields should be kept.
      By default, no fields are dropped.

   - ‘alter-raw-fields’: A function that alters the list of fields of a PackageFormer *before*
     any processing has transpiried. This is the identity function by default.

   - ‘alter-fields’: A function to alter existing fields *after* processing;
     it does not alter inserted fields via ‘prefix-fields’ nor ‘suffix-fields’.
     This is the identity function by default.
  "

  (let* ((pf (cadr (get-children "PackageFormer" decls)))
     (header     (car pf))
     (pf-name (package-former-name header))
     (pf-variation (variation-symbol header))
     (field-decl (cadr pf)) ;; In order to maintain user-provided indentation.
     (fields     (funcall alter-raw-fields (cddr pf)))
     (indentation (s-repeat (if fields (get-indentation (car fields)) 0) " "))
       (preFields   (--map (concat indentation it) prefix-fields))
       (postFields  (--map (concat indentation it) suffix-fields))
     (tc nil)
     )

  ;; Default value of ‘new-name’ & ‘carrier’ are ⟪PackageFormer'sName⟫-⟪name-suffix⟫.
  (unless new-name (setq new-name (format "%s-%s-%s" pf-name name-suffix (gensym))))
  (unless carrier  (setq carrier new-name))

  ;; Replace "(? : Variation)" with the provided ‘variation-replacement’
  (setq header (insert-parameter variation-replacement (erase-parameters header)))

  ;; Replace "PackageFormer" with ‘type’.
  (setq header (s-replace "PackageFormer" type header))

  ;; Replace PackageFormer's name with provided instantiation name.
  (setq header (s-replace pf-name new-name header))

  ;; Replace all occurences of “package-former-name followed by variation”
  ;; with ‘carrier’.
  (setq fields (--map (s-replace (concat pf-name " " pf-variation) carrier it) fields))

  ;; Perform any processing on the fields.
  (setq fields (funcall alter-fields (-filter keep-fields fields)))

  ;; Stick all the pieces together, along with the new fields.
  (setq tc (s-join "\n"
    (-cons* header
    (-concat
       (if omit-field-header () (list field-decl))
       preFields fields  postFields))))

  ;; Declare generation source matter.
  (concat
   "\n{- This was generated from the PackageFormer " pf-name " -}\n"
    tc)
 )
)
#+END_SRC

#+RESULTS:
: instantiate

Let's instantiate our test example from earlier to produce a typeclass.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
            :name-suffix "typeclass"
            :type "record"
            :variation-replacement "(Carrier : Set)"
            :carrier "Carrier"
            )
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-typeclass-g105 (Carrier : Set) : Set where
:   field
:     _⨾_ : Carrier → Carrier → Carrier
:     Id  : Carrier
:     assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

#+BEGIN_SRC emacs-lisp :var test = test :exports both
;; (instantiate test)

(setq _test (show (car package-formers)))

(instantiate _test :variation-replacement "noice")

;; (erase-parameters _test)
; (insert-parameter "(nn : ?)" (erase-parameters _test)))

;; (instantiate-as-typeclass (show (car package-formers)))
;; (instantiate (show (car package-formers)))
;; -as-typeclass (show (car package-formers)))
;; (stringp (show (car package-formers)))
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-nil-g106 noice : Set where
:   field
:     _⨾_ : Semigroup-nil-g106 → Semigroup-nil-g106 → Semigroup-nil-g106
:     Id  : Semigroup-nil-g106
:     assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

What about a bundled up record declaration?
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
            :name-suffix "semantics"
            :type "record"
            :carrier "Carrier"
            :prefix-fields '("Carrier : Set")
            )
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-semantics-g107  : Set where
:   field
:     Carrier : Set
:     _⨾_ : Carrier → Carrier → Carrier
:     Id  : Carrier
:     assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

Records provide a semantics, what if we want the syntax?
Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

First, a helper function.
#+BEGIN_SRC emacs-lisp
(defun target (field)
  " Given a declaration “name : type0 → ⋯ → typeN”, yield “typeN”. "
  (car (-take-last 1 (s-split "→" field)))
)
#+END_SRC

#+RESULTS:
: target

Let's test it out:
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (list (s-contains? package-former-name (target "     Id  : Semigroup-syntax"))
    (s-contains? package-former-name (target "_⨾_ : Semigroup-syntax → Semigroup-syntax → Semigroup-syntax"))
    (s-contains? package-former-name (target "     assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)")))
)
#+END_SRC

#+RESULTS:
| t | t | nil |

The results are as expected, so let's move to the real use case.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (instantiate test  :name-suffix "syntax"
             :type "data"
             :omit-field-header t
               :new-name package-former-name
               ;; :carrier package-former-name
             :keep-fields (lambda (f) (s-contains? package-former-name (target f)))
            )
)
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: data Semigroup-syntax  : Set where
:     _⨾_ : Semigroup-syntax → Semigroup-syntax → Semigroup-syntax
:     Id  : Semigroup-syntax

Yeehaw! We've got three variations and possibly much more from a single fancy well-toggled
function 🤠 We can emulate generative modules this way too! 😻

Let's package these particular toggle configurations into their own functions.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-typeclass (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda “typeclass”.

   - ‘new-name’ is the name of the resulting instance.
     Default is “⟪PackageFormer'sName⟫-record-g*” for a random sequence of digits ‘*’.

   - ‘carrier’: What is the carrier of this new instance? Default is “Carrier”.

  "
  (instantiate decls :new-name new-name
             :name-suffix "typeclass"
             :type "record"
             :variation-replacement (format "(%s : Set)" carrier)
             :carrier carrier
            )
)
#+END_SRC

#+RESULTS:
: instantiate-as-typeclass

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-record (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - ‘new-name’ is the name of the resulting instance.
     Default is “⟪PackageFormer'sName⟫-record-g*” for a random sequence of digits ‘*’.

   - ‘carrier’: What is the carrier of this new instance? Default is “Carrier”.

  "
  (instantiate test :new-name new-name
            :name-suffix "record"
            :type "record"
            :carrier carrier
            :prefix-fields `(,(format "%s : Set" carrier))
            )
)

#+END_SRC

#+RESULTS:
: instantiate-as-record

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-data (decls &key new-name (carrier "Carrier") (alter-fields #'identity))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - ‘new-name’ is the name of the resulting instance.
     Default is “⟪PackageFormer'sName⟫-record-g*” for a random sequence of digits ‘*’.

   - ‘carrier’: What is the carrier of this new instance? Default is “Carrier”.

  "
  (let* ((pf (cadr (get-children "PackageFormer" decls)))
     (header     (car pf))
     (pf-name (package-former-name header)))

    (instantiate test  :new-name new-name
               :name-suffix "syntax"
               :type "data"
               :omit-field-header t
               :keep-fields (lambda (f) (s-contains? pf-name (target f)))
               :alter-fields alter-fields
              )
  )
)
#+END_SRC

#+RESULTS:
: instantiate-as-data

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(s-join "\n" `(
,(instantiate-as-typeclass test)
,(instantiate-as-record test)
,(instantiate-as-data test)
))
#+END_SRC

#+RESULTS:
#+begin_example

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-typeclass-g108 (Carrier : Set) : Set where
  field
    _⨾_ : Carrier → Carrier → Carrier
    Id  : Carrier
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-record-g109  : Set where
  field
    Carrier : Set
    _⨾_ : Carrier → Carrier → Carrier
    Id  : Carrier
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

{- This was generated from the PackageFormer Semigroup -}
data Semigroup-syntax-g110  : Set where
    _⨾_ : Semigroup-syntax-g110 → Semigroup-syntax-g110 → Semigroup-syntax-g110
    Id  : Semigroup-syntax-g110
#+end_example

Notice that the results contained generated names since no names were provided.
* COMMENT PackageFormer Name and Variation Symbol          :possibly_not_needed:

As such, we form a method for
obtaining the name, the variation symbol, and a method to rewrite substrings of the
children ---wait, we already have the last one: ~get-children~ with optional ~:then~
keyword.

#+BEGIN_SRC emacs-lisp
;; The following two only work on headers of PackageFormer declarations.

(defun package-former-name (declaration)
  "Given a declaration of the form
   “PackageFormer Semigroup (v : Variation) : Set where”
   return the name “Semigroup”.
  "
  (s-chop-prefix "PackageFormer "
    (s-chop-suffix " ("
      (car (s-match "PackageFormer .* (" declaration))))
)


(defun variation-symbol (declaration)
  "Given a declaration of the form
   “PackageFormer Semigroup (v : Variation) : Set where”
   return the name “v”.
  "
  (s-chop-prefix "("
    (s-chop-suffix " : Variation)"
      (car (s-match "(.*)" declaration))))
)
#+END_SRC

#+RESULTS:
: variation-symbol

Let's test these two out.
#+BEGIN_SRC emacs-lisp
(package-former-name "PackageFormer Semigroup (v : Variation) : Set where")
;; ⇒ "Semigroup"

(variation-symbol "PackageFormer Semigroup (v : Variation) : Set where")
;; ⇒ "v"
#+END_SRC

#+RESULTS:
: v

* COMMENT Parameter Erasure & Insertion           :possibly_not_needed:
MA: Just change the package-former-variation to package-former-parameter ---which is a pair, “name : type”.
This may make it easier later to transition to having multiple parameters.

When a PackageFormer such as the following is instantiated, say, to a typeclass
variation, we must erase the variation parameter and insert a new type parameter.
#+BEGIN_SRC agda
   PackageFormer Semigroup (v : Variation) : Set where …
↦  record Semigroup (Carrier : Set) : Set  where ⋯
#+END_SRC

#+RESULTS:
: <interactive>:5:1: error: parse error on input ‘↦’

#+BEGIN_SRC emacs-lisp
;; The following only work on headers of PackageFormer declarations.

(defun erase-parameters (declaration)
  "Given a declaration of the form
   “PackageFormer Semigroup (existing-params) : Set ℓ where”
   return
   “PackageFormer Semigroup : Set ℓ where”
  "
  (s-collapse-whitespace ;; Convert all adjacent whitespace chars to a single space.
   (s-replace
      (car (s-match "(.*) : Set" declaration))
      ": Set"
      declaration))
)

(defun insert-parameter (param declaration)
  "Given a declaration of the form
   “PackageFormer Semigroup (existing-params) : Set ℓ where”
   return
   “PackageFormer Semigroup (existing-params) ‘param’ : Set ℓ where”

   Precondition: ‘param’ is a string.
  "
  (let ((rest-of-line (car (s-match ": Set.*" declaration))))
  (s-replace
      rest-of-line
      (concat param " " rest-of-line)
      declaration)
  )
)
#+END_SRC

#+RESULTS:
: insert-parameter

Let's test these out:
#+BEGIN_SRC emacs-lisp :exports both
(erase-parameters "PackageFormer Semigroup (v : Variation) (C : Set) : Set where")
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup : Set where

# Notice the superfluous whitespace is /not/ collapsed for parameter insertion.
#+BEGIN_SRC emacs-lisp :exports both
(insert-parameter "(Carrier : Set)"
  (erase-parameters "PackageFormer Semigroup (v : Variation) : Set where"))
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup (Carrier : Set) : Set where

A naturally expected property is if we obtain the variation symbol of a package former,
erase said parameter, then insert it; then we have essentially done nothing.
#+BEGIN_SRC emacs-lisp :exports both :results replace
(let* ((ex "PackageFormer Semigroup (ww : Variation) : Set where")
       (vd "(%ww : Variation)"))

  (and (equal "PackageFormer Semigroup : Set where" (erase-parameters ex))
       (equal ex (insert-parameter vd (erase-parameters ex))))
)
#+END_SRC

#+RESULTS:
  | nil |

Excellent 😎

* Referencing Text From Code Blocks ---Attaching prose as doc strings :noexport:ignore:

Sources:
+ John Kitchin https://lists.gnu.org/archive/html/emacs-orgmode/2018-05/msg00350.html
+ https://kdr2.com/tech/emacs/1805-approach-org-ref-code-to-text.html

# NAME: get-named-text
#+NAME: commentary
#+BEGIN_SRC emacs-lisp :var name="" :results replace
(let ((el (org-element-map (org-element-parse-buffer) org-element-all-elements
        (lambda (el)
          (when (string= (org-element-property :name el) name)
        el))
        nil t)))
  (let ((s (buffer-substring (org-element-property :contents-begin el)
                 (org-element-property :contents-end el))))
    (replace-regexp-in-string "\\\"" "\\\\\"" s)))
#+END_SRC

** COMMENT Example
For example:
#+NAME: ADD
#+BEGIN_SRC emacs-lisp -n -r :noweb yes :tangle test.el
(defun add (x y)
  "One line description of adding X and Y.
  <<get-named-text("DOC-OF-ADD")>> ;; code to code
  <<get-named-text("add-options")>>"
  (+ x y)
  )
#+END_SRC

#+NAME: DOC-OF-ADD
We use the function add to calculate the sum of two numbers.

#+NAME: add-options
- one
- two
- three
- and of course "optional things"

*** There is a reason we only support two args
    :PROPERTIES:
    :ID:       BAD97113-3561-4A4A-BA07-0CD5BF6BA35F
    :END:

* COMMENT footer

# Local Variables:
# eval: (visual-line-mode t)
# compile-command: (progn (org-babel-tangle) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# End:
