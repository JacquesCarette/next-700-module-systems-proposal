# C-c C-v C-b to execute all code blocks in buffer.

#+TITLE: Package Formers
#+DESCRIPTION: Generalising ADTS, records, typeclasses to “package formers”.
#+AUTHOR: Musa Al-hassy
#+EMAIL: alhassy@gmail.com
#+STARTUP: indent
# PROPERTY: header-args :tangle tangled.agda :comments link

#+CATEGORIES: Agda MetaProgramming Lisp
#+OPTIONS: html-postamble:nil toc:nil d:nil tag:nil
# IMAGE: ../assets/img/org_logo.png
# SOURCE: https://raw.githubusercontent.com/alhassy/org-agda-mode/master/literate.lagda

# INCLUDE: ~/Dropbox/MyUnicodeSymbols.org

* Abstract       :ignore:
#+BEGIN_CENTER org
*Abstract*
#+END_CENTER

Editor extension for supporting “the next 700 module systems”.

Everything here works with Agda version 2.6.0.

#+TOC: headlines 2

* Getting Started

We're going to write a compiler in Lisp that is going to compile
fictitious Agda code ---henceforth referred to as “700 code”---
into currently legitimate Agda code.

For example, something like the following, henceforth referred to as ~test~:
#+NAME:test
#+BEGIN_Example org-agda
PackageFormer Semigroup (v : Variation) : Set where
  field
    _⨾_ : Semigroup v → Semigroup v → Semigroup v
    Id  : Semigroup v
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

SemigroupR = Semigroup record
SemigroupD = Semigroup data
SemigroupT = Semigroup typeclass
#+END_Example
Will behave as if:
#+BEGIN_Example org-agda
record SemigroupR  : Set where
  field
    Carrier : Set
    _⨾_ : Carrier → Carrier → Carrier
    Id  : Carrier
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

data SemigroupD : Set where
    _⨾_ : SemigroupD → SemigroupD → SemigroupD
    Id  : SemigroupD

record SemigroupT (Carrier : Set) : Set where
  field
    _⨾_ : Carrier → Carrier → Carrier
    Id  : Carrier
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
#+END_Example
This is a nearly 200% increase in size; that is, our fictitious code will
save us a lot of repetition.

* Global preconditions
1. All package formers have exactly one explicit ~Variation~ parameter.
2. The ~where~ keyword appears on the same line as the ~PackageFormer~ key-phrase.
3. The name of the PackageFormer should not contain ~PackageFormer~ as a sub-identifier.
4. The first child of the package former is the ~field~ declaration, on its own line.
* Getting indented children

Consider the following todo list,
#+NAME: children-example
#+BEGIN_SRC org
+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 1.2
+ item 3
#+END_SRC

:Example:
#+BEGIN_SRC emacs-lisp :var it = children-example
(message it)
#+END_SRC

#+RESULTS:
: + item 1
:   - subitem 1.1
:     * subsubitem 1.1.1
:   - subitem 1.2
: + item 2
:   - subitem 1.2
: + item 3
:End:

We would think that ~item 1~ has two ‘children’, and, moreover, one grand-child.
Whereas ~item 2~ has a single child and ~item 3~ is barren.

#+BEGIN_SRC emacs-lisp
(defun get-indentation (string)
  "How many spaces are there at the front of ‘string’?

  Property: The resulting number is ‘≤ length string’.
  "
  (if string (length (s-shared-start string (s-repeat (length string) " "))) 0)
)

(stringp "nice")
(stringp '(nice))

(listp "nice")
(listp '(nice))

(cl-defun get-children (parent the-wild &key (then #'identity))
  "Go into ‘the-wild’ seeking out the first occurence of ‘parent’,
   who once found, ought to have a minimal indentation for its children.

   “Minimal” in that if there are items with a greater indentation,
    then they are children of children and should be kept.

   The first input argument is of type ‘string’,
   the second argument may be of type ‘string’ or ‘list’ of strings
   ---if it's a string, we split along new lines---,
   the optional ‘then’ is a function acting on children strings.

   Result is the parent followed by its children, as a list of lines,
   where each child has been altered using the optional ‘then’ function.
   Moreover, we also return the rest of the unconsidered portion of ‘the-wild’:
   Result: ( (cons parent-line children-lines) . unconsidered-remaining-lines )

   Warning: We do /not/ return the unconsidered prefix of ‘the-wild’; i.e,
   the porition that does not contain an occurence of ‘parent’.
   Why? I currently have no need for it, so I throw it away.

   Implementation: Look at the indentation of the
   first child, then use that as a lower bound to find the indentation
   of the remaining children.
  "

  (let ( (lines (if (stringp the-wild) (s-lines the-wild) the-wild))
         (indentation -1)
         (parent-line nil) )
    ;; Ensure: lines ≈ (parent-here . more-lines)
    (while (and (car lines) (not (s-contains? parent (car lines))))
      ;; ‘and’ in-case parent is not even in the list, and so we reach nil.
      (setq lines (cdr lines))
      )

    ;; Throw away parent, but keep its contextual line.
    (setq parent-line (car lines))
    (setq lines (cdr lines))

    ;; How far is the first child indented?
    (setq indentation (get-indentation (car lines)))

    ;; Keep only the children that have at least this level of indentation.
    (setq lines&more (--split-with (<= indentation (get-indentation it)) lines))
    (setq lines (car lines&more))
    (setq unconsidered (cadr lines&more))

    ;; Alter the children according to the given function.
    (setq lines (mapcar then lines))

    ;; Yield the parent line along with the children lines.
    `( ,(cons parent-line lines) . ,unconsidered )
  )
)
#+END_SRC

#+RESULTS:
: get-children

Let's try this out on our example hierarchy, ~eh~, from earlier.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both
(car (get-children "+ item 1" eh))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 |

Excellent! Let's looks at the other parents.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both
(get-children "+ item 2" eh)
#+END_SRC

#+RESULTS:
| (+ item 2   - subitem 1.2) | + item 3 |

Notice that we found the parent ~+ item 2~ and its only child ~- subitem 1.2~, and
we dropped the prefix of ~eh~ that did not contain the parent but have kept
the remaining unconsidered portion of ~eh~.

Finally, the barren parent.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both
(get-children "+ item 3" eh)
#+END_SRC

#+RESULTS:
| + item 3 |

Yay :smile:

Before we move on, let's try altering a child clause; e.g., I'd like
~* subitem 1.1.1~ to be renamed to ~* subitem that is super deep~.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both
(car (get-children "+ item 1" eh
 :then (lambda (x) (s-replace "1.1.1" "that is super deep" x))))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem that is super deep | - subitem 1.2 |

Nice :grin:

Now the moment of truth, let's try this out on our example.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(car (get-children "PackageFormer" test))
#+END_SRC

#+RESULTS:
| PackageFormer Semigroup (v : Variation) : Set where | field | _⨾_ : Semigroup v → Semigroup v → Semigroup v | Id  : Semigroup v | assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z) |

Also, does the list variant work:
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(car (get-children "PackageFormer" (s-lines test)))
#+END_SRC

#+RESULTS:
| PackageFormer Semigroup (v : Variation) : Set where | field | _⨾_ : Semigroup v → Semigroup v → Semigroup v | Id  : Semigroup v | assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z) |

Test-driven development doesn't seem bad 😲

* PackageFormer Name and Variation Symbol

A PackageFormer is generally declared as
#+BEGIN_SRC haskell :tangle no
PackageFormer Semigroup (v : Variation) : Set where …
#+END_SRC

#+RESULTS:
: Prelude>
: <interactive>:2:47-51: error: parse error on input ‘where’

The body of such a declaration mentions ~Semigroup v~, which we would like to rewrite
with other names when the package is instantiated. As such, we form a method for
obtaining the name, the variation symbol, and a method to rewrite substrings of the
children ---wait, we already have the last one: ~get-children~ with optional ~:then~
keyword.

#+BEGIN_SRC emacs-lisp
;; The following two only work on headers of PackageFormer declarations.

(defun package-former-name (declaration)
  "Given a declaration of the form
   “PackageFormer Semigroup (v : Variation) : Set where”
   return the name “Semigroup”.
  "
  (s-chop-prefix "PackageFormer "
    (s-chop-suffix " ("
      (car (s-match "PackageFormer .* (" declaration))))
)


(defun variation-symbol (declaration)
  "Given a declaration of the form
   “PackageFormer Semigroup (v : Variation) : Set where”
   return the name “v”.
  "
  (s-chop-prefix "("
    (s-chop-suffix " : Variation)"
      (car (s-match "(.*)" declaration))))
)
#+END_SRC

#+RESULTS:
: variation-symbol

Let's test these two out.
#+BEGIN_SRC emacs-lisp
(package-former-name "PackageFormer Semigroup (v : Variation) : Set where")
;; ⇒ "Semigroup"

(variation-symbol "PackageFormer Semigroup (v : Variation) : Set where")
;; ⇒ "v"
#+END_SRC

#+RESULTS:
: v

* Parameter Erasure & Insertion

When a PackageFormer such as the following is instantiated, say, to a typeclass
variation, we must erase the variation parameter and insert a new type parameter.
#+BEGIN_SRC haskell :tangle no
   PackageFormer Semigroup (v : Variation) : Set where …
↦  record Semigroup (Carrier : Set) : Set  where ⋯
#+END_SRC

#+RESULTS:
: <interactive>:5:1: error: parse error on input ‘↦’

#+BEGIN_SRC emacs-lisp
;; The following only work on headers of PackageFormer declarations.

(defun erase-parameters (declaration)
  "Given a declaration of the form
   “PackageFormer Semigroup (existing-params) : Set ℓ where”
   return
   “PackageFormer Semigroup : Set ℓ where”
  "
  (s-collapse-whitespace ;; Convert all adjacent whitespace chars to a single space.
   (s-replace
      (car (s-match "(.*) : Set" declaration))
      ": Set"
      declaration))
)

(defun insert-parameter (param declaration)
  "Given a declaration of the form
   “PackageFormer Semigroup (existing-params) : Set ℓ where”
   return
   “PackageFormer Semigroup (existing-params) ‘param’ : Set ℓ where”

   Precondition: ‘param’ is a string.
  "
  (let ((rest-of-line (car (s-match ": Set.*" declaration))))
  (s-replace
      rest-of-line
      (concat param " " rest-of-line)
      declaration)
  )
)
#+END_SRC

#+RESULTS:
: insert-parameter

Let's test these out:
#+BEGIN_SRC emacs-lisp :exports both
(erase-parameters "PackageFormer Semigroup (v : Variation) (C : Set) : Set where")
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup : Set where

# Notice the superfluous whitespace is /not/ collapsed for parameter insertion.
#+BEGIN_SRC emacs-lisp :exports both
(insert-parameter "(Carrier : Set)"
  (erase-parameters "PackageFormer Semigroup (v : Variation) : Set where"))
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup (Carrier : Set) : Set where

A naturally expected property is if we obtain the variation symbol of a package former,
erase said parameter, then insert it; then we have essentially done nothing.
#+BEGIN_SRC emacs-lisp :exports both
(let* ((ex "PackageFormer Semigroup (ww : Variation) : Set where")
       (vs (variation-symbol ex))
       (vd (format "(%s : Variation)" vs)))

  (and (equal "PackageFormer Semigroup : Set where" (erase-parameters ex))
       (equal ex (insert-parameter vd (erase-parameters ex))))
)
#+END_SRC

#+RESULTS:
: t

Excellent 😎

* package-formers list
#+BEGIN_SRC emacs-lisp
;; TODO: The global variables package-formers & instance-declaration should be /buffer/ specfic.

(defvar package-formers nil
  "The list of PackageFormer's declarations in the current Agda buffer.")

(defstruct package-former-declaration
  "Record of componenets that form a PackageFormer."
  name variation-symbol level fields
  )
;; TODO: For now, PackageFormer's have no other parameters besides the variation symbol.

(cl-defmethod show ((p package-former-declaration))
  "Pretty print a package-former-declaration record value"

  (concat
    (format "PackageFormer %s (%s : Variation) : Set %s where \n"
            (package-former-declaration-name p)
              (package-former-declaration-variation-symbol p)
              (package-former-declaration-level p))
    (s-join "\n" (package-former-declaration-fields p))
  )
)

;; nice
;; (show (car package-formers))

(defun load-package-former-declaration (lines)
  "The input ‘lines’ mut be a list of lines forming a full PackageFormer declaration;
   e.g., obtained by calling ‘get-children’.

   It is parsed and added to the list of ‘package-formers’.
  "

  ;; Precondition Example, with intentionally strange whitespacing:
  ;; header ≈ “PackageFormer Semigroup   (v : Variation) : Set  ( ℓexpr)   where”

  (-let [header (car lines)]
    (add-to-list 'package-formers
               (make-package-former-declaration
                   :name             (substring-delimited-$ "PackageFormer $here (" header)
                   :variation-symbol (substring-delimited-$ "($here : Variation"    header)
                     ;; ‘level’ may be “”, that's okay.
                   :level            (substring-delimited-$ "Set $here where"       header)
                   :fields           (cdr lines))) ;; maybe skip line with “fields” header?
  )
)
#+END_SRC

#+RESULTS:
: load-package-former-declaration

testing
#+BEGIN_SRC emacs-lisp :var test = test
(setq package-formers nil)

(load-package-former-declaration
 (car (get-children "PackageFormer" test)))

; test
(substring-delimited-$ "Set $here where" (caar (get-children "PackageFormer" test)))
#+END_SRC

#+RESULTS:

* ~instantiate~ ---the /backend/ core utility
Let's put the pieces together.
#+BEGIN_SRC emacs-lisp
(cl-defun instantiate (decls &key
  new-name (type "record") carrier
  name-suffix
  (variation-replacement "")
  (prefix-fields "") (suffix-fields "") omit-field-header
  (keep-fields (lambda (x) t))
  (alter-raw-fields #'identity)
  (alter-fields #'identity)
  )

  "Given a PackageFormer declaration, instantiate it into a concrete Agda type.

   Remarks or example values:

   - ‘decls’ is immediately provided to ‘get-children’, so it may be a string
      or a list.

   - ‘type’: The replacement for “PackageFormer”; default is “record”.

   - ‘carrier’: What is the carrier of this new instance? E.g., “Carrier”.
      By default it's the ‘new-name’; but this is unresonable when, say, a typeclass
      variation is requested.

   - ‘name-suffix’: When no ‘new-name’ is provided, the default is
      “⟪PackageFormer'sName⟫-⟪variation⟫-g*”, where ‘*’ is an arbitrarily generated number.

     This may be useful for rapid development when one does not want to provide
     a name to an instance, but simply wants the instance to exist.

   - ‘variation-replacement’: “(Carrier : Set)”; empty string by default.

   - ‘prefix-fields’: List of fields, “name : type”, to be added at the beginning
      of the field declaration. Default is empty string.

   - ‘suffix-fields’: List of fields, “name : type”, to be added at the beginning
      of the field declaration. Default is empty string.

   - ‘omit-field-header’: Should the “field” word be removed? No by default.

   - ‘keep-fields’: Predicate that determines which fields should be kept.
      By default, no fields are dropped.

   - ‘alter-raw-fields’: A function that alters the list of fields of a PackageFormer *before*
     any processing has transpiried. This is the identity function by default.

   - ‘alter-fields’: A function to alter existing fields *after* processing;
     it does not alter inserted fields via ‘prefix-fields’ nor ‘suffix-fields’.
     This is the identity function by default.
  "

  (let* ((pf (car (get-children "PackageFormer" decls)))
         (header     (car pf))
         (pf-name (package-former-name header))
         (pf-variation (variation-symbol header))
         (field-decl (cadr pf)) ;; In order to maintain user-provided indentation.
         (fields     (funcall alter-raw-fields (cddr pf)))
         (indentation (s-repeat (if fields (get-indentation (car fields)) 0) " "))
           (preFields   (--map (concat indentation it) prefix-fields))
           (postFields  (--map (concat indentation it) suffix-fields))
         (tc nil)
         )

  ;; Default value of ‘new-name’ & ‘carrier’ are ⟪PackageFormer'sName⟫-⟪name-suffix⟫.
  (unless new-name (setq new-name (format "%s-%s-%s" pf-name name-suffix (gensym))))
  (unless carrier  (setq carrier new-name))

  ;; Replace "(? : Variation)" with the provided ‘variation-replacement’
  (setq header (insert-parameter variation-replacement (erase-parameters header)))

  ;; Replace "PackageFormer" with ‘type’.
  (setq header (s-replace "PackageFormer" type header))

  ;; Replace PackageFormer's name with provided instantiation name.
  (setq header (s-replace pf-name new-name header))

  ;; Replace all occurences of “package-former-name followed by variation”
  ;; with ‘carrier’.
  (setq fields (--map (s-replace (concat pf-name " " pf-variation) carrier it) fields))

  ;; Perform any processing on the fields.
  (setq fields (funcall alter-fields (-filter keep-fields fields)))

  ;; Stick all the pieces together, along with the new fields.
  (setq tc (s-join "\n"
        (-cons* header
        (-concat
           (if omit-field-header () (list field-decl))
           preFields fields  postFields))))

  ;; Declare generation source matter.
  (concat
   "\n{- This was generated from the PackageFormer " pf-name " -}\n"
    tc)
 )
)
#+END_SRC

#+RESULTS:
: instantiate

Let's instantiate our test example from earlier to produce a typeclass.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
                    :name-suffix "typeclass"
                    :type "record"
                    :variation-replacement "(Carrier : Set)"
                    :carrier "Carrier"
                    )
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-typeclass-g105 (Carrier : Set) : Set where
:   field
:     _⨾_ : Carrier → Carrier → Carrier
:     Id  : Carrier
:     assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

#+BEGIN_SRC emacs-lisp :var test = test :exports both
;; (instantiate test)

(setq _test (show (car package-formers)))

(instantiate _test :variation-replacement "noice")

;; (erase-parameters _test)
; (insert-parameter "(nn : ?)" (erase-parameters _test)))

;; (instantiate-as-typeclass (show (car package-formers)))
;; (instantiate (show (car package-formers)))
;; -as-typeclass (show (car package-formers)))
;; (stringp (show (car package-formers)))
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-nil-g106 noice : Set where
:   field
:     _⨾_ : Semigroup-nil-g106 → Semigroup-nil-g106 → Semigroup-nil-g106
:     Id  : Semigroup-nil-g106
:     assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

What about a bundled up record declaration?
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
                    :name-suffix "semantics"
                    :type "record"
                    :carrier "Carrier"
                    :prefix-fields '("Carrier : Set")
                    )
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-semantics-g107  : Set where
:   field
:     Carrier : Set
:     _⨾_ : Carrier → Carrier → Carrier
:     Id  : Carrier
:     assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

Records provide a semantics, what if we want the syntax?
Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

First, a helper function.
#+BEGIN_SRC emacs-lisp
(defun field-target (field)
  " Given a declaration “name : type0 → ⋯ → typeN”, yield “typeN”. "
  (car (-take-last 1 (s-split "→" field)))
)
#+END_SRC

#+RESULTS:
: field-target

Let's test it out:
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (list (s-contains? package-former-name (field-target "     Id  : Semigroup-syntax"))
        (s-contains? package-former-name (field-target "_⨾_ : Semigroup-syntax → Semigroup-syntax → Semigroup-syntax"))
        (s-contains? package-former-name (field-target "     assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)")))
)
#+END_SRC

#+RESULTS:
| t | t | nil |

The results are as expected, so let's move to the real use case.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (instantiate test  :name-suffix "syntax"
                     :type "data"
                     :omit-field-header t
                       :new-name package-former-name
                       ;; :carrier package-former-name
                     :keep-fields (lambda (f) (s-contains? package-former-name (field-target f)))
                    )
)
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: data Semigroup-syntax  : Set where
:     _⨾_ : Semigroup-syntax → Semigroup-syntax → Semigroup-syntax
:     Id  : Semigroup-syntax

Yeehaw! We've got three variations and possibly much more from a single fancy well-toggled
function 🤠 We can emulate generative modules this way too! 😻

Let's package these particular toggle configurations into their own functions.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-typeclass (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda “typeclass”.

   - ‘new-name’ is the name of the resulting instance.
     Default is “⟪PackageFormer'sName⟫-record-g*” for a random sequence of digits ‘*’.

   - ‘carrier’: What is the carrier of this new instance? Default is “Carrier”.

  "
  (instantiate decls :new-name new-name
                     :name-suffix "typeclass"
                     :type "record"
                     :variation-replacement (format "(%s : Set)" carrier)
                     :carrier carrier
                    )
)
#+END_SRC

#+RESULTS:
: instantiate-as-typeclass

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-record (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - ‘new-name’ is the name of the resulting instance.
     Default is “⟪PackageFormer'sName⟫-record-g*” for a random sequence of digits ‘*’.

   - ‘carrier’: What is the carrier of this new instance? Default is “Carrier”.

  "
  (instantiate test :new-name new-name
                    :name-suffix "record"
                    :type "record"
                    :carrier carrier
                    :prefix-fields `(,(format "%s : Set" carrier))
                    )
)

#+END_SRC

#+RESULTS:
: instantiate-as-record

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-data (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - ‘new-name’ is the name of the resulting instance.
     Default is “⟪PackageFormer'sName⟫-record-g*” for a random sequence of digits ‘*’.

   - ‘carrier’: What is the carrier of this new instance? Default is “Carrier”.

  "
  (let* ((pf (car (get-children "PackageFormer" decls)))
         (header     (car pf))
         (pf-name (package-former-name header)))

    (instantiate test  :new-name new-name
                       :name-suffix "syntax"
                       :type "data"
                       :omit-field-header t
                       :keep-fields (lambda (f) (s-contains? pf-name (field-target f)))
                      )
  )
)
#+END_SRC

#+RESULTS:
: instantiate-as-data

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(s-join "\n" `(
,(instantiate-as-typeclass test)
,(instantiate-as-record test)
,(instantiate-as-data test)
))
#+END_SRC

#+RESULTS:
#+begin_example

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-typeclass-g108 (Carrier : Set) : Set where
  field
    _⨾_ : Carrier → Carrier → Carrier
    Id  : Carrier
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-record-g109  : Set where
  field
    Carrier : Set
    _⨾_ : Carrier → Carrier → Carrier
    Id  : Carrier
    assoc : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

{- This was generated from the PackageFormer Semigroup -}
data Semigroup-syntax-g110  : Set where
    _⨾_ : Semigroup-syntax-g110 → Semigroup-syntax-g110 → Semigroup-syntax-g110
    Id  : Semigroup-syntax-g110
#+end_example

Notice that the results contained generated names since no names were provided.

* Acting on Agda Buffer

The aim is to process test enclosed in ~{-700 ⋯ -}~ comments,
produce legitimate Agda from that, and ensure the generated Agda is accessible to the
current buffer automatically.

** TODO substring-delimited and friends
First, the function to get everything in these special “700-comments”.
#+BEGIN_SRC emacs-lisp
(cl-defun buffer-substring-delimited (start end &optional (highlight nil))
  "
  Get the current buffer's /next/ available substring that is delimited
  between the regexp tokens ‘start’ up to ‘end’, exclusively.

  If no tokens are found, an error is thrown.

  The ‘highlight’ option simply highlights the selected region ---visual feedback
  for the user.
  "
  (let (p1 p2)
    (re-search-forward start)
    (setq p1 (point))

    (re-search-forward end)
    (backward-word)
    (setq p2 (point))

    (when highlight ;; do we want to highlight the region?
      (goto-char p1)
      (push-mark p2)
      (setq mark-active t)
    )

    ;; (copy-region-as-kill p1 p2)
    (buffer-substring-no-properties p1 p2)
))
#+END_SRC

#+RESULTS:
: buffer-substring-delimited

Let's obtain the contents of /all/ 700-comments.
#+BEGIN_SRC emacs-lisp
(cl-defun buffer-substring-delimited-whole-buffer (start end)
  "Return a list of all substrings in the current buffer that
   are delimited by regexp tokens ‘start’ and ‘end’, exclusively.
  "
  (save-excursion
    (let ((l nil) (continue t))
     (beginning-of-buffer)

     (while continue
       (condition-case nil
         ;; attemptClause
         (setq l (cons (buffer-substring-delimited start end) l))
         ;; recoveryBody
         (error (setq continue nil))))

     ;; We've collected items as we saw them, so ‘l’ is in reverse.
    (reverse l)
    )
  )
)
#+END_SRC

#+RESULTS:
: buffer-substring-delimited-whole-buffer

#+BEGIN_SRC emacs-lisp
(cl-defun substring-delimited
    (prefix suffix string &key preserve-spaces longest-substring)
  "Assuming ‘string’ ≈ ⋯‘prefix’⟪needle⟫‘suffix’⋯, return the /first/ such needle
   by default, unless ‘longest-substring’ is true, in which case yield /longest/
   such needle.

  Unless ‘preserve-spaces’ is true, we convert all adjacent whitespace
  characters to a single space in the input ‘string’ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (let (longest-needle context first-ending result)

    (unless preserve-spaces (setq string (s-collapse-whitespace string)))
    (setq context (concat prefix ".*" suffix))
    (setq longest-needle (s-chop-prefix prefix
                           (s-chop-suffix suffix
                             (car (s-match context string)))))

    (setq first-ending (s-index-of suffix longest-needle))
    (setq result (if (and (not longest-substring) first-ending)
                       (substring longest-needle 0 (1- first-ending))
                       longest-needle))
    (if preserve-spaces result (s-trim result))
  )
)

(cl-defun substring-delimited-$
    (context string &key preserve-spaces longest-substring)
  "Assuming ‘context’ = “⟪prefix⟫ $here ⟪suffix⟫”
   and ‘string’ ≈ ⋯‘prefix’⟪needle⟫‘suffix’⋯, return the /first/ such needle
   by default, unless ‘longest-substring’ is true, in which case yield /longest/
   such needle.

  Unless ‘preserve-spaces’ is true, we convert all adjacent whitespace
  characters to a single space in the input ‘string’ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (-let [pre-post (s-split "$here" context)]
    (substring-delimited (car pre-post) (s-trim (cadr pre-post)) string
     :preserve-spaces preserve-spaces :longest-substring longest-substring)
  )
)

;; testing
(setq _header "PackageFormer  Semigroup   (  v : Variation) : Set (  ℓexpr)   where")
(substring-delimited "PackageFormer " "(" _header :preserve-spaces t :longest-substring t)
(substring-delimited "PackageFormer " "(" _header :preserve-spaces t)
(substring-delimited "PackageFormer " "(" _header)
(substring-delimited-$ "PackageFormer $here (" _header) ;; nice!
#+END_SRC

#+RESULTS:
: Semigroup

:RndmTests:
#+BEGIN_SRC emacs-lisp :tangle no
;; Get text delimited by quotes
;; (buffer-substring-delimited "^\"" "^\"")

;; Get text delimited by quotes
;; (buffer-substring-delimited "^\{-" "^-\}")

;; (setq it (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}"))
#+END_SRC

#+RESULTS:

:End:
** insert-generated-import
Let's give the current buffer access to the location of the generated file.
#+BEGIN_SRC emacs-lisp
(defun insert-generated-import (name-of-generated-file)
  "In the current file, find the top-most module declaration
   then insert an import of the generated file.
  "
  (interactive)

  (save-excursion
    (beginning-of-buffer)
    (condition-case the-err
      ;; attemptClause
      (re-search-forward (concat "open import " name-of-generated-file))
       ;; recoveryBody
      (error
       ;; (message-box (format "%s" the-err))
         (re-search-forward "\\(module.*\\)")
         (replace-match (concat "\\1\nopen import " name-of-generated-file))
        )
    )
  )
)
#+END_SRC

#+RESULTS:
: insert-generated-import

** instantiations-remaining list
#+BEGIN_SRC emacs-lisp
(defvar instantiations-remaining nil
  "The PackageFormer instantiations that need to be performed.")

(defstruct instance-declaration
  "Record of componenets for an PackageFormer instance declaration:
   ⟪name⟫ = ⟪package-former⟫ ⟪variation⟫.
  "
  name package-former variation
) ;; TODO: Add consideration for ‘renaming’ clauses!
  ;; Need to alter load-instance-declaration and maybe no other methods.

(defun load-instance-declaration (line)
  "If the current ‘line’ string is an instance declaration,
   then parse and add it to the list of ‘instantiations-remaining’;
   else do nothing.

   Returns t if an instance-declaration was loaded, otherwise nil.
  "

  ;; Example instance declaration: “MagmaR = Magma record”
  ;; ⇒ 4 pieces, sepearted by spaces, where second item must be an equality.

  (let ( (pieces (s-split " " line)) )
   (when (and (<= 4 (length pieces)) (equal (nth 1 pieces) "="))
     (add-to-list 'instantiations-remaining
                  (make-instance-declaration :name           (nth 0 pieces)
                                             :package-former (nth 2 pieces)
                                             :variation      (nth 3 pieces)
                                             ))
     t ;; Indicate that an instance was loaded.
   )
  )
)
#+END_SRC

#+RESULTS:
: load-instance-declaration

** parse-700-comments
#+BEGIN_SRC emacs-lisp
(defvar 700-comments nil
  "The contents of the 700-comments.

   If this variable does not change, we short-circut all processing.
  ") ;; TODO

(cl-defun parse-700-comments ()
  "
   Parse comments of the form “{-700 ⋯ -}” and add all PackageFormer declarations
   to the ‘package-formers’ list and all instantations to the ‘instantiations-remaining’ list.
  "
  (interactive)

  (let (item lines) ;; ‘item’ is either a PackageFormer or instantiation declaration.

  ;; Step 0: Catenate all 700-comments into a single string.
  (setq 700-comments (s-join "\n" (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}")))
  ;; TODO: Assign to a local var, check equality against global 700-comments,
  ;; if identical, no more processing since everything already generated.

  ;; View comments as a sequence of lines, ignore empty lines ---which are not in our grammar.
  (setq lines (--remove (s-blank? (s-collapse-whitespace it)) (s-lines 700-comments)))

  ;; Traverse the 700-comments:
  ;; If we view a “lhs = rhs” equation, add to global ‘instantiations-remaining’ list.
  ;; If we view a PackageFormer declaration, add to global ‘package-formers’ list.
  (while lines
   (setq item (car lines))
   (if (load-instance-declaration item) (setq lines (cdr lines))
     ;; Else we have a PackageFormer declaration:
     ;; Get it along with the remaining 700-comments.
     (setq item (get-children "PackageFormer" lines))
     (load-package-former-declaration (car item))
     (setq lines (cdr item))))

  (message "Finished parsing 700-comments.")
  )
)
#+END_SRC

#+RESULTS:
: parse-700-comments

* Now for the /frontend/ core utility

#+BEGIN_SRC emacs-lisp
(cl-defun reify-instances ()
 " Instantiate all items in ‘instantiations-remaining’.
 "
 (interactive)
 (let* (result name pf-type pf variation reify)

   (dolist (inst instantiations-remaining)
        (setq name (instance-declaration-name inst))
          (setq variation (instance-declaration-variation inst))
        (setq pf-type (instance-declaration-package-former inst))
        (setq pf (car (--filter (equal pf-type (package-former-declaration-name it)) package-formers)))
        (setq reify (pcase (instance-declaration-variation inst)
                      ("typeclass" (instantiate-as-typeclass (show pf) :new-name name))
                      ("record" (instantiate-as-record (show pf) :new-name name))
                      ("data" (instantiate-as-data (show pf) :new-name name))
                    (otherwise  (message-box "Error: Variation %s not supported yet." variation))
              ))
        (setq result (-cons* reify result)))

   (s-join "\n" result)
))

(global-set-key (kbd "<f7>") 'reify-instances)
#+END_SRC

#+RESULTS:
: reify-instances

#+BEGIN_SRC emacs-lisp
(defun reify-package-formers (orig-fun &rest args)
  (interactive)

  ;; Sometimes we may want the full name due to files being in a nested
  ;; directory hierarchy:
  ;; (file-name-sans-extension buffer-file-name)
  (setq generated-file-name (concat(file-name-sans-extension (buffer-name))
                  "_Generated"))

  ;; This’ inefficent.
  (setq package-formers nil)
  (setq instantiations-remaining nil)
  (parse-700-comments)

  (with-temp-buffer
    (beginning-of-buffer)

    (insert (s-join "\n" `(
             "{- This file is generated ;; do not alter. -}"
             "open import Relation.Binary.PropositionalEquality using (_≡_)"
               "open import Level as ℓ"
             ,(format "module %s where " generated-file-name)
             ,(reify-instances))))

    ;; (mark-whole-buffer)
    (write-region (beginning-of-buffer) (end-of-buffer)
                  (concat generated-file-name ".agda"))
    )
    ;; MA: Using ‘(write-file "Generated.agda")’ means we make a file
    ;; then the temporary buffer /vistis/ the agda file, which loads the
    ;; agda process therein, which is undesirable since it could leave
    ;; agda working on the buffer even after it has been killed!
    ;; This would necessiate calling (agda2-restart) afterwards.
    ;;
    ;; Instead we write the whole region, without visiting the resuting file.

  (insert-generated-import generated-file-name)
  ;; call agda2-load
  (apply orig-fun args)
  (message "700 ∷ All the best coding! (•̀ᴗ•́)و")
)

(advice-add 'agda2-load :around #'reify-package-formers)
#+END_SRC

#+RESULTS:

* TODO Minor mode ---Menu matter
#+BEGIN_SRC emacs-lisp

(defvar 700-menu-bar-menu (make-sparse-keymap "700 PackageFormers"))
(define-key global-map [menu-bar my-menu] (cons "700PackageFormers" 700-menu-bar-menu))

(defun enable-package-formers ()
 (interactive)
 (advice-add 'agda2-load :around #'reify-package-formers)
 ;; place notification in modeline
 (setq global-mode-string
      (cond ((consp global-mode-string)
             (add-to-list 'global-mode-string "700 (•̀ᴗ•́)و"))
            ((not global-mode-string)
             (list "700 (•̀ᴗ•́)و"))
            ((stringp global-mode-string)
             (list "700 (•̀ᴗ•́)و" global-mode-string))))
)

(defun disable-package-formers ()
 (interactive)
 (advice-remove 'agda2-load #'reify-package-formers)
 (setq global-mode-string (remove "700 (•̀ᴗ•́)و" global-mode-string))
)

(define-key 700-menu-bar-menu [enable-package-formers]
  '(menu-item "Enable PackageFormer Generation" enable-package-formers))

(define-key 700-menu-bar-menu [disable-package-formers]
  '(menu-item "Disable PackageFormer Generation" disable-package-formers))
#+END_SRC

#+RESULTS:
| menu-item | Disable PackageFormer Generation | disable-package-formers |

* TODO missing features
+ [A] Generated.agda needs to inherit all open/import declarations from parent.
+ [A] Lifting a field to the parameter level.
  - [A] “pf typeclass lifting N” lifts the first N fields to the parameter level.
+ [A] Explain how generative modules can be emulated.
+ [B] Renaming?

  #+BEGIN_SRC emacs-lisp
(defun generate-all-instances () ;; TODO
  "For each PackageFormer ‘pf’, produce the default instances:
   ‘pf-record’, ‘pf-typeclass’, ‘pf-data’.

   Use: You want a particular instance in rapid developement and don't want
   to be bothered to give it a name. Or experimenting and unsure which instance
   is most desirable, so have access to all of them.

   Possible extensions:
   0. Introduce concrete syntax “GenerateDefaultInstances pf” to invoke this command.
   1. Have a global list of default instances.
  "

  (interactive)

    ;; Keep this around since we may want to produce variations wholesale with
  ;; names: packageformer-variation; e.g., Magma-typeclass.
  ;;
  ;;
  ;; the variations
;;  (setq the-vars-shush (--map (car it) (--map (-take-last 1 it) (--map (s-split " " it) decls-vars-shush))))
  ;;
  ;; (dolist (variation the-vars-shush ll)
  ;;  (setq ll (cons (make-typeclass decls (concat pf-name "-" variation)) ll)))

  )
#+END_SRC

#+RESULTS:
: generate-all-instances


* COMMENT footer

# Local Variables:
# eval: (load-file "~/org-agda-mode/org-agda-mode.el")
# eval: (visual-line-mode t)
# compile-command: (progn (org-babel-tangle) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# End:
