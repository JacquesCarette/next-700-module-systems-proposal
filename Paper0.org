#+TITLE: A Language Feature to Unbundle Data at Will
#+subtitle: ---Draft ;; Work in progress---
#+DESCRIPTION: Thesis proposal for Musa Al-hassy; McMaster University 2019.
#+AUTHOR: Musa Al-hassy, Jacques Carette, Wolfram Kahl
#+EMAIL: alhassy@gmail.com
#+OPTIONS: toc:nil d:nil title:t
#+PROPERTY: header-args :tangle no :comments link
#+TODO: TODO | OLD LaTeX README Remarks

* Remarks COMMENT on writing
# At the end of a section, explain why the section is there,
# and what the reader should take away from it.

# MA: LaTeX pads colons, :, with spacing.
# For inline typing annotations, use ghost colon ‚Äú\:‚Äù to avoid this issue.

# Drop the 'proposed'. Use positive, active language like

# YS.
# Maybe start with asking what is the message you want to deliver in this paper? What kind of
# bundling is bad and why is it so?

# (add-to-list 'org-latex-text-markup-alist '(code . verb))
# (add-to-list 'org-latex-text-markup-alist '(verbatim . verb))

:WK_Tips:

‚óà Re: abstract:
Paragraph 1: Background and identified problem
Paragraph 2: Contribution

‚óà After code blocks, and especially before one-line paragraphs between
code blocks, always put \noindent unless there is a strong reason not to.
Also consider doubling the code block indentation.

‚óà  PacakageFormer --> \textsf{\upshape PackageFormer}
    [Code is ALWAYS typeset as code,
     just like math is always typeset as math.]

:End:
:JC_Remarks:
‚óÜ Consider Finite State Machines, rather than graphs, so as to have a multi-sorted
  structure where the sorts do not ‚Äòdepend‚Äô on each other.

- The introduction needs to cover the *problem* that is being solved - and not the solution; that is not 100% clear below
- You need to save space for related work (can be a short paragraph, but without it, it'll get rejected)
- Where are the citations? There should be citations throughout!
:End:

* README COMMENT Dependencies of this org file

In the source blocks below, go into each one and press C-c C-c
to have it executed. Some ‚Äòresults‚Äô will be echoed into the buffer
if everything went well.

Rather than executing the following blocks each time you edit this file,
consider adding them to your Emacs [[https://alhassy.github.io/init/][configuration file]].

 + org-mode :: This particular markup is called org-mode.

     Let's obtain Org-mode along with the extras that allow us to ignore
     heading names, but still utilise their contents --e.g., such as a heading
     named ‚Äòpreamble‚Äô that contains org-mode setup for a file.
     #+begin_src emacs-lisp
;; first we get a handy-dandy package manager

(require 'package)
(setq package-archives '(("org"       . "https://orgmode.org/elpa/")
                         ("gnu"       . "https://elpa.gnu.org/packages/")
                         ("melpa"     . "https://melpa.org/packages/")
                         ("melpa-stable" . "https://stable.melpa.org/packages/")
                         ))
(package-initialize)

(package-refresh-contents)

(package-install 'use-package)
(require 'use-package)
(setq use-package-always-ensure t)

;; then we get the org-mode goodness

(use-package org
  :ensure org-plus-contrib
  :config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines)))
#+end_src

     This lets us use the ~:ignore:~ tag on headlines you'd like to have ignored,
     while not ignoring their content --see [[https://emacs.stackexchange.com/a/17677/10352][here]].

     - Use the ~:noexport:~ tag to omit a headline /and/ its contents.

 + minted & bib :: Source blocks obtain colour.

     Execute the following for bib ref as well as minted
     Org-mode uses the Minted package for source code highlighting in PDF/LaTeX
     --which in turn requires the pygmentize system tool.
     #+BEGIN_SRC emacs-lisp
     (setq org-latex-listings 'minted
           org-latex-packages-alist '(("" "minted"))
           org-latex-pdf-process
           '("pdflatex -shell-escape -output-directory %o %f"
             ;; "biber %b"
             "bibtex %b"
             "pdflatex -shell-escape -output-directory %o %f"
             "pdflatex -shell-escape -output-directory %o %f")
     )
     #+END_SRC

  # Enable the following to have small-font code blocks.
  # LATEX_HEADER: \RequirePackage{fancyvrb}
  # LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}

 + amart :: Enable acmart latex class.

   #+NAME: make-acmart-class
   #+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("acmart" "\\documentclass{acmart}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

 (message "acmart has been loaded")
 #+END_SRC

 #+RESULTS: make-acmart-class
 : acmart has been loaded

   The ‚Äòfooter‚Äô at the end of this file currently executes only this code block for you
   ---if you enable the local vars. You can easily tweak it to execute the other blocks,
   if you like.

 + org-ref :: [[https://github.com/jkitchin/org-ref][An exquisite system]] for handling references.

    If everything works, the following entity will display useful data
    when the mouse hovers over it (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà If you click on it, then you're
    in for a lot of super neat stuff, such as searching for the pdf online!

    cite:agda_overview

    #+BEGIN_SRC emacs-lisp
(use-package org-ref :demand t)

;; Files to look at when no ‚Äú‚ï≤bibliography{‚ãØ}‚Äù is not present in a file.
;; Most useful for non-LaTeX files.
(setq reftex-default-bibliography '("References.bib"))

(use-package helm-bibtex :demand t)
;; If you use helm-bibtex as the citation key completion method you should set these variables too.

(setq bibtex-completion-bibliography "References.bib")
#+END_SRC

  Execute ~M-x helm-bibtex~ and, say, enter ~agda~ and you will be presented with
  all the entries in the bib database that mention ‚Äòagda‚Äô. Super cool stuff.

* LaTeX setup                                                        :ignore:

  #+LATEX_CLASS: acmart
  #+latex_class_options: [sigplan,review,anonymous]
  # latex_class_options: [acmsmall,review,anonymous]

  # ACM uses the natbib package
  #
  # LATEX_HEADER: \settopmatter{printfolios=true,printccs=false,printacmref=false}

  # Visible editorial comments.
  #+LATEX_HEADER: \usepackage{edcomms}
  #+LATEX_HEADER: \edcommsfalse

  #+LATEX_HEADER: \acmYear{2019}
  #+LATEX_HEADER: \setcopyright{none}
  # LATEX_HEADER: \acmJournal{GPCE}
  # LATEX_HEADER: \acmVolume{1}
  # LATEX_HEADER: \acmNumber{GPCE}
  # LATEX_HEADER: \acmArticle{1}
  # LATEX_HEADER: \acmMonth{1}
  # LATEX_HEADER: \acmDOI{}

  # Dark green colour for links.
  #+LATEX_HEADER: \usepackage{color}
  #+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
  #+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkgreen,citecolor=darkgreen,urlcolor=darkgreen}

  #+LATEX_HEADER: \usepackage{CheatSheet/UnicodeSymbols}

  #+LATEX_HEADER: \DeclareMathOperator{\VCCompose}{\longrightarrow\hspace{-3ex}\oplus\;}
  #+LATEX_HEADER: \newunicodechar{‚ü¥}{\ensuremath{\VCCompose}}
  #+LATEX_HEADER: \newunicodechar{ùìã}{\ensuremath{v}}

* Abstract :ignore:
#+begin_center
*Abstract*
#+end_center
#+begin_small

  # The eager commit to what data should be a type parameter or a record component
  # is a premature design decision. We demonstrate a language feature that circumvents
  # such over-specification.
  #
  # WK:  That's quite a mouthful and hard to parse. Perhaps establish some context first?

  # This is analogous to
  # which information is exposed dynamically at runtime and which is known statically,
  # respectively.

  Programming languages with sufficiently expressive type theories provide users with
  different means of data ‚Äòbundling‚Äô. Specifically one can choose to encode information
  in a record either as a parameter or a field, in dependently-typed languages such as
  Agda, Coq, Lean and Idris.
  For example, we can speak of graphs /over/ a particular vertex set, or speak
  of arbitrary graphs where the vertex set is a component.
  These create isomorphic types, but differ with respect to intended use.
  Traditionally, a library designer would make this choice (between parameters and fields);
  if a user wants a different variant, they are forced to build conversion utilities as well as
  duplicate functionality. For a graph data type,
  if a library only provides a Haskell-like typeclass view of graphs /over/ a vertex set,
  yet a user wishes to work with the category of graphs, they must now package a vertex
  set as a component in a record along with a graph over that set.

  We design and implement a language feature that allows both the library designer and
  the user to make the choice of information exposure only when necessary, and otherwise leave
  the distinguishing line between parameters and fields unspecified.
  Our language feature is currently implemented as a prototype meta-program
  incorporated into Agda's Emacs ecosystem, in a way that is unobtrusive to Agda users.
#+end_small

* Introduction --- Selecting the ‚Äòright‚Äô perspective

  :Ideas:
  Which perspective of semigroups does one select? Semigroupùíæ from the thesis proposal;
     the perspective considered should have legitimate uses rather than artificial ones.
     How do we write, e.g., ‚Äòconcat‚Äô in the various forms. What is the minimal reduplication required using
     existing techniques.
   :End:

  Library designers want to produce software components that are useful for
  the perceived needs of a variety of users and usage scenarios.  It is therefore
  natural for designers to aim for a high-level of generality, in the hopes of increased
  reusability. One such particular ``choice'' will occupy us here: When creating a
  record to bundle up certain information that ``naturally'' belongs together, what
  parts of that record should be /parameters/ and what parts should be
  /fields/? This is analogous to whether functions are curried and so arguments
  may be provided partially, or otherwise must be provided all-together in one tuple.

  The subtlety of what is a ‚Äòparameter‚Äô --- exposed at the type level --- and what is a
  ‚Äòfield‚Äô --- a component value --- has led to awkward formulations and
  the duplication of existing types for the sole purpose of different uses.

  :JC:
  \edcomm{JC}{Incorporate a little bit of the text of Tom Hales' critique of
  Lean, verbation and cite, here}

  MA: If you mean [[https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/][this review]], then you likely mean item 4 regarding the issues
  of Lean being its own metalanguage. However, this appears to be problematic
  due to limited man-power working on Lean: ‚Äúthe tools simply are not available‚Äù.
  Item 7 regarding ugly projection chains has already been addressed below, briefly,
  when mentioning flattening. Re item 9, Agda allows [simulated] diamonds.
  Re item 10, that's what's being addressed in this work.
  :End:

  # For example, the ubiquitous monoid, used to model compositionality,
  # in Haskell, is only allowed one instance per datatype. However, the Booleans,
  # for example, support multiple monoid instances such as sequential and parallel monoids
  # ---the former being conjunction with
  # identity /true/ and the latter being disjunction with identity /false/.
  For example, each Haskell typeclass can have only one instance per datatype;
  since there are several monoids with the datatype ~Bool~ as carrier,
  in particular those induced by conjunction and disjunction,
  the de-facto-standard libraries for Haskell
  define two isomorphic copies ~All~ and ~Any~ of ~Bool~,
  only for the purpose of being able to attach the respective monoid instances to them.

  But perhaps Haskell's type system does not give the programmer sufficient
  tools to adequately express such ideas. As such, for the rest of this paper
  we will illustrate our ideas in Agda cite:Norell-2007,agda_overview.
  For the monoid example,
  it seems that there are three contenders for the monoid interface:

  \newpage
  #+begin_src agda
  record Monoid‚ÇÄ : Set‚ÇÅ where
    field
      Carrier : Set
      _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
      Id      : Carrier
      assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
      leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
      rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x

  record Monoid‚ÇÅ (Carrier : Set) : Set where
    field
      _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
      Id      : Carrier
      assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
      leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
      rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x

  record Monoid‚ÇÇ
           (Carrier : Set)
           (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier)
         : Set  where
    field
      Id      : Carrier
      assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
      leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
      rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x
  #+end_src

  \vspace{0.3em}\noindent
  In ~Monoid‚ÇÄ~, we will call ~Carrier~ ``bundled up'',
  while we call it ``exposed'' in ~Monoid‚ÇÅ~ and ~Monoid‚ÇÇ~.
  The bundled-up version allows us to speak of /a/
  monoid, rather than /a monoid on a given type/ which is captured by ~Monoid‚ÇÅ~.
  While ~Monoid‚ÇÇ~ exposes both the carrier and the composition operation,
  we might in some situation be interested
  in exposing the identity element instead
  --- e.g., the discrepancy ‚Äò‚â¢‚Äô and indistinguishability ‚Äò‚â°‚Äô operations
  on the Booleans
  have the same identities as conjunction and disjunction, respectively.
  Moreover, there are other combinations of what is to be exposed and hidden,
  for applications that we might never think of.

  Rather than code with /interface formulations we think people will likely use/, it is far
  more general to /commit to no particular formulation/ and allow the user to select
  the form most convenient for their use-cases. This desire for reusability motivates
  a new language feature: The \textsf{\upshape PackageFormer}.

  Moreover, it is often the case that one begins working with a record of useful
  semantic data, but then, say, for proof automation, may want to use the associated
  datatype for syntax. For example, the syntax of closed monoid terms is formalised as follows.
  #+begin_src agda
    data Monoid‚ÇÉ : Set where
      _‚®æ_ : Monoid‚ÇÉ ‚Üí Monoid‚ÇÉ ‚Üí Monoid‚ÇÉ
      Id  : Monoid‚ÇÉ
  #+end_src
  \noindent
  We can see that this version can also be
  mechanically obtained from ~Monoid‚ÇÄ~ by discarding ‚Äònon-simple‚Äô
  fields then turning the remaining fields into constructors.
  # That would necessitate yet another nearly identical data-structure
  # --- having constructors rather than field projections.

  We show how all these different
  presentations can be derived from a /single/
  \textsf{\upshape PackageFormer} declaration
  via a generative meta-program integrated into the
  most widely used Agda ``IDE'', the Emacs mode for Agda.
  In particular, a package of $N$ constituents with $M$
  presentations of bundling results in nearly $N √ó M$ lines of code,
  yet this quadratic count becomes linear $N + M$ by having a single
  package declaration of $N$ constituents with $M$ subsequent instantiations.
  It is this massive reduction in duplicated efforts and maintenance that we view
  as the main contribution of our work.

  :Remarks:
  To demonstrate the generality of the notion of package formers we shall demonstrate how other common forms could be ‚Äòderived‚Äô from the single declaration above. It is to be noted that for such a small example, such derived code may be taken for granted, however for much larger theories ‚Äîfor example, a ‚Äúfield‚Äù comes with more than 20 fields‚Äî the ability to derive different perspectives in a consistent fashion is indispens- able; especially when the package is refactored. More realistically, a symmetric rig groupoid uses about 212 coherence laws [rig_computation], for which case-splitting, to perform proofs, yields over 200 goals thereby making metaprogramming a tempting approach.
  :End:

* TODO \textsf{\upshape PackageFormer}s --- Being non-committal as much as possible :outdated:
  :Remarks:
  Unifying the different perspectives under the same banner. We speak in terms of elaborations,
     but may propose elementary typing rules or semantics. Discuss \textsf{\upshape PackageFormer} polymorphism, from ¬ß4 of thesis proposal.
     :End:

    # It is notoriously difficult to reconstruct the possible inputs to a function
    # that yielded a certain output.
    # That is, unless you are using Prolog of-course,
    # where the distinctions between input and output are an illusion
    # that is otherwise
    # made real only by how Prolog users treat arguments to a relation.
    # Dependently-typed programming at its core is the adamant hygienic blurring of
    # concepts
    # --- namely, types are terms \cite{types_overview} ---
    # and so the previous presentations of monoids are unified in the following
    # single declaration which does not distinguish between parameters and fields.
    #
    We claim that the previous monoid-related pieces of Agda code
    can all be unified as a single declaration
    which does not distinguish between parameters and fields,
    where ~PackageFormer~ is a keyword with similar syntax as ~record~:

      #+begin_src agda
  PackageFormer MonoidP : Set‚ÇÅ where
    Carrier : Set
     _‚®æ_    : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x
  #+end_src

  \noindent
  Coupled with various `directives' that let one declare
  what should be parameters and what should be fields,
  we can reproduce the above.
  Notice that here ~Carrier~ has been removed in favour of the name MonoidP,
  which also is the name of the newly declared entity.
  This does indeed mean that so far our facility is /single sorted/.
  # # Superficially, the parameters and fields have been flattened into a single location
  # # and the name ~Carrier~ has been dispensed with in-favour of ~MonoidP~,
  # # which also happens to be name of this newly declared entity.
  #
  # MA: We commend the astute reader who has noticed a hint of predicitivity here,
  # but it is an issue we shall not address in the current work.
  #
  # WK: No, as a matter of courtesy.

  # #+BEGIN_EXPORT latex
  # \emph{One uses a \textsf{\upshape PackageFormer} by instantiating the particular presentation that is desired.}
  # #+END_EXPORT

  A package former is used via /instantiations/, written as low-precedence
 juxtapositions of a package former name and and expression of type
 ~Variation~.
 # WK: I currently think that ``Variation'' is not a good name for this type.
 The latter can be built in particular via the following:
    #+begin_src agda
id          :  Variational
record      :  Variational
typeclass   :  Variational
termtype    :  Variational
unbundled   :  ‚Ñï ‚Üí Variational
exposing    :  List Name ‚Üí Variational
_‚ü¥_        :  Variational ‚Üí Variational ‚Üí Variational
#+end_src
#                           -- Syntax as for using
# # JC proposes ~termlanguage~ for ~termtype~
\noindent
 The variationals ~unbundled~ and ~exposing~ have arguments.
 While\linebreak ~exposing~ explicitly lists the names that should be turned
 into parameters, in that sequence, `` ~unbundled~ $n$'' exposes the
 first $n$ names declared in the package former.

 An instantiation juxtaposition is written ~PF ùìã~ to indicate that the PackageFormer
 named ~PF~ is to be restructred according to scheme ~ùìã~. A /composition/ of variationals
 is denoted using the symbol ‚Äò‚ü¥‚Äô; for example,
 ~PF ùìã‚ÇÅ ‚ü¥ ùìã‚ÇÇ ‚ü¥ ‚ãØ ‚ü¥ ùìã‚Çô~ denotes the forward-composition of iterated instantiations,
 namely\linebreak ((~(PF ùìã‚ÇÅ) ùìã‚ÇÇ) ‚ãØ) ùìã‚Çô~,  since we take prefix instantiation application
to have lower precedence that variational composition.
 In particular, an empty composition is the identity
 scheme, which performs no alteration, and has the explicit name ~id~.
 \linebreak
 Since ~PF id ‚âà PF~ and ~id~ is the identity of composition, we may
 write any /instantion/ as a sequence of ‚ü¥-sepearted clauses:
~PF ‚ü¥ ùìã‚ÇÅ ‚ü¥ ùìã‚ÇÇ ‚ü¥ ‚ãØ ‚ü¥ ùìã‚Çô~ ---which is equivalent to \linebreak
~PF ((((id ‚ü¥ ùìã‚ÇÅ) ‚ü¥ ùìã‚ÇÇ) ‚ãØ )‚ü¥ ùìã‚Çô)~.

  # #
  # # We conceive of an extensible type ~Variations~
  # # which includes ~termtype~ and ~record~
  # # as two keywords. Moreover, this type is equipped with a number of combinators, one
  # # of which is the infix operator ~_unbundled_ : Variation ‚Üí ‚Ñï ‚Üí Variation~ which modifies a particular
  # # presentation by also lifting the first ~n~ constituents from the field level to the
  # # parameter level. In particular, ~typeclass = record unbundled 1~.
  # # We also allow the named version of this combinator, namely
  # # ~_exposing_ : Variation ‚Üí List Name ‚Üí Variation~.
  # # Instantiation syntax is of the form ~‚Äú‚ü™package-former-name‚ü´ ‚ü™variation‚ü´‚Äù~,
  # # as such, ~_unbundled_~  and ~_exposing_~ have higher precedence.
  # # Let us demonstrate these concepts.

  0. [@0] To make ~Monoid‚ÇÄ'~ the type of /arbitrary monoids/
   (that is, with arbitrary carrier), we declare:
        \vspace{0.3em}
   #+begin_src agda
 Monoid‚ÇÄ'  = MonoidP record
#+end_src

  1. [@1] We may obtain the previous formulation of
     ~Monoid‚ÇÅ~ as follows:
        \vspace{0.3em}
   # # -- WK: typeclass was not shown
   # # Monoid‚ÇÅ‚Ä≤  = MonoidP typeclass
   # # Monoid‚ÇÅ‚Ä≥ = MonoidP record exposing (Carrier)
   #+begin_src agda
 Monoid‚ÇÅ'  = MonoidP record ‚ü¥ exposing (Carrier)
 Monoid‚ÇÅ‚Ä≥ = MonoidP record ‚ü¥ unbundled 1
#+end_src
# ##  This also
# ##  Haskell2010-style (single-parameter) type classes then correspond to
# ##  ~_unbundled 1, and so we define
# ##    #+begin_src agda
# ##  MonmoidClass = MonoidP typeclass unbundled 1
# ## #+end_src
# ## WK: ?

# #    \vspace{0.3em}

  2. [@2] As for ~Monoid‚ÇÅ~, there are also different ways
     to regain the previous formulation of ~Monoid‚ÇÇ~.
        \vspace{0.3em}
    #+begin_src agda
 Monoid‚ÇÇ‚Ä≤  = MonoidP record ‚ü¥ unbundled 2
 Monoid‚ÇÇ‚Ä≥ = MonoidP
              record ‚ü¥ exposing (Carrier; _‚®æ_)
#+end_src

      \vspace{0.3em}

# # Our precedence rules indicate that ~MonoidP ‚ãØ~ parenthesises
# # as if it were ~MonoidP (‚ãØ)~.
# # Moreover, notice that the infix combinators for unbundling and exposing,
# # behave similar to the curry functional $(A √ó B ‚Üí C) \;‚Üí\; (A ‚Üí B ‚Üí C)$.
# #
# #   2. [@2] To speak of /a monoid over an arbitrary carrier/, we declare:
# #         \vspace{0.3em}
# #    #+begin_src agda
# #  Monoid‚ÇÉ = MonoidP record
# # #+end_src
# #    \vspace{0.3em}
# #    \noindent
# #    It behaves as if it were declared thusly:
# #    \vspace{0.3em}
# #    \noindent
# #    #+begin_src agda
# #     record Monoid‚ÇÉ : Set‚ÇÅ where
# #       field
# #         Carrier : Set
# #         _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
# #         Id      : Carrier
# #         ‚ãØ
# # #+end_src
# #
# #   The name ~Carrier~ is a default and could be renamed; likewise for ~Vars~ below.

  3. [@3] Finally, we mentioned metaprogramming's need to work with terms:
        \vspace{0.3em}
    #+begin_src agda
 Monoid‚ÇÉ‚Ä≤ = MonoidP termtype
#+end_src
    \vspace{0.3em}
   \noindent
   Of course we may want to have terms /over/ a particular variable set, and so declare:
      \vspace{0.3em}
     #+begin_src agda
 Monoid‚ÇÑ = MonoidP termtype ‚ü¥ renaming (Carrier to Vars) ‚ü¥ exposing (Vars)
#+end_src
    \vspace{0.3em}
    \noindent
    Since the name ~Vars~ does not occur in the ~MonoidP~ package former,
    and is different from the special name ~Carrier~,
    it is added as a ~Set~ parameter together with an injection
    into the created datatype ~Monoid‚ÇÑ~,
    which could equivalently be defined as follows:
       \vspace{0.3em}
       \noindent
    #+begin_src agda
    data Monoid‚ÇÑ (Vars : Set) : Set where
      inj : Vars ‚Üí Monoid‚ÇÑ Vars
      _‚®æ_  : Monoid‚ÇÑ Vars
           ‚Üí Monoid‚ÇÑ Vars ‚Üí Monoid‚ÇÑ Vars
      Id  : Monoid‚ÇÑ Vars
  #+end_src

     \vspace{0.3em}
     \noindent
     Note that only ‚Äòfunctional‚Äô symbols have been exposed in these
     instantiations;
     no ‚Äòproof-matter‚Äô.

# ##  WK: Try it:
# ##       #+begin_src agda
# ##   MonoidTermPropEqu = MonoidP equality where termtype = Monoid‚ÇÖ
# ##  #+end_src
# ##
# ##      #+begin_src agda
# ##      data MonoidTermPropEqu (Vars : Set) : Set where
# ##        eqVars : {v w : Vars}  ‚Üí v ‚â° w ‚Üí inj v ‚â° inj w
# ##        ...
# ##    #+end_src
# ##
# ##       #+begin_src agda
# ##   MonoidTermSetoid = MonoidP termSetoid where termtype = Monoid‚ÇÖ
# ##  #+end_src
# ##
# ##      #+begin_src agda
# ##      module _ {v e : Level} (Vars : Setoid v e) where
# ##        open SetoidV Vars
# ##        data _‚âàT_ : Monoid‚ÇÖ CarrierV ‚Üí Monoid‚ÇÖ CarrierV  ‚Üí Set (v \sqcup e) where
# ##          eqVars : {v w : Vars}  ‚Üí v ‚âàV w ‚Üí inj v ‚âàT inj w
# ##          ...
# ##        MonoidTermSetoid : Setoid v e
# ##        MonoidTermSetoid = record { ... }
# ##    #+end_src
# ##

# #  There are of-course a number of variations on how a package is to be presented;
# #  we have only mentioned two for brevity. The interested reader may consult
# #  the ‚Äònext 700 module systems‚Äô proposal \cite{alhassy_thesis_proposal};
# #  which discusses more variations and examples in detail.
  #+begin_export latex
  \edcomm{JC}{I would
instead, especially as you have the room, insert a paragraph naming the
additional things that can be done.}
#+end_export

  For brevity we have only discussed product representations of packages, however
  the language feature also supports elaborations into nested dependent-sums
  as in the case where we may have a coherent substructure.
  Alongside ~_unbundled_~, we also have infix combinators for extending an
  instantiation with additional fields or constructors, and the renaming of constituents
  according to a user provided String-to-String function.
  Moreover, just as syntactic datatype declarations may be derived, we also
  allow support for the derivation of induction principles and structure-preserving homomorphism types.
  Our envisioned system would be able to derive simple, tedious, uninteresting concepts; leaving difficult,
  interesting, ones for humans to solve.

  :Remarks:
  0. Besides syntax, induction principles are also derived:

  2. The ability to extend an instantiation with additional new fields or constructors.

     - Since typeclass declarations provide type-level functions, these can be
       pre-composed with functions that alter their inputs.
       E.g., ~MonoidP typeclass~ is a parmeterised type which is a function of types,
       so, for example, ~MonoidP typeclass ‚àò List~ is the same but the carrier is now
       lists over the provide parameter.

       - Likewise we provide support for a constraint upon the parameter:
         MonoidP typeclass using constraint
         reduces
         MonoidP typeclass field constraint : ...

         nice.

  1. Records, Haskell-style typeclasses,
     nested dependent sums with the carrier declared or existentially quantified,
     sums: Disjoint collection of declarations where each declaration is itself
     a dependet sum consistong of the context necessayr toensure that the consitnutets
     are well-typed.

     There are obvious isomorphisms and these should be guarentted.

  4. The ability to apply a string-to-string function to alter the names of constiuents
     ‚Äòdecorated‚Äô.

  5. Derive homomorphisms, strucutre preserving operations.

  6. Support multiple defaults.

  3. Constitients of package formers give rise to functions ---e.g., by replacing the
     PackageFormer name with a new fresh variable. See ùíØ, page 42, of thesis-proposal.

     In turn, this can be used to produce simple, tedious, induction principles. See (0) above.

  4. This is particularly useful when one wants to extract such constieunte types for re-use elsewhere.
  :End:

  The \textsf{\upshape PackageFormer} language feature unifies disparate representations of the
  same concept under a single banner. How does one actually /do/ anything with
  these entities? Are we forced to code along particular instantiations?
  No; unless we desire to do so.

* TODO \textsf{\upshape Variation} Polymorphism :outdated:
# # A New Kind of Polymorphism

  Suppose we want to produce the function ~concat~, which composes the elements of a list
  according to a compositionality scheme --- examples of this include summing over
  a list, multiplication over a list, checking all items in a list are true, or
  at least one item in the list is true.
  Depending on the selected instantiation,
  the resulting function may have types such as the following:

  \vspace{1em}
#+BEGIN_SRC agda
  concat‚ÇÄ : {M : Monoid‚ÇÄ}
          ‚Üí let C = Monoid‚ÇÄ.Carrier M
             in  List C ‚Üí C

  concat‚ÇÅ : {C : Set} {M : Monoid‚ÇÅ C} ‚Üí List C ‚Üí C

  concat‚ÇÇ : {C : Set} {_‚®æ_ : C ‚Üí C‚Üí C}
            {M : Monoid‚ÇÇ C _‚®æ_} ‚Üí List C ‚Üí C

  concat‚ÇÉ : List Monoid‚ÇÉ ‚Üí Monoid‚ÇÉ
#+END_SRC
  \vspace{1em}

  \noindent
  An attempt to unify these declarations requires understanding exactly
  /which type is referred to by the phrase MonoidP./
  For the ~termtype~ variation, it can only refer to the resulting algebraic data-type;
  whereas for the ~record~ variation, it could refer to the result record type /or/ to
  the ~Carrier~ projection of such record types. Consequently, we use monad-like notation
  ~do œÑ ‚Üê MonoidP; ‚ãØœÑ‚ãØ~ whenever we wish to refer to /values/ of the underlying carrier
  of a particular instantiation, rather than referring to the type /of/ such values.
  For example:
  \vspace{0.3em}
#+BEGIN_SRC agda
     do œÑ ‚Üê MonoidP record; ‚Ñ¨ œÑ
  ‚âà  Œª {œÑ : MonoidP record} ‚Üí ‚Ñ¨ (MonoidP.Carrier œÑ)

     do œÑ ‚Üê MonoidP termtype; ‚Ñ¨ œÑ
  ‚âà  ‚Ñ¨ (MonoidP termtype)
#+END_SRC
  \vspace{0.3em}
  \noindent
  This lets us write the following /variation polymorphic/ programs:
#+BEGIN_SRC agda
  concatP : {v : Variation}
          ‚Üí do œÑ ‚Üê MonoidP v; List œÑ ‚Üí œÑ
  concatP []       = MonoidP.Id
  concatP (x ‚à∑ xs) = x ‚®æ concatP xs
    where _‚®æ_ = MonoidP._‚®æ_
#+END_SRC

  \vspace{0.3em}
  \noindent
  It is important at this juncture to observe that the type of ~concatP~
  depends crucially on the variation ~v~ that is supplied, or inferred.
  This is a prime reason for using a dependently-typed language as the
  setting for the \textsf{\upshape PackageFormer} feature.

* TODO Next Steps :outdated:
  :Remarks:
  Ignoring the implementation, there are no sound semantics for these constructs.
     Discuss theory presentation combinators and possible extensions.
  :End:

  We have outlined a new unifying language feature that is intended to massively reduce
  duplicated efforts involving different perspectives of datatypes. Moreover, to make
  this tractable we have also provided a novel form of polymorphism and demonstrated
  it with minimal examples.

  # We have implemented a meta-program that realises these
  # elaborations in an unobtrusive
  # fashion: An Agda programmer simply declares them in special comments.
  # The resulting ‚Äòeditor tactic‚Äô demonstrates
  # that this language feature is promising.
  We have implemented this as an ``editor tactic'' meta-program.
  In actual use, an Agda programmer declares what they want
  using the combinators above (inside special Agda code comments),
  and these are then elaborated into Agda code.

  # Thus far we have relied on the reader's understanding of functional programming and
  # algebraic data types to provide an informal and indirect semantics by means of
  # elaborations into existing notions. An immediate next step would be to provide
  # explicit semantics for \textsf{\upshape PackageFormer}'s within a minimal type theory.
  We have presented our work indirectly by using examples, which we
  hope are sufficiently clear to indicate our intent. We next intend to
  provide explicit (elaboration) semantics for ~PackageFormer~ within a
  minimal type theory.

  Moreover there are a number of auxiliary goals, including:

  1. How do users extend the built-in ~Variations~ type along with the intended
     elaboration scheme.

     One possible route is for a user to ‚Äòinstall‚Äô a new variation by specifying
     where the separation line between parameters and fields happens; e.g.,
     by providing a function such as ~List Constituent ‚Üí Pair (List Constituent)~,
     which may introduce new names, such as the aforementioned ~Carrier~ and ~Vars.~

  2. Explain how generative modules cite:modular_modules
     are supported by this scheme.

  3. Demonstrate how boilerplate code for renamings, hidings, extensions,
     and the flattening of hierarchical structures can be formed;
     cite:tpc.

  4. How do multiple default, or optional, clauses for a constituent fit into this
     language feature.
     # This may necessitate a form of limited subtyping.

     # 5. Discuss inheritance, coercion, and transport along canonical isomorphisms.

  5. Flexible polymorphic definitions: One should be able to construct a program
     according to the most convenient presentation, but be able to have it
     /automatically/ applicable to other instantiations;
     cite:types_for_modules.
     # first_class_modules_support haskell_modules_formally

          # ~concatP : {v : Variation}  ‚Üí  do œÑ ‚Üê MonoidP v;  List œÑ ‚Üí œÑ~. \newline
     For example, the ~concat~ function was purely syntactic and the easiest formulation
     uses the algebraic data-type rendition, whence one would write \newline
     ~concat : List MonoidP termtype ‚Üí MonoidP termtype~ \newline
     and the variation is found, then systematically generalised to obtain \newline
     #+begin_src agda
concatP : {v : Variation}
        ‚Üí  do œÑ ‚Üê MonoidP v;  List œÑ ‚Üí œÑ
     #+end_src

     \vspace{1em}
     \noindent
     When there are multiple variations mentioned, the problem becomes less clear cut
     and the simplest solution may be to simply indicate which variation or occurrences
     thereof is intended to be generalised.

  \noindent
  Finally, the careful reader will have noticed
  that our abstract mentions graphs, yet
  there was no further discussion on that example.
  Indeed, one of the next goals is to
  accommodate multi-sorted structures where sorts may /depend/ on one another, as edge-sets
  depend on the vertex-set chosen.

  There are many routes to progress on this fruitful endeavour.
  # However, a prototype capable of supporting the examples mentioned
  # can be found at
  # \newline
  # https://alhassy.github.io/next-700-module-systems-proposal/.
  We have a complete
  prototype available on github, which we will link to once the paper is
  no longer double-blind.

  # We look forward to this feature reducing the length of our code
  # and alleviating us of tedious boilerplate constructions.

* Bib                                                                :ignore:

 #+latex: \bibliography{References}
 #+latex: \bibliographystyle{plainnat}

* OLD COMMENT other ideas

What about some context at the beginning of the first paragraph?

What does the term bundling refer to, bundling of what? and what kind of data exposure is a problem?
Suggestion (just an example of sth you can do), mention a record type (or something else) as a way of bundling, and explain that data exposure means what fields are exposed. I believe that is what you mean with type and value levels?

  ----other ideas----

  # We design and implement a language feature that allows both the library designer and user to make this choice as necessary.

  # True, but relevant?
  The more information known statically, the less arbitrary choices that need to be performed
  by inspecting data at runtime ---e.g., what to do when list elements, say in Java, differ
  or when list lengths, say in Haskell, differ when computing a dot product.
  However, it is not clear how much information exposure is ideal.

  For example, more exposure at the parameter or type-index level enforces too many constraints
  ---as in considering graphs /over/ a particular vertex set versus the type of graphs over an arbitrary
  vertex set. It thus appears that the context dictates which level of exposure is most appropriate.
  #
  # This definitely belongs in your abstract, but needs to be attached to something more concrete.
  #
  The traditional approach is to reduplicate utility functions or provide conversions between the few supported
  perspectives.
  Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
  and otherwise leave the ‚Äòbelt line‚Äô between parameters and fields unspecified.

  To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
  After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
  as users step-wise program.

** COMMENT OLD Abstract                                              :ignore:
   :PROPERTIES:
   :CUSTOM_ID: abstract
   :END:

 # Use:  x vs.{{{null}}} ys
 # This informs LaTeX not to put the normal space necessary after a period.
 #
 #+MACRO: null  @@latex:\null{}@@

 #+begin_center
 *Abstract*
 #+end_center
 #+begin_small
   Programming languages with sufficiently expressive type theories provide users with essentially two
   levels of data ‚Äòbundling‚Äô. One may expose important constituents at the type level or have them
   hidden at the value level. Alternatively put, which information is exposed dynamically at runtime and which is known
   statically. Rather than force a user to commit to a choice, we propose a language feature that allows such
   choices to be determined whenever is convenient for the task at hand.

   The more information known statically, the less arbitrary choices that need to be performed
   by inspecting data at runtime ---e.g., what to do when list elements, say in Java, differ
   or when list lengths, say in Haskell, differ when computing a dot product.
   However, it is not clear how much information exposure is ideal.
   For example, more exposure at the parameter or type-index level enforces too many constraints
   ---as in considering graphs /over/ a particular vertex set versus the type of graphs over an arbitrary
   vertex set. It thus appears that the context dictates which level of exposure is most appropriate.
   The traditional approach is to duplicate utility functions or provide conversions between the few supported
   perspectives.
   Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
   and otherwise leave the ‚Äòbelt line‚Äô between parameters and fields unspecified.

   To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
   After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
   as users step-wise program.
 #+end_small
 # \newpage
 # \thispagestyle{empty}
 # \tableofcontents
 # \newpage

** COMMENT OLD Introduction

   Programming languages with sufficiently expressive type theories provide users with essentially two
   levels of data ‚Äòbundling‚Äô. One may expose important constituents at the type level or have them
   hidden at the value level. Alternatively put, which information is exposed dynamically at runtime and which is known
   statically. Rather than force a user to commit to a choice, we propose a language feature that allows such
   choices to be determined whenever is convenient for the task at hand.

   For example, consider the dot-product $\Sigma_{i = 0}^n x_i \cdot y_i$ operation.
   It is unreasonable to have this as an operation of $2 \cdot n$ many numbers, instead of such a primitive type
   we may utilise the richer structure of vectors. Now what is the type of a vector ---is it ~Vec ‚Ñù n, Vec ‚Ñù,~ or just ~Vec~?
   That is, how much information is exposed at the type level and how much is hidden at the component value level.
   In the programming setting, nullary ~Vec~ may correspond to lists whose type is only known at runtime,
   whereas ~Vec ‚Ñù~ corresponds to lists of real numbers yet  the list length is known as run time, whereas
   ~Vec ‚Ñù n~ corresponds to lists of real numbers where the list length is statically known to be ~n~.

   Languages without sufficient support for polymorphism, such as old versions of Java, can only provide the nullary
   ~Vec~ form. The check that all the constituents are of the same type transpires at runtime, which necessities a decision
   of what is done when elements differ ---throwing an exception is common.
   In contrast, languages with elegant polymorphism support, such as Haskell, would have the element type pre-determined
   leaving the choice of what to do when vector lengths differ ---ignoring extra elements is common.
   Yet in dependently-typed languages, such as Agda, one can select either format or, better yet, have the length information
   at the type level. /The more information known statically, the less arbitrary choices that need to be performed./

   However, it is not clear how much information exposure is ideal.
   For example, when the type of elements is exposed we can easily form the dot-product
   and it would be awkward to phrase it otherwise. Perhaps a demonstration will clarify this further.
   {{{code(Typing the dot-product using different vector perspectives)}}}
   #+BEGIN_SRC agda
  data Vec (carrier : Set) (length : ‚Ñï) : Set where
    []  : Vec carrier 0
    _‚à∑_ : ‚àÄ {length : ‚Ñï}
      ‚Üí carrier ‚Üí Vec carrier length ‚Üí Vec carrier (length + 1)

  record Vec‚Ä≤ (carrier : Set)  : Set (‚Ñìsuc ‚Ñìzero) where
    field
      length   : ‚Ñï
      elements : Vec carrier length

  record Vec‚Ä≥ : Set (‚Ñìsuc ‚Ñìzero) where
    field
      carrier  : Set
      length   : ‚Ñï
      elements : Vec carrier length

   dot : ‚àÄ {n} (xs ys : Vec ‚Ñù n) ‚Üí ‚Ñù
   dot = ‚ãØ

   dot‚Ä≤ : (xs ys : Vec‚Ä≤ ‚Ñù) ‚Üí length xs ‚â° length ys ‚Üí ‚Ñù
   dot‚Ä≤ = ‚ãØ

   dot‚Ä≥ : (xs ys : Vec‚Ä≥)	‚Üí carrier xs ‚â° ‚Ñù  ‚Üí carrier ys ‚â° ‚Ñù
    ‚Üí length xs ‚â° length ys ‚Üí ‚Ñù
   dot‚Ä≥ = ‚ãØ
   #+END_SRC
   The more exposed data, the easier it is to type the dot-product.
   However, more exposure is not always ideal. For example, suppose we are interested
   is discussing the ubiquitous category ~ListSet~ whose objects are lists over some carrier set
   and whose morphisms are functions between the carrier sets. The type of objects cannot be
   ~Vec~ nor ~Vec‚Ä≤~ since they /enforce too many constraints/, instead it must be ~Vec‚Ä≥~.
   Hence, there is not best choice but it is contextual use that determines which presentation
   is most fitting. Are we then forced to re-duplicate the ~dot~ code for each level of exposure?
   Our proposed language feature suggests otherwise: /Write once, obtain many!/

   Interestingly, we can go so far as to form ~Vec ‚Ñù n xs~ to be the type consisting of a single formal value
   when ~xs~ is a list /and/ its constituents are of type ‚Ñù /and/ the list length is ~n~; and to have no value otherwise.
   This is, for nearly all uses, overkill; yet it begs the question /where is the line between parameters and component fields?/
   Traditionally, a library designer would make this choice and may provide views for the other perspectives.
   Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
   and otherwise leave the ‚Äòbelt line‚Äô between parameters and fields unspecified.

   To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
   After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
   as users step-wise program.

* COMMENT footer                                                     :ignore:

(shell-command "cp Paper0.pdf GPCE_19_Alhassy_Carette_Kahl.pdf")

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "make-acmart-class") (org-babel-execute-src-block))
# compile-command: (progn (org-babel-tangle) (org-latex-export-to-pdf) (async-shell-command "open Paper0.pdf"))
# End:
