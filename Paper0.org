# (shell-command "mv Paper0.pdf GPCE_19_Alhassy_Carette_Kahl.pdf")
# (shell-command "mv GPCE_19_Alhassy_Carette_Kahl.pdf Paper0.pdf")

# (progn (org-babel-tangle) (org-latex-export-to-pdf) (async-shell-command "open Paper0.pdf"))

# TITLE: Loosen your belt whenever you like
#+TITLE: A Language Feature to Unbundle Data at Will
#+DESCRIPTION: Thesis proposal for Musa Al-hassy; McMaster University 2019.
# AUTHOR: [[mailto:alhassm@mcmaster.ca][Musa Al-hassy]], [[mailto:carette@mcmaster.ca][Jacques Carette]], [[mailto:kahl@mcmaster.ca][Wolfram Kahl]]
#+AUTHOR: Musa Al-hassy, Jacques Carette, Wolfram Kahl
#+EMAIL: alhassy@gmail.com
#+OPTIONS: toc:nil d:nil title:t
#+PROPERTY: header-args :tangle no :comments link
#+TODO: TODO | OLD LaTeX

# At the end of a section, explain why the section is there,
# and what the reader should take away from it.

# MA: LaTeX pads colons, :, with spacing.
# For inline typing annotations, use ghost colon ‚Äú\:‚Äù to avoid this issue.

# Drop the 'proposed'. Use positive, active language like

# YS.
# Maybe start with asking what is the message you want to deliver in this paper? What kind of
# bundling is bad and why is it so?

# (add-to-list 'org-latex-text-markup-alist '(code . verb))
# (add-to-list 'org-latex-text-markup-alist '(verbatim . verb))

:WK_Tips:

‚óà Re: abstract:
Paragraph 1: Background and identified problem
Paragraph 2: Contribution

‚óà After code blocks, and especially before one-line paragraphs between
code blocks, always put \noindent unless there is a strong reason not to.
Also consider doubling the code block indentation.

‚óà  PacakageFormer --> \textsf{\upshape PackageFormer}
    [Code is ALWAYS typeset as code,
     just like math is always typeset as math.]

:End:
:JC_Remarks:
‚óÜ Consider Finite State Machines, rather than graphs, so as to have a multi-sorted
  structure where the sorts do not ‚Äòdepend‚Äô on each other.

- The introduction needs to cover the *problem* that is being solved - and not the solution; that is not 100% clear below
- You need to save space for related work (can be a short paragraph, but without it, it'll get rejected)
- Where are the citations? There should be citations throughout!
:End:

* LaTeX setup                                                        :ignore:
#+latex_class_options: [sigplan,review,anonymous]
# latex_class_options: [acmsmall,review,anonymous]
# latex_class_options: [acmsmall,review]
#+LATEX_CLASS: acmart

#+LATEX_HEADER: \settopmatter{printfolios=true,printccs=false,printacmref=false}
#+LATEX_HEADER: \usepackage[backend=biber,style=alphabetic]{biblatex}
#+LATEX_HEADER: \addbibresource{MyReferences.bib}
#+LATEX_HEADER: \usepackage{edcomms}

#+LATEX_HEADER: \acmJournal{GPCE}
# LATEX_HEADER: \acmVolume{1}
#+LATEX_HEADER: \acmNumber{GPCE}
# LATEX_HEADER: \acmArticle{1}
#+LATEX_HEADER: \acmYear{2019}
# LATEX_HEADER: \acmMonth{1}
# LATEX_HEADER: \acmDOI{}
#+LATEX_HEADER: \setcopyright{none}

#+LATEX_HEADER: \usepackage{MyUnicodeSymbols}
#+LATEX_HEADER: \newunicodechar{‚®æ}{\ensuremath{\mathop{\fatsemi}}}
#+LATEX_HEADER: \newunicodechar{‚â¢}{\ensuremath{\nequiv}}
#+LATEX_HEADER: \newunicodechar{œÑ}{\ensuremath{\tau}}
#+LATEX_HEADER: \newunicodechar{‚ÇÑ}{\ensuremath{_4}}
#+LATEX_HEADER: \newunicodechar{‚Ä≤}{'}
#+LATEX_HEADER: \newunicodechar{‚Ä≥}{''}

# LATEX_HEADER: \usepackage[dvipsnames]{xcolor} % named colours
#+LATEX_HEADER: \usepackage{xcolor} % named colours
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \definecolor{darkred}{rgb}{0.3, 0.0, 0.0}
#+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
#+LATEX_HEADER: \definecolor{darkblue}{rgb}{0.0, 0.1, 0.3}
#+LATEX_HEADER: \definecolor{darkorange}{rgb}{1.0, 0.55, 0.0}
#+LATEX_HEADER: \definecolor{sienna}{rgb}{0.53, 0.18, 0.09}
#+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkgreen}

# Having small-font code blocks.
# LATEX_HEADER: \RequirePackage{fancyvrb}
# LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}

#+BEGIN_EXPORT latex
% \author{Musa Al-hassy}
% \affiliation{
%   \institution{McMaster University}
%   \streetaddress{1280 Main St. W.}
%   \city{Hamilton}
%   \state{ON}
%   \postcode{L8S 4K1}
%   \country{Canada}}
% \email{alhassm@mcmaster.ca}
% \author{Jacques Carette}
% \author{Wolfram Kahl}
#+END_EXPORT

** COMMENT acmart Emacs setup
 #+NAME: make-acmart-class
 #+BEGIN_SRC emacs-lisp :results none
(with-eval-after-load "ox-latex"
   (add-to-list 'org-latex-classes
        '("acmart" "\\documentclass{acmart}"
          ("\\section{%s}" . "\\section*{%s}")
          ("\\subsection{%s}" . "\\subsection*{%s}")
          ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
          ("\\paragraph{%s}" . "\\paragraph*{%s}")
          ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
 #+END_SRC

* Abstract :ignore:
#+begin_center
*Abstract*
#+end_center
#+begin_small

  # The eager commit to what data should be a type parameter or a record component
  # is a premature design decision. We demonstrate a language feature that circumvents
  # such over-specification.
  #
  # WK:  That's quite a mouthful and hard to parse. Perhaps establish some context first?

  # This is analogous to
  # which information is exposed dynamically at runtime and which is known statically,
  # respectively.

  Programming languages with sufficiently expressive type theories provide users with
  different means of data ‚Äòbundling‚Äô. Specifically one can choose to encode information
  in a record either as a parameter or a field, in depdently-typed languages such as
  Agda, Coq, Lean and Idris.
  For example, we can speak of graphs /over/ a particular vertex set, or speak
  of arbitrary graphs where the vertex set is a component.
  These create isomorphic types, but differ with respect to intended use.
  Traditionally, a library designer would make this choice (between parameters and fields);
  if a user wants a different variant, they are forced to build conversion utilities as well as
  duplicate functionality. For a graph data type,
  if a library only provides a Haskell-like typeclass view of graphs /over/ a vertex set,
  yet a user wishes to work with the category of graphs, they must now package a vertex
  set as a component in a record along with a graph over that set.

  We design and implement a language feature that allows both the library designer and
  the user to make the choice of information exposure only when necessary, and otherwise leave
  the distinguishing line between parameters and fields unspecified.
  Our language feature is currently implemented as a prototype meta-program
  incorporated into Agda's Emacs ecosystem, in a way that is unobtrusive to Agda users.
#+end_small

* Introduction --- Selecting the ‚Äòright‚Äô perspective

  :Ideas:
  Which perspective of semigroups does one select? Semigroupùíæ from the thesis proposal;
     the perspective considered should have legitimate uses rather than artificial ones.
     How do we write, e.g., ‚Äòconcat‚Äô in the various forms. What is the minimal reduplication required using
     existing techniques.
   :End:

  Library designers want to produce software components that are useful to for
  the perceived needs of a variety of users and usage scenarios.  It is therefore
  natural for designers to aim for a high-level of generality, in the hopes of increased
  reusability. One such particular ``choice'' will occupy us here: When creating a
  record to bundle up certain information that ``naturally'' belongs together, what
  parts of that record should be /parameters/ and what parts should be
  /fields/? This is analogous to whether functions are curried and so arguments
  may be provided partially, or otherwise must be provided all-together in one tuple.

  The subtlety of what is a ‚Äòparameter‚Äô ---exposed at the type level--- and what is a
  ‚Äòfield‚Äô ---a component value--- has led to awkward formulations and
  the duplication of existing types for the sole purpose of different uses.

  :JC:
  \edcomm{JC}{Incorporate a little bit of the text of Tom Hales' critique of
  Lean, verbation and cite, here}

  MA: If you mean [[https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/][this review]], then you likely mean item 4 regarding the issues
  of Lean being its own metalanguage. However, this appears to be problematic
  due to limited man-power working on Lean: ‚Äúthe tools simply are not available‚Äù.
  Item 7 regarding ugly projection chains has already been addressed below, briefly,
  when mentioning flattening. Re item 9, Agda allows [simulated] diamonds.
  Re item 10, that's what's being addressed in this work.
  :End:

  # For example, the ubiquitous monoid, used to model compositionality,
  # in Haskell, is only allowed one instance per datatype. However, the Booleans,
  # for example, support multiple monoid instances such as sequential and parallel monoids
  # ---the former being conjunction with
  # identity /true/ and the latter being disjunction with identity /false/.
  For example, each Haskell typeclass can have only one instance per datatype;
  since there are several monoids with the datatype ~Bool~ as carrier,
  in particular those induced by conjunction and disjunction,
  the de-facto-standard libraries for Haskell
  define two isomorphic copies ~All~ and ~Any~ of ~Bool~,
  only for the purpose of being able to attach the respective monoid instances to them.

  But perhaps Haskell's type system does not give the programmer sufficient
  tools to adequately express such ideas. As such, for the rest of this paper
  we will illustrate our ideas in Agda \cite{agda_overview}.
  For the monoid example,
  it seems that there are three contenders for the monoid interface:
  \newpage
  #+begin_src agda
  record Monoid‚ÇÄ : Set‚ÇÅ where
    field
      Carrier : Set
      _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
      Id      : Carrier
      assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
      leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
      rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x

  record Monoid‚ÇÅ (Carrier : Set) : Set where
    field
      _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
      Id      : Carrier
      assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
      leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
      rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x

  record Monoid‚ÇÇ (Carrier : Set)
                 (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) : Set where
     Id      : Carrier
     assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
     leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
     rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x
  #+end_src

  \vspace{0.3em}
  In ~Monoid‚ÇÄ~, we will call ~Carrier~ ``bundled up'',
  while we call it ``exposed'' in ~Monoid‚ÇÅ~ and ~Monoid‚ÇÇ~.
  The bundled-up version allows us to speak of /a/
  monoid, rather than /a monoid on a given type/ which is captured by ~Monoid‚ÇÅ~.
  While ~Monoid‚ÇÇ~ exposes both the carrier and the composition operation,
  we might in some situation be interested
  in exposing the identity element instead
  --- e.g., the discrepancy ‚Äò‚â¢‚Äô and indistinguishability ‚Äò‚â°‚Äô operations
  on the Booleans
  have the same identities as conjunction and disjunction, respectively.
  Moreover, there are other combinations of what is to be exposed and hidden,
  for applications that we might never think of.

  Rather than code with /interface formulations we think people will likely use/, it is far
  more general to /commit to no particular formulation/ and allow the user to select
  the form most convenient for their use-cases. This desire for reusability motivates
  a new language feature: The \textsf{\upshape PackageFormer}.

  Moreover, what if the user wanted the syntax to form monoid terms as in
  metaprogramming.
  \edcomm{JC}{This is too imprecise --- please put specific Agda code
    for MonoidTerm (you have the room) instead. Then you can say
    something like "We can see that this version can also be
    mechanically obtained from Monoid_1 by turning each field into a
    constructor". This will make the idea much clearer.}
  That would necessitate yet another nearly identical data-structure
  --- having constructors rather than field projections.

  We show how all these different
  presentations can be derived from a /single/ \textsf{\upshape PackageFormer} declaration.
  It is this massive reduction in duplicated efforts and maintenance that we view
  as the main contribution of our work.
  \edcomm{JC}{``massive reduction in duplicated efforts and maintenance'' begs the
   question of doing a quantitative study to measure this --- which you have
   neither done, nor intend to do.}

* \textsf{\upshape PackageFormer}s --- Being non-committal as much as possible
  :Remarks:
  Unifying the different perspectives under the same banner. We speak in terms of elaborations,
     but may propose elementary typing rules or semantics. Discuss \textsf{\upshape PackageFormer} polymorphism, from ¬ß4 of thesis proposal.
     :End:

    # It is notoriously difficult to reconstruct the possible inputs to a function
    # that yielded a certain output.
    # That is, unless you are using Prolog of-course,
    # where the distinctions between input and output are an illusion
    # that is otherwise
    # made real only by how Prolog users treat arguments to a relation.
    # Dependently-typed programming at its core is the adamant hygienic blurring of
    # concepts
    # ---namely, types are terms \cite{types_overview}---
    # and so the previous presentations of monoids are unified in the following
    # single declaration which does not distinguish between parameters and fields.
    #
    We claim that the previous monoid-related pieces of Agda code
    can all be unified as a single declaration
    which does not distinguish between parameters and fields,
    where ~PackageFormer~ is a keyword with similar syntax as ~record~:

      #+begin_src agda
  PackageFormer MonoidP : Set where
     _‚®æ_    : MonoidP ‚Üí MonoidP ‚Üí MonoidP
    Id      : MonoidP
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x
  #+end_src

  \noindent
  Coupled with various `directives' that let one declare
  what should be parameters and what should be fields,
  we can reproduce the above.
  Notice that here ~Carrier~ has been removed in favour of the name MonoidP,
  which also is the name of the newly declared entity.
  This does indeed mean that so far our facility is //single sorted//.
  ## Superficially, the parameters and fields have been flattened into a single location
  ## and the name ~Carrier~ has been dispensed with in-favour of ~MonoidP~,
  ## which also happens to be name of this newly declared entity.
  #
  # MA: We commend the astute reader who has noticed a hint of predicitivity here,
  # but it is an issue we shall not address in the current work.
  #
  # WK: No, as a matter of courtesy.

  #+BEGIN_EXPORT latex
  \emph{One uses a \textsf{\upshape PackageFormer} by instantiating the particular presentation that is desired.}
  #+END_EXPORT

  We conceive of an extensible type ~Variations~ which includes ~datatype~ and ~record~
  as two keywords. Moreover, this type is equipped with a number of combinators, one
  of which is the infix operator ~_unbundled_ : Variation ‚Üí ‚Ñï ‚Üí Variation~ which modifies a particular
  presentation by also lifting the first ~n~ constituents from the field level to the
  parameter level. In particular, ~typeclass = record unbundled 1~.
  We also allow the named version of this combinator, namely
  ~_exposing_ : Variation ‚Üí List Name ‚Üí Variation~.
  Instantiation syntax is of the form ~‚Äú‚ü™package-former-name‚ü´ ‚ü™variation‚ü´‚Äù~,
  as such, ~_unbundled_~  and ~_exposing_~ have higher precedence.
  Let us demonstrate these concepts.

  0. [@0] We may obtain the previous formulations of ~Monoid‚ÇÅ~ in two different ways:
        \vspace{0.3em}
    #+begin_src agda
 Monoid‚ÇÅ‚Ä≤  = MonoidP typeclass
 Monoid‚ÇÅ‚Ä≥ = MonoidP record exposing Carrier
#+end_src

    \vspace{0.3em}

  1. Likewise, there are number of ways to regain the previous formulation of ~Monoid‚ÇÇ~.
        \vspace{0.3em}
    #+begin_src agda
 Monoid‚ÇÇ‚Ä≤  = MonoidP record unbundled 2
 Monoid‚ÇÇ‚Ä≥ = MonoidP record exposing (Carrier; _‚®æ_)
#+end_src

      \vspace{0.3em}

Our precedence rules indicate that ~MonoidP ‚ãØ~ parenthesises as if it were ~MonoidP (‚ãØ)~.
Moreover, notice that the infix combinators for unbundling and exposing,
behave similar to the curry functional $(A √ó B ‚Üí C) \;‚Üí\; (A ‚Üí B ‚Üí C)$.

  2. [@2] To speak of /a monoid over an arbitrary carrier/, we declare:
        \vspace{0.3em}
   #+begin_src agda
 Monoid‚ÇÉ = MonoidP record
#+end_src
   \vspace{0.3em}
   \noindent
   It behaves as if it were declared thusly:
   \vspace{0.3em}
   \noindent
   #+begin_src agda
    record Monoid‚ÇÉ : Set‚ÇÅ where
      field
        Carrier : Set
        _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
        Id      : Carrier
        ‚ãØ
#+end_src

  The name ~Carrier~ is a default and could be renamed; likewise for ~Vars~ below.

  3. [@3] Finally, we mentioned metaprogramming's need to work with terms:
        \vspace{0.3em}
    #+begin_src agda
 Monoid‚ÇÑ = MonoidP datatype
#+end_src
    \vspace{0.3em}
    \noindent
    It behaves as if it were declared thusly:
       \vspace{0.3em}
        \noindent
     #+begin_src agda
    data Monoid‚ÇÑ : Set where
      _‚®æ_ : Monoid‚ÇÑ ‚Üí Monoid‚ÇÑ ‚Üí Monoid‚ÇÑ
      Id  : Monoid‚ÇÑ
#+end_src
   \vspace{0.3em}
   \noindent
   Of course we may want to have terms /over/ a particular variable set, and so declare:
      \vspace{0.3em}
     #+begin_src agda
 Monoid‚ÇÖ = MonoidP datatype exposing (Vars)
#+end_src
    \vspace{0.3em}
    \noindent
    It behaves as if it were declared thusly:
       \vspace{0.3em}
       \noindent
    #+begin_src agda
    data Monoid‚ÇÖ (Vars : Set) : Set where
      inj : Vars ‚Üí Monoid‚ÇÑ Vars
      _‚®æ_ : Monoid‚ÇÑ Vars ‚Üí Monoid‚ÇÑ Vars ‚Üí Monoid‚ÇÑ Vars
      Id  : Monoid‚ÇÑ Vars
  #+end_src

     \vspace{0.3em}
     \noindent
     Note that only ‚Äòfunctional‚Äô symbols have been exposed in these elaborations; no ‚Äòproof-matter‚Äô.

  There are of-course a number of variation on how a package is to be presented,
  we have only mentioned two for brevity. The interested reader may consult
  the ‚Äònext 700 module systems‚Äô proposal \cite{alhassy_thesis_proposal};
  which discusses more variations and examples in detail.

  The \textsf{\upshape PackageFormer} language feature unifies disparate representations of the
  same concept under a single banner. How does one actually /do/ anything with
  these entities? Are we forced to code along particular instantiations?
  No; unless we desire to do so.

* A New Kind of Polymorphism

  Suppose we want to produce the function ~concat~, which composes the elements of a list
  according to a compositionality scheme ---examples of this include summing over
  a list, multiplication over a list, checking all items in a list are true, or
  at least one item in the list is true. Depending on the interface presentation
  selected, the typing of this function could be elegant or awkward, as follows.

  \vspace{1em}
#+BEGIN_SRC agda
  concat‚ÇÅ : {C : Set} {M : Monoid‚ÇÅ C} ‚Üí List C ‚Üí C

  concat‚ÇÇ : {C : Set} {_‚®æ_ : C ‚Üí C‚Üí C} {M : Monoid‚ÇÇ C _‚®æ_} ‚Üí List C ‚Üí C

  concat‚ÇÉ : {M : Monoid‚ÇÉ} ‚Üí let C = Monoid‚ÇÉ.Carrier M  in  List C ‚Üí C

  concat‚ÇÑ : List Monoid‚ÇÑ ‚Üí Monoid‚ÇÑ
#+END_SRC
  \vspace{1em}

  An immediate attempt to unify these declarations requires pinpointing exactly
  /which type is referred to semantically by the phrase MonoidP./
  For the ~datatype~ variation, it could only refer to the resulting algebraic data-type;
  whereas for the ~record~ variation, it could refer to the result record type /or/ to
  the ~Carrier~ projection of such record types. Consequently, we use monad-like notation
  ~do œÑ ‚Üê MonoidP; ‚ãØœÑ‚ãØ~ whenever we wish to refer to /values/ of the underlying carrier
  of a particular instantiaiton, rather than referring to the type /of/ such values.
  In particular:
  \vspace{0.3em}
#+BEGIN_SRC agda
  do œÑ ‚Üê MonoidP record; ‚Ñ¨ œÑ    ‚âà  Œª {œÑ : MonoidP record}
                                      ‚Üí ‚Ñ¨ (MonoidP.Carrier œÑ)

  do œÑ ‚Üê MonoidP datatype; ‚Ñ¨ œÑ  ‚âà  ‚Ñ¨ (MonoidP datatype)
#+END_SRC
  \vspace{0.3em}
  \noindent
  With this understanding in-hand, we may write /variation polymorphic/ programs:
#+BEGIN_SRC agda
  concatP : {v : Variation}  ‚Üí  do œÑ ‚Üê MonoidP v;  List œÑ ‚Üí œÑ
  concatP []       = MonoidP.Id
  concatP (x ‚à∑ xs) = x ‚®æ concatP xs where _‚®æ_ = MonoidP._‚®æ_
#+END_SRC

  \vspace{0.3em}
  \noindent
  It is important at this juncture to observe that the type of ~concatP~
  depends crucially on the variation ~v~ that is supplied, or inferred.
  This is a prime reason for using a dependently-typed language as the
  setting for the \textsf{\upshape PackageFormer} feature.

* Next Steps
  :Remarks:
  Ignoring the implementation, there are no sound semantics for these constructs.
     Discuss theory presentation combinators and possible extensions.
  :End:

  We have outlined a new unifying language feature that is intended to massively reduce
  duplicated efforts involving different perspectives of datatypes. Moreover, to make
  this tractable we have also provided a novel form of polymorphism and demonstrated
  it with minimal examples.

  We have implemented a meta-program that realises these elaborations in an unobtrusive
  fashion: An Agda programmer simply declares them in special comments.
  The resulting ‚Äòeditor tactic‚Äô demonstrates that this language feature is promising.

  Thus far we have relied on the reader's understanding of functional programming and
  algebraic data types to provide an informal and indirect semantics by means of
  elaborations into existing notions. An immediate next step would be to provide
  explicit semantics for \textsf{\upshape PackageFormer}'s within a minimal type theory.
  Moreover there are a number of auxiliary goals, including:

  1. How do users extend the built-in ~Variations~ type along with the intended
     elaboration scheme.

     One possible route is for a user to ‚Äòinstall‚Äô a new variation by specifying
     where the separation line between parameters and fields happens; e.g.,
     by providing a function such as ~List Constituent ‚Üí Pair (List Constituent)~,
     which may introduce new names, such as the aforementioned ~Carrier~ and ~Vars.~

  2. Explain how generative modules \cite{modular_modules}
     are supported by this scheme, and they indeed are.

  3. Demonstrate how tedious boilerplate code for renamings, hidings, extensions,
     and the flattening of hierarchical structures can be formed;
     \cite{tpc}.

  4. How do multiple default, or optional, clauses for a constituent fit into this
     language feature. This may necessitate a form of limited subtyping.

  5. Discuss inheritance, coercion, and transport along canonical isomorphisms.

  6. Flexible polymorphic definitions: One should be able to construct a program
     according to the most convenient presentation, but be able to have it
     /automatically/ applicable to other instantiations;
     \cite{types_for_modules}.
     # first_class_modules_support haskell_modules_formally

     For example, the ~concat~ function was purely syntactic and the easiet formulation
     uses the algebraic data-type rendition, whence one would write \newline
     ~concat : List MonoidP datatype ‚Üí MonoidP datatype~ \newline
     and the variation is found then systematically generalised to obtain \newline
     ~concatP : {v : Variation}  ‚Üí  do œÑ ‚Üê MonoidP v;  List œÑ ‚Üí œÑ~. \newline
     When there are multiple variations mentioned, the problem becomes less clear cut
     and the simplest solution may be to simply indicate which variation or occurrences
     thereof is intended to be generalised.

  Finally, the astute reader will have remembered that our abstract mentions graphs yet
  there was no further discussion on that example. Indeed, one of the next goals is to
  accommodate multi-sorted structures where sorts may /depend/ on one another, as edge-sets
  depend on the vertex-set chosen.

  There are many routes to progress on this fruitful endeavour.
  However, a prototype capable of supporting the examples mentioned can be found at
  \newline
  https://alhassy.github.io/next-700-module-systems-proposal/.

  We look forward to this feature reducing the length of our code
  and alleviating us of tedious boilerplate constructions.

* OLD COMMENT other ideas

What about some context at the beginning of the first paragraph?

What does the term bundling refer to, bundling of what? and what kind of data exposure is a problem?
Suggestion (just an example of sth you can do), mention a record type (or something else) as a way of bundling, and explain that data exposure means what fields are exposed. I believe that is what you mean with type and value levels?

  ----other ideas----

  # We design and implement a language feature that allows both the library designer and user to make this choice as necessary.

  # True, but relevant?
  The more information known statically, the less arbitrary choices that need to be performed
  by inspecting data at runtime ---e.g., what to do when list elements, say in Java, differ
  or when list lengths, say in Haskell, differ when computing a dot product.
  However, it is not clear how much information exposure is ideal.

  For example, more exposure at the parameter or type-index level enforces too many constraints
  ---as in considering graphs /over/ a particular vertex set versus the type of graphs over an arbitrary
  vertex set. It thus appears that the context dictates which level of exposure is most appropriate.
  #
  # This definitely belongs in your abstract, but needs to be attached to something more concrete.
  #
  The traditional approach is to reduplicate utility functions or provide conversions between the few supported
  perspectives.
  Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
  and otherwise leave the ‚Äòbelt line‚Äô between parameters and fields unspecified.

  To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
  After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
  as users step-wise program.

** COMMENT OLD Abstract                                              :ignore:
   :PROPERTIES:
   :CUSTOM_ID: abstract
   :END:

 # Use:  x vs.{{{null}}} ys
 # This informs LaTeX not to put the normal space necessary after a period.
 #
 #+MACRO: null  @@latex:\null{}@@

 #+begin_center
 *Abstract*
 #+end_center
 #+begin_small
   Programming languages with sufficiently expressive type theories provide users with essentially two
   levels of data ‚Äòbundling‚Äô. One may expose important constituents at the type level or have them
   hidden at the value level. Alternatively put, which information is exposed dynamically at runtime and which is known
   statically. Rather than force a user to commit to a choice, we propose a language feature that allows such
   choices to be determined whenever is convenient for the task at hand.

   The more information known statically, the less arbitrary choices that need to be performed
   by inspecting data at runtime ---e.g., what to do when list elements, say in Java, differ
   or when list lengths, say in Haskell, differ when computing a dot product.
   However, it is not clear how much information exposure is ideal.
   For example, more exposure at the parameter or type-index level enforces too many constraints
   ---as in considering graphs /over/ a particular vertex set versus the type of graphs over an arbitrary
   vertex set. It thus appears that the context dictates which level of exposure is most appropriate.
   The traditional approach is to duplicate utility functions or provide conversions between the few supported
   perspectives.
   Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
   and otherwise leave the ‚Äòbelt line‚Äô between parameters and fields unspecified.

   To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
   After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
   as users step-wise program.
 #+end_small
 # \newpage
 # \thispagestyle{empty}
 # \tableofcontents
 # \newpage

** COMMENT OLD Introduction

   Programming languages with sufficiently expressive type theories provide users with essentially two
   levels of data ‚Äòbundling‚Äô. One may expose important constituents at the type level or have them
   hidden at the value level. Alternatively put, which information is exposed dynamically at runtime and which is known
   statically. Rather than force a user to commit to a choice, we propose a language feature that allows such
   choices to be determined whenever is convenient for the task at hand.

   For example, consider the dot-product $\Sigma_{i = 0}^n x_i \cdot y_i$ operation.
   It is unreasonable to have this as an operation of $2 \cdot n$ many numbers, instead of such a primitive type
   we may utilise the richer structure of vectors. Now what is the type of a vector ---is it ~Vec ‚Ñù n, Vec ‚Ñù,~ or just ~Vec~?
   That is, how much information is exposed at the type level and how much is hidden at the component value level.
   In the programming setting, nullary ~Vec~ may correspond to lists whose type is only known at runtime,
   whereas ~Vec ‚Ñù~ corresponds to lists of real numbers yet  the list length is known as run time, whereas
   ~Vec ‚Ñù n~ corresponds to lists of real numbers where the list length is statically known to be ~n~.

   Languages without sufficient support for polymorphism, such as old versions of Java, can only provide the nullary
   ~Vec~ form. The check that all the constituents are of the same type transpires at runtime, which necessities a decision
   of what is done when elements differ ---throwing an exception is common.
   In contrast, languages with elegant polymorphism support, such as Haskell, would have the element type pre-determined
   leaving the choice of what to do when vector lengths differ ---ignoring extra elements is common.
   Yet in dependently-typed languages, such as Agda, one can select either format or, better yet, have the length information
   at the type level. /The more information known statically, the less arbitrary choices that need to be performed./

   However, it is not clear how much information exposure is ideal.
   For example, when the type of elements is exposed we can easily form the dot-product
   and it would be awkward to phrase it otherwise. Perhaps a demonstration will clarify this further.
   {{{code(Typing the dot-product using different vector perspectives)}}}
   #+BEGIN_SRC agda
  data Vec (carrier : Set) (length : ‚Ñï) : Set where
    []  : Vec carrier 0
    _‚à∑_ : ‚àÄ {length : ‚Ñï}
      ‚Üí carrier ‚Üí Vec carrier length ‚Üí Vec carrier (length + 1)

  record Vec‚Ä≤ (carrier : Set)  : Set (‚Ñìsuc ‚Ñìzero) where
    field
      length   : ‚Ñï
      elements : Vec carrier length

  record Vec‚Ä≥ : Set (‚Ñìsuc ‚Ñìzero) where
    field
      carrier  : Set
      length   : ‚Ñï
      elements : Vec carrier length

   dot : ‚àÄ {n} (xs ys : Vec ‚Ñù n) ‚Üí ‚Ñù
   dot = ‚ãØ

   dot‚Ä≤ : (xs ys : Vec‚Ä≤ ‚Ñù) ‚Üí length xs ‚â° length ys ‚Üí ‚Ñù
   dot‚Ä≤ = ‚ãØ

   dot‚Ä≥ : (xs ys : Vec‚Ä≥)	‚Üí carrier xs ‚â° ‚Ñù  ‚Üí carrier ys ‚â° ‚Ñù
    ‚Üí length xs ‚â° length ys ‚Üí ‚Ñù
   dot‚Ä≥ = ‚ãØ
   #+END_SRC
   The more exposed data, the easier it is to type the dot-product.
   However, more exposure is not always ideal. For example, suppose we are interested
   is discussing the ubiquitous category ~ListSet~ whose objects are lists over some carrier set
   and whose morphisms are functions between the carrier sets. The type of objects cannot be
   ~Vec~ nor ~Vec‚Ä≤~ since they /enforce too many constraints/, instead it must be ~Vec‚Ä≥~.
   Hence, there is not best choice but it is contextual use that determines which presentation
   is most fitting. Are we then forced to re-duplicate the ~dot~ code for each level of exposure?
   Our proposed language feature suggests otherwise: /Write once, obtain many!/

   Interestingly, we can go so far as to form ~Vec ‚Ñù n xs~ to be the type consisting of a single formal value
   when ~xs~ is a list /and/ its constituents are of type ‚Ñù /and/ the list length is ~n~; and to have no value otherwise.
   This is, for nearly all uses, overkill; yet it begs the question /where is the line between parameters and component fields?/
   Traditionally, a library designer would make this choice and may provide views for the other perspectives.
   Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
   and otherwise leave the ‚Äòbelt line‚Äô between parameters and fields unspecified.

   To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
   After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
   as users step-wise program.

* Bib  :ignore:
#+LaTeX: \printbibliography
* COMMENT References
@online{alhassy_thesis_proposal,
  author    = {Musa Al-hassy},
  title     = {The Next 700 Module Systems: Extending Dependently-Typed Languages to Implement Module System Features In The Core Language},
  school    = {McMaster University},
  year      = {2019},
  url       = {https://alhassy.github.io/next-700-module-systems-proposal/thesis-proposal.pdf}
}

@InProceedings{types_for_modules,
  author       = {Derek Dreyer and Karl Crary and Robert Harper},
  title        = {A Type System for Higher-Order Modules},
  year         = 2003,
  booktitle    = {Conference Record of {POPL} 2003: The 30th
                  {SIGPLAN-SIGACT} Symposium on Principles of
                  Programming Languages, New Orleans, Louisisana, USA,
                  January 15-17, 2003},
  pages        = {236-249},
  doi          = {10.1145/640128.604151},
  url          = {https://doi.org/10.1145/640128.604151},
  timestamp    = {Tue, 06 Nov 2018 11:07:43 +0100},
  biburl       = {https://dblp.org/rec/bib/conf/popl/DreyerCH03},
  bibsource    = {dblp computer science bibliography,
                  https://dblp.org}
}

@InProceedings{agda_overview,
  author       = {Ana Bove and Peter Dybjer and Ulf Norell},
  title        = {A Brief Overview of Agda - {A} Functional Language
                  with Dependent Types},
  year      = {2009},
  booktitle    = {Theorem Proving in Higher Order Logics, 22nd
                  International Conference, TPHOLs 2009, Munich,
                  Germany, August 17-20, 2009. Proceedings},
  pages        = {73-78},
  doi          = {10.1007/978-3-642-03359-9\_6},
  url          = {https://doi.org/10.1007/978-3-642-03359-9\_6},
  timestamp    = {Tue, 14 May 2019 10:00:48 +0200},
  biburl       = {https://dblp.org/rec/bib/conf/tphol/BoveDN09},
  bibsource    = {dblp computer science bibliography,
                  https://dblp.org}
}

@Online{types_overview,
  author       = {Nino Guallart},
  title        = {{An overview of type theories}},
  year         = 2014,
  archiveprefix= {arXiv},
  eprint       = {1411.1029v2},
  primaryclass = {math.LO}
}

* COMMENT footer                                                     :ignore:
#### eval: (progn (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "make-acmart-class") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# compile-command: (progn (org-babel-tangle) (org-latex-export-to-pdf) (async-shell-command "open Paper0.pdf"))
# End:
